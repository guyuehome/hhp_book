{"config":{"indexing":"full","lang":["en","ja"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"","text":"引言 机器人是一个非常复杂的系统，硬件部分包括：各种各样感知环境信息的传感器、作为大脑进行计算的主控平台、执行动作的电机等等。软件层面包括：感知算法，规控算法，数据驱动的程式，操作系统等。 2022年6月，地平线机器人正式推出全新一代机器人开发平台，在软件、算法、工具层面给行业带来更多帮助。 本教程将会以旭日X3派为平台，介绍地平线机器人开发平台的使用原理与方法。 教程链接汇总 旭日X3派开发板使用手册： https://developer.horizon.ai/api/v1/fileData/documents_pi/index.html 机器人开发平台使用手册： https://developer.horizon.ai/api/v1/fileData/TogetherROS/index.html 视频课程： https://class.guyuehome.com/all/10284445/19617453 图文教程： https://hhp.guyuehome.com/ 教程问答： https://www.guyuehome.com/Bubble/circleDetail/id/92 博客泡圈： https://www.guyuehome.com/","text_tokens":["各样","all","复杂","com","html","感知","驱动","数据","传感器","主控","环境","更","92","平台",":","工具","与","派","hhp","、","带来","id","全新","博客","以","传感","介绍","机器","问答","教程","使用手册","开发","系统","软件","6","developer","机器人","www","年","，","documents","地平线","api","使用","class","视频",".","课程","x3","操作","10284445","horizon","等","链接","行业","图文","引言","部分","19617453","推出","操作系统","进行","信息","月","在","包括","硬件","ai","togetherros","各种各样","算法","动作","电机","_","汇总","给","一个","层面","正式","作为","guyuehome","计算","。","非常复杂","程式","filedata","是","：","一代","pi","的","bubble","开发板","为","执行","旭日","circledetail","帮助","方法"," ","https","将会","感器","2022","等等","规控","多","各种","大脑","v1","原理","泡圈","地平","index","本","手册","/","非常"],"title":"引言","title_tokens":["引言"]},{"location":"#_1","text":"机器人是一个非常复杂的系统，硬件部分包括：各种各样感知环境信息的传感器、作为大脑进行计算的主控平台、执行动作的电机等等。软件层面包括：感知算法，规控算法，数据驱动的程式，操作系统等。 2022年6月，地平线机器人正式推出全新一代机器人开发平台，在软件、算法、工具层面给行业带来更多帮助。 本教程将会以旭日X3派为平台，介绍地平线机器人开发平台的使用原理与方法。","text_tokens":["各样","复杂","感知","驱动","数据","传感器","主控","环境","更","平台","工具","与","派","、","带来","全新","以","传感","介绍","机器","教程","开发","系统","软件","6","机器人","年","，","地平线","使用","x3","操作","等","行业","部分","推出","操作系统","进行","信息","月","在","包括","硬件","各种各样","算法","动作","电机","给","一个","层面","正式","作为","计算","。","非常复杂","程式","是","：","一代","的","为","执行","旭日","帮助","方法"," ","将会","感器","2022","等等","规控","多","各种","大脑","原理","地平","本","非常"],"title":"引言","title_tokens":["引言"]},{"location":"#_2","text":"旭日X3派开发板使用手册： https://developer.horizon.ai/api/v1/fileData/documents_pi/index.html 机器人开发平台使用手册： https://developer.horizon.ai/api/v1/fileData/TogetherROS/index.html 视频课程： https://class.guyuehome.com/all/10284445/19617453 图文教程： https://hhp.guyuehome.com/ 教程问答： https://www.guyuehome.com/Bubble/circleDetail/id/92 博客泡圈： https://www.guyuehome.com/","text_tokens":["developer","19617453","机器人","all","www","com","：","pi","html","documents","bubble","api","使用","开发板","class","92","旭日","circledetail","平台"," ","https",":","ai","视频","派","togetherros","hhp",".","课程","x3","id","_","10284445","博客","horizon","v1","泡圈","机器","guyuehome","问答","index","手册","filedata","教程","使用手册","开发","图文","/"],"title":"教程链接汇总","title_tokens":["教程","链接","汇总"]},{"location":"about/","text":"学机器人，上古月居 古月居 ，是华语地区知名的ROS机器人社区（ www.guyuehome.com ），致力于为机器人学习者提供优质的交流学习平台，线上用户超过120万人，努力构建集人才、内容、校企为一体的社区生态，2011年创建至今，累积高质量内容超过1000万字、视频课程超过1000小时，出版《ROS机器人开发实践》等畅销图书，与众多高校及企业建立合作，通过AI机器人+社区生态的创新模式，赋能面向未来的人才培养。 版权声明 古月居网站的所有作品，包括但不限于课程、视频、课件和源码等均为武汉精锋微控科技有限公司合法拥有版权或依法有权使用的作品，仅限被授权用户的个人学习使用。 未经本公司书面许可，任何单位或个人不得对本网站的作品进行使用、复制、修改、抄录、传播、镜像或与其它产品捆绑使用、销售等。 违反上述声明者，本公司将追究其法律责任。 如需授权请联系 brand@guyuehome.com 。","text_tokens":["畅销","人才","高校","com","模式","小时","@","平台","网站","与","面向","、","《","致力","追究其","万字","生态","法律","机器","课件","ros","内容","居","精锋","被","开发","机器人","高质量","www","学","120","年","，","有权","有限","古月","赋能","使用","产品","个人","责任","学习","》","对本","镜像","视频","2011","出版","请",".","课程","版权","企业","声明","等","培养","brand","合法","书面","作品","有限公司","依法","用户","创建","复制","万人","通过","进行","实践","抄录","包括","法律责任","所有","ai","明者","学习者","但","地区","华语","合作","公司","科技","校企","创新","努力","及","拥有","面向未来","上","未经","单位","高质","集","不得","guyuehome","1000","。","至今","传播","超过","如需","上述","社区","是","累积","未来","声明者","追究","限于","武汉","的","（","致力于","仅限","构建","+","为","将","和","提供"," ","任何","微控","修改","）","线上","交流学习","不","优质","销售","人才培养","均","其它","交流","究其","图书","知名","或","捆绑","违反","一体","联系","源码","本","建立","众多","授权","质量","许可"],"title":"关于我们","title_tokens":["我们","关于"]},{"location":"about/#_1","text":"古月居 ，是华语地区知名的ROS机器人社区（ www.guyuehome.com ），致力于为机器人学习者提供优质的交流学习平台，线上用户超过120万人，努力构建集人才、内容、校企为一体的社区生态，2011年创建至今，累积高质量内容超过1000万字、视频课程超过1000小时，出版《ROS机器人开发实践》等畅销图书，与众多高校及企业建立合作，通过AI机器人+社区生态的创新模式，赋能面向未来的人才培养。","text_tokens":["畅销","人才","高校","com","模式","小时","平台","与","面向","、","《","致力","万字","生态","机器","ros","内容","居","开发","机器人","高质量","www","120","年","，","古月","赋能","学习","》","视频","2011","出版",".","课程","企业","等","培养","用户","创建","万人","通过","实践","ai","学习者","地区","华语","合作","校企","创新","努力","及","面向未来","高质","集","guyuehome","1000","。","至今","超过","社区","是","累积","未来","的","（","致力于","构建","+","为","提供"," ","）","线上","交流学习","优质","人才培养","交流","图书","知名","一体","建立","众多","质量"],"title":"学机器人，上古月居","title_tokens":["机器","机器人","学","居","，","古月","上"]},{"location":"about/#_2","text":"古月居网站的所有作品，包括但不限于课程、视频、课件和源码等均为武汉精锋微控科技有限公司合法拥有版权或依法有权使用的作品，仅限被授权用户的个人学习使用。 未经本公司书面许可，任何单位或个人不得对本网站的作品进行使用、复制、修改、抄录、传播、镜像或与其它产品捆绑使用、销售等。 违反上述声明者，本公司将追究其法律责任。 如需授权请联系 brand@guyuehome.com 。","text_tokens":["com","@","网站","与","、","追究其","法律","课件","居","精锋","被","，","有权","有限","古月","使用","产品","个人","责任","学习","对本","镜像","视频","请",".","课程","版权","声明","等","brand","合法","书面","作品","有限公司","依法","用户","复制","进行","抄录","包括","法律责任","所有","明者","但","公司","科技","拥有","未经","单位","不得","guyuehome","。","传播","如需","上述","声明者","追究","限于","武汉","的","仅限","为","将","和"," ","任何","微控","修改","不","销售","均","其它","究其","或","捆绑","违反","联系","源码","本","授权","许可"],"title":"版权声明","title_tokens":["声明","版权"]},{"location":"hhp/1.1_%E6%99%BA%E8%83%BD%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8F%91%E5%B1%95%E4%B8%8E%E7%8E%B0%E7%8A%B6/","text":"智能机器人发展与现状 智能机器人正在改变着我们的生活，想象这样一种场景。 也许不知不觉的某一天，我们就会发现类似这样的机器人会真实出现在生活当中。 科技的发展日新月异，智能机器人也突飞猛进，伴随机器人发展而生的机器人操作系统，也是机器人重要的发展动力之一。 智能机器人举例 提到智能机器人，大家脑海里会映射出什么样的情景呢？ 是不是会有很多科幻电影中变形金刚、大白机器人、星球大战等场景呢？ 智能机器人这个概念，只是一个科幻词汇么？当然不是的，其实在我们身边，已经有越来越多智能机器人出现，我们来看看他们都在哪里？ 扫地机器人 先来看一个大家最熟悉的一个类型——扫地机器人。现在的扫地机器人，除了可以完成扫地、拖地这样一些基本功能之外，还搭载了激光雷达、相机、红外等十几种传感器。 一个全新的扫地机器人虽然是第一次来到你家，但是它可能用到 5 分到 10 分钟时间，很快就可以通过它的传感器对你的家庭环境了如指掌，也就是把实际的家庭环境做成了一张地图，这样他就会知道哪里是卧室，哪里是餐厅，哪里是厨房，不同的区域用多大的风力，用多大的水量来去清扫最为合适，它都会智能化地来做判断。 除此之外，它还得知道怎么样去躲避各种障碍物，比如说家里面的宠物、地上摆放的插线板，各种各样的杂物等等。 所以看似非常小的一个扫地机器人，其实已经是一个很智能化的家用设备了，正在潜移默化地改变着我们的生活。 自动化仓储 第二个案例，虽然大部分人在生活中不会直接接触，但却和每一个人息息相关，那就是自动化仓储。 这是京东某个实际部署运营的一套自动化的仓库，在里面可以看到各种各样的机器人，比如工业机械臂、移动机器人等等，这套立体仓库当中大量的货架也是自动化的，这就是一个典型的机器人应用场景。 之前有一个关于京东的新闻报道，里边讲到，从我们下单那刻开始，到商品分拣出来放到快递员手上，只需要20分钟。比如我们要买个手机，下单付款，20分钟之后，这个手机已经从这么庞大的仓库中顺利找到，并且完成了包装、打标、分配等一系列工序。这样，我们在绝大部分城市，基本都可以体验到下单之后，当天或者隔天收货的体验，为什么它可以做到如此高效，就是因为背后这一套由机器人组成的自动化系统，借助大数据的分析，甚至可以做到在你下单之前，平台就知道你将要买什么东西。比如说你会按照一个月的频率买米买面，那平台就可以预测到上个月你买的米应该快吃完了，然后就会在距离你家最近的一个仓库里面备货。 当你下单之后，这袋米可能半个小时送到你手上了。 自动驾驶 第三个案例，那就是当今最为热门的技术之一——自动驾驶。 自动驾驶汽车也是典型的移动机器人系统，为了保证绝对安全的驾驶过程，汽车上装配了非常多的传感器，以及极为复杂的控制算法。 视频中我们看到的是华为自动驾驶系统在实际路面上测试的效果，自动驾驶汽车通过多个相机、雷达、超声波，实时构建周围环境的三维信息，不仅可以动态识别路面上的行人车辆、车道线、交通指示灯等，还可以安全完成超车、会车、跟车、转向等重要功能，同时对突发状况也可以及时处理，比如躲避突然出现的车辆、礼让行人等，最终自动行驶入库，把我们安全顺利的送到目的地。 虽然自动驾驶相关的技术和法律法规还在不断完善中，但是相信有一天我们每个人都可以体验自动驾驶的乐趣，而且这一天不会太远。 智能机器人发展 机器人的发展横跨几十年，经历了三个重要时期。 2000年前，机器人主要应用于工业生产，俗称工业机器人，由示教器操控，帮助工厂释放劳动力，此时的机器人并没有太多智能而言，完全按照人类的命令执行动作，更加关注电气层面驱动器、伺服电机、减速机、控制器等设备，这是机器人的电气时代。 2000年后，计算机和视觉技术逐渐应用，机器人的类型不断丰富，出现了AGV、视觉检测等应用，此时的机器人传感器更加丰富，但是依然缺少自主思考的过程，智能化有限，只能感知局部环境，这是机器人的数字时代，不过这也是机器人大时代的前夜。 2015年之后，随着人工智能技术的快速发展，机器人成为了AI技术的最佳载体，家庭服务机器人、送餐机器人、四足仿生机器狗、自动驾驶汽车等应用呈井喷状爆发，智能机器人时代正式拉开序幕。 2015年之后，智能机器人市场迅速爆发，到2025年，国内人工智能市场有望达到1164亿元，而作为人工智能重要载体的机器人，市场更会达到1463亿元。 行业的快速发展，必将带动大量专业人才的需求，人才缺口也将逐年扩大，2025年，预计国内机器人行业的人才缺口将超过450万，人工智能方面的缺口更会达到1000万。 面对如此严峻的人才需求，国内各高校从2016年起，陆续开设机器人和人工智能专业，为人才的供给提供有力保障。 智能机器人的快速发展，必将对机器人开发提出更高的要求，软件层面最为热点的技术之一就是机器人操作系统，这也是我们课程的主角。 机器人操作系统 对于越来越复杂的智能机器人系统，已经不是一个人或者一个团队可以独立完成的，如何高效开发机器人，是技术层面上非常重要的一个问题，针对这个问题，一群斯坦福大学的有志青年尝试给出一个答案，那就是机器人操作系统。 ROS的诞生 2007年，他们诞生了这样一个想法，我们有没有可能做一款个人服务机器人，帮助我们完成洗衣、做饭、收拾家等一切你不想做的事情，甚至还可以在你无聊的时候，陪你聊天玩耍，最后他们真的做出来了。 当时，他们深知做出这样一款机器人并不容易，机械、电路、软件等都要涉及，而且横跨很多个专业，光靠自己肯定做不到，此时他们诞生了这样一个想法：既然自己做不到，那为什么不联合所有人一起干呢？如果设计一套标准的机器人平台和其中的软件，大家都可以在这个平台上做应用开发，既然应用软件都基于同一平台，应用的分享也很容易实现，这就类似别人开发的苹果手机应用，只要你有苹果手机，同样也可以用。 说干就干，初期的机器人原型是用实验室可以找到的木头和一些零部件组成的，后期有了充足的资金，才得以实现图中这款外观精致、性能强悍的机器人——PR2，Personal Robot 2代。 在这几个图中，我们可以看到PR2机器人已经可以完成叠毛巾、熨烫衣服、打台球、剪头发等一系列复杂的应用功能，以叠毛巾为例，这在当时是轰动机器人圈的重要研究，因为第一次有机器人可以完成柔性物体的处理，虽然效率很低，在100分钟之内只完成了5条毛巾的整理，但是在学术层面，却推动机器人向前走了一大步。 这款机器人中的软件框架就是ROS的原型，所以ROS因这款个人服务机器人而生，很快也从中独立出来，成为一款用于更多机器人的软件系统。 ROS怀揣“提高机器人软件复用率”的目标，促使社区快速发展和繁荣，时至今日，ROS已经广泛用于各种机器人的开发，无论是机械臂、移动机器人、水下机器人，还是人形机器人、复合机器人，统统都可以看到ROS的身影，ROS已经成为机器人领域的普遍标准。 ROS的特点 提高机器人软件复用率，这个目标简单来讲就是 不要重新造轮子 。 正如一家做汽车的公司，从零制造汽车并不是一个明智的做法，他们通常会采购A家的轮子、B家的引擎、C家的多媒体系统，最后把这些整合到一起做成汽车。同理，我们也可以将ROS社区中已有的各种软件集合到一起，在此之上去实现自己的创意，同时还可以将自己的成果分享给别人，这样大家都可以站在巨人的肩膀上，向前走的更远，一步一步，智能机器人才会有更多沉淀和更长远的进步。 围绕这个核心目标，ROS在自身的设计上也尽量做到了模块化，由 通信机制、开发工具、应用功能、生态系统 四大部分组成。同时ROS具备多项特点，这里的ROS是ROS1和ROS2的总称， 比如： 社区是全球化 的，那就可以集合全人类的智慧来推进机器人的智能化发展； 这些智慧的结晶都会以各种各样的 应用案例在社区中沉淀 下来； ROS本身也是完全开源的， 商业许可证非常宽松 ； 对商业应用功能友好，这就代表着公司可以直接使用ROS开发商业化的机器人产品， 缩短了产品的上市时间 ； ROS也可以 跨平台使用 ，Linux、Windows、嵌入式系统都可以跑； ROS2中也新增了很多 支持工业应用 的新特性和新技术，促使ROS在越来越多领域中被使用。 ROS的社区 社区是ROS快速发展的核心动力，什么是社区呢？其实就是ROS相关资源的整合方式，比如wiki说明、问答网站、应用源码、论坛讨论等都算是社区中的元素。 ROS全球社区有几个重要网站： answers.ros.org，这是一个ROS问答网站，大家可以在上边提出任何关于ROS的问题，全球很多开发者都很乐意回答我们的问题； wiki.ros.org，这是ROS的维基百科，记录了ROS教程和各种功能包的使用； discourse.ros.org，这是ROS论坛，关于ROS开发的新鲜事都可以在这里发表和查看，比如ROS的活动、新功能包的发布等等。 index.ros.org，是ROS各种资源的一个索引网站； packages.ros.org，是ROS功能包存储的数据库。 这几个网站的使用情况基本就可以代表ROS社区的活跃度了。 上图是近几年ROS社区页面浏览量的增长曲线，从总体趋势上来看，各项增长速度都非常快，wiki作为日常使用最为频繁的网站，使用度无疑是最高的，现在每个月有 150万左右 的访问量，answers和packages现在差不多，每个月有 80万 左右，其他两个不多，四项加起来每个月基本有 250万左右 的访问量，已经是一个活跃度非常棒的社区了。 从访问人数上来看，上边这张图更为清晰， wiki每个月有20到25万人使用 ， answers每个月有15万人以上使用 ，四项加起来每个月差不多有40多万的使用人数，这些用户绝大部分都是机器人开发者，可以看到ROS使用人数是越来越多了。 这张图是根据功能包下载次数统计得到的地域排名，基本上可以代表不同国家机器人研发的活跃程度，给大家作为一个参考。 总而言之，通过这些数据，我们可以看到的是ROS发展迅猛，正在助推机器人革命这一波大浪潮，大家每一个人在其中都大有可为。","text_tokens":["人才","各样","是不是","主要","华为","功能","自主","陆续","一家","充足","其他","平台","计算机","并且","应用","答案","为什么","米","臂","远","就","100","仿生","货架","全人","做成","地域","上个月","革命","频繁","高","推动","法律","机器","就是","研发","场景","ros","算机","最后","新增","什么","10","除此","实现","活跃","趋势","在生活中","2025","给出","想法","动机","报道","汽车","十几","劳动力","全人类","家庭","每个","类型","巨人","丰富","数字","使用","不过","各","重要","装配","备货","第三",".","变形","操控","课程","也许","基本功","资金","广泛","明智","红外","完","参考","根据","尝试","零","浏览","最为","并","依然","行业","15","工厂","图中","情景","找到","太远","他们","看看","特点","有人","命令","简单","减速","越来越","创意","通过","很","维基百科","斯坦福","发现","分拣","从","新鲜","当然","之后","没有","需要","同时","discourse","三个","通常","维基","很多","很快","无疑","公司","各种各样","扫地","算法","几十年","条","电机","重新","法律法规","接触","造","有志","还是","速度","手机","周围环境","制造","序幕","会","怎么","去","层面","目标","正式","熨烫","乐意","1000","最高","地来","。","出来","呈","四项","2015","跟车","一次","为了","之内","嵌入式","处理","一款","诞生","清扫","毛巾","借助","执行","推进","b","次数","上去","自动","如何","今日","时至今日","爆发","星球","下单","涉及","效率","—","因","来到","许可","实验室","三维","分","之前","linux","更为","几十","行驶","方面","法规","多媒体系统","各项","维基百","通信","现状","更加","wiki","这套","福大","多万","载体","高校","基本","对于","之外","及时","小时","上图","这一波","二个","越来","环境","一套","用到","第一","后期","有望","？","与","都","工具","餐厅","外观","目的地","站","先","包装","除此之外","超声波","已有","闻报","星球大战","障碍","快递","青年","基于","这些","由示","局部","answers","大部分","突飞猛进","以","真的","指示灯","提出","得以","增长速度","完善","发表","关于","最","可能","动力","2016","教程","沉淀","系统","开发","支持","线","卧室","新鲜事","厨房","默化","20","买面","自己","但是","玩耍","查看","按照","起来","既然","说明","躲避","实时","无论","相信","超声","下来","出现","做出","产品","进步","严峻","四大","隔天","同理","这是","做饭","地上","物体","逐年","全球","a","当","当今","采购","呢","robot","除了","具备","度","概念","之一","零部件","而生","提高","程度","成果","设计","完全","电气","付款","数据库","俗称","繁荣","用于","做法","此","万人","那","人才需求","操作系统","由","距离","几年","信息","在","突飞","大战","人","典型","2007","研究","org","排名","动作","此时","对","5","得到","体系","一个","上","日新月异","测试","状","仓库","圈","ros1","同样","人数","张图","计算","至今","一个月","伺服电机","记录","不是","收拾","摆放","人类","时候","超车","经历","缺口","保障","家用","是","真实","亿元","事情","社区","快速","智慧","一种","改变","声波","供给","柔性","频率","甚至","或者","极为","将","这","转向","提供","商业化","城市","风力","这款","商业","这个","知道","热点","水量","一系","工业","预计","驱动器","多个","“","新","同一","一切","新月","聊天","多","嵌入","已经","以上","关注","打","律法","代表","缺少","核心","面对","index","迅猛","国内","从中","买米","助推","非常","大步","手上","2","太","交通","只","可以","他","其中","你家","驱动","整理","向前走","潜移","绝大","传感器","苹果","时代","剪头发","差不多","智能化","以及","动态","分配","逐渐","大学","热门","所有人","体验","后","搭载","、","类似","线板","40","存储","生态系统","开发者","么","讨论","随着","促使","而言","它","部署","怀揣","带动","生态","吃","放到","独立","周围","十年","ros2","统计","25","率","不断丰富","前夜","东西","页面","组成","机器人","应该","80","市场","万","完成","，","仓储","而且","有限","了如指掌","活跃度","然后","直接","及时处理","拉开","必将","轰动","友好","这袋","判断","生产","当时","只是","只要","视觉","性能","领域","肩膀","缩短","绝对","开发工具","宽松","复用","年前","肯定","立体仓库","科幻电影","操作","结晶","personal","比如","预测","叠","等","乐趣","目的","员","讲","引擎","增长","大有可为","自动化","多媒体","用户","棒","送餐","开设","映射","所以","元素","工业生产","标准","部分","买","半个","问题","基本功能","成为","自身","识别","头发","日常","为例","个","移动","其实","指示","所有","系列","packages","激光","但","检测","部件","案例","障碍物","第三个","才","打标","地图","也","agv","拉开序幕","整合","论坛","访问","基本上","特性","如此","人工智能","模块化","作为","快","包","驾驶","狗","向前","激光雷达","250","开源","变形金刚","主角","联合","思考","需求","于","：","某个","的","着","不会","发状","不到","你","词汇","区域","为","和","别人","有","帮助","轮子","怎么样"," ","熟悉","任何","某","设备","之","业生","国家","举例","等等","一群","伺服","团队","插","陪","各种","释放","”","起","提到","正在","十几种","科幻","中","大白","一步","将要","浪潮","可为","强悍","安全","本身","把","如果","索引","行人","这样","复杂","四足","只能","一天","感知","统统","数据","技术","分享","绝大部分","最终","更","潜移默化","清晰","大量","不断完善","庞大","网站","宠物","劳动","近几年","电路","方式","达到","跑","要求","用多大","模块","全球化","小","新闻报道","分析","全新","许可证","地","深知","传感","状况","访问量","做到","那刻","多项","总体","高效","车辆","加","新闻","150","每","当天","控制","礼让","人工","不断","软件系统","问答","尽量","得","家","过程","最佳","还","几种","被","上边","猛进","软件","路面","控制算法","我们","扩大","上个","年","衣服","入库","身边","第二个","学术","突发","复合","看似","个人","情况","无论是","总称","视频","这里","回答","初期","一些","大部","背后","款","了","针对","百科","什么样","上市","杂物","1164","有没有","不要","因为","发布","时期","以叠","大家","左右","相关","当中","代","无聊","立体","顺利","却","不知","台球","电影","出","洗衣","开始","一大","正如","光靠","两个","车","到","这么","商品","框架","最近","pr2","水下","伴随","月","息息相关","想象","一大步","实际","比如说","控制器","万左右","ai","保证","跨平台","第二","干","突然","身影","有力","木头","科技","现在","发展","虽然","c","windows","送到","低","专业","里边","人形","迅速","给","总而言之","来看","不仅","精致","专业人才","普遍","算是","一张","机制","生态系","2000","而","第一次","一起","买个","超过","收货","曲线","车道","不知不觉","雷达","容易","运营","应用软件","450","用","来","不同","斯坦福大学","工序","大","构建","合适","原型","浏览量","横跨","生活","不觉","；","服务","分钟","更会","说干就干","看到","智能","不","效果","要","突发状况","围绕","机械","感器","井喷","资源","不多","移动机器人","里面","据库","活动","下载","哪里","拖地","家庭环境","几个","教器","不想","媒体","一系列","来讲","时间","长远","实验","1463","相机","源码","脑海","集合","减速机","做","里会","京东","金刚"],"title":"智能机器人发展现状","title_tokens":["机器","机器人","现状","智能","发展"]},{"location":"hhp/1.1_%E6%99%BA%E8%83%BD%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8F%91%E5%B1%95%E4%B8%8E%E7%8E%B0%E7%8A%B6/#_1","text":"智能机器人正在改变着我们的生活，想象这样一种场景。 也许不知不觉的某一天，我们就会发现类似这样的机器人会真实出现在生活当中。 科技的发展日新月异，智能机器人也突飞猛进，伴随机器人发展而生的机器人操作系统，也是机器人重要的发展动力之一。","text_tokens":["猛进","是","真实","机器人","我们","这样","一种","一天","操作系统","的","，","着","改变","出现","伴随","发现","在","突飞","想象","生活","重要","不觉"," ","某","智能","科技","发展","类似","就","也许","操作","也","新月","突飞猛进","而生","之一","日新月异","会","当中","机器","场景","。","正在","不知","动力","系统","不知不觉"],"title":"智能机器人发展与现状","title_tokens":["机器","机器人","与","现状","智能","发展"]},{"location":"hhp/1.1_%E6%99%BA%E8%83%BD%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8F%91%E5%B1%95%E4%B8%8E%E7%8E%B0%E7%8A%B6/#_2","text":"提到智能机器人，大家脑海里会映射出什么样的情景呢？ 是不是会有很多科幻电影中变形金刚、大白机器人、星球大战等场景呢？ 智能机器人这个概念，只是一个科幻词汇么？当然不是的，其实在我们身边，已经有越来越多智能机器人出现，我们来看看他们都在哪里？","text_tokens":["看看","机器人","是不是","我们","越来越","，","的","来","出现","身边","越来","大战","词汇","在","其实","有","只是","当然"," ","？","都","这个","很多","星球","智能","变形","、","呢","他们","科幻电影","星球大战","什么样","概念","么","哪里","多","一个","等","大家","已经","会","机器","提到","场景","脑海","科幻","不是","什么","中","大白","里会","情景","电影","映射","出","金刚","变形金刚"],"title":"智能机器人举例","title_tokens":["机器","智能","举例","机器人"]},{"location":"hhp/1.1_%E6%99%BA%E8%83%BD%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8F%91%E5%B1%95%E4%B8%8E%E7%8E%B0%E7%8A%B6/#_3","text":"先来看一个大家最熟悉的一个类型——扫地机器人。现在的扫地机器人，除了可以完成扫地、拖地这样一些基本功能之外，还搭载了激光雷达、相机、红外等十几种传感器。 一个全新的扫地机器人虽然是第一次来到你家，但是它可能用到 5 分到 10 分钟时间，很快就可以通过它的传感器对你的家庭环境了如指掌，也就是把实际的家庭环境做成了一张地图，这样他就会知道哪里是卧室，哪里是餐厅，哪里是厨房，不同的区域用多大的风力，用多大的水量来去清扫最为合适，它都会智能化地来做判断。 除此之外，它还得知道怎么样去躲避各种障碍物，比如说家里面的宠物、地上摆放的插线板，各种各样的杂物等等。 所以看似非常小的一个扫地机器人，其实已经是一个很智能化的家用设备了，正在潜移默化地改变着我们的生活。","text_tokens":["各样","这样","基本","可以","之外","他","功能","你家","潜移","传感器","环境","潜移默化","用到","智能化","第一","都","宠物","餐厅","搭载","、","先","就","用多大","除此之外","线板","小","障碍","做成","非常","全新","地","传感","它","机器","就是","10","除此","最","可能","得","家","还","几种","卧室","厨房","默化","机器人","但是","十几","我们","完成","家庭","躲避","，","类型","了如指掌","看似","判断","地上","一些","了","除了","基本功","杂物","比如","红外","等","大家","最为","所以","基本功能","到","通过","很","其实","实际","比如说","激光","很快","障碍物","虽然","现在","扫地","各种各样","对","地图","5","也","来看","一个","会","怎么","去","一张","地来","。","第一次","摆放","激光雷达","一次","家用","是","雷达","的","着","来","不同","改变","清扫","合适","你","区域","生活","怎么样"," ","风力","熟悉","分钟","知道","设备","智能","—","水量","来到","感器","等等","里面","分","哪里","拖地","插","家庭环境","各种","已经","时间","相机","正在","十几种","做","把"],"title":"扫地机器人","title_tokens":["机器","扫地","机器人"]},{"location":"hhp/1.1_%E6%99%BA%E8%83%BD%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8F%91%E5%B1%95%E4%B8%8E%E7%8E%B0%E7%8A%B6/#_4","text":"第二个案例，虽然大部分人在生活中不会直接接触，但却和每一个人息息相关，那就是自动化仓储。 这是京东某个实际部署运营的一套自动化的仓库，在里面可以看到各种各样的机器人，比如工业机械臂、移动机器人等等，这套立体仓库当中大量的货架也是自动化的，这就是一个典型的机器人应用场景。 之前有一个关于京东的新闻报道，里边讲到，从我们下单那刻开始，到商品分拣出来放到快递员手上，只需要20分钟。比如我们要买个手机，下单付款，20分钟之后，这个手机已经从这么庞大的仓库中顺利找到，并且完成了包装、打标、分配等一系列工序。这样，我们在绝大部分城市，基本都可以体验到下单之后，当天或者隔天收货的体验，为什么它可以做到如此高效，就是因为背后这一套由机器人组成的自动化系统，借助大数据的分析，甚至可以做到在你下单之前，平台就知道你将要买什么东西。比如说你会按照一个月的频率买米买面，那平台就可以预测到上个月你买的米应该快吃完了，然后就会在距离你家最近的一个仓库里面备货。 当你下单之后，这袋米可能半个小时送到你手上了。","text_tokens":["手上","各样","只","这样","基本","可以","你家","数据","小时","绝大","绝大部分","二个","一套","大量","分配","平台","庞大","都","并且","应用","体验","为什么","、","臂","米","包装","就","闻报","货架","快递","新闻报道","上个月","分析","大部分","它","部署","做到","那刻","吃","放到","机器","就是","高效","新闻","场景","每","当天","什么","关于","可能","在生活中","系统","动机","东西","买面","20","报道","组成","机器人","应该","我们","按照","完成","上个","，","仓储","然后","直接","第二个","这袋","备货","隔天","这是","大部","背后","当","了","立体仓库","比如","预测","因为","完","等","相关","当中","立体","顺利","员","讲","却","自动化","付款","找到","开始","部分","买","半个","那","到","这么","商品","由","最近","距离","分拣","在","移动","人","从","息息相关","实际","之后","比如说","典型","需要","系列","但","第二","案例","虽然","各种各样","送到","里边","打标","也","接触","一个","手机","如此","会","仓库","快","。","出来","一个月","买个","收货","是","运营","某个","的","不会","工序","大","借助","你","甚至","或者","和","频率","这","生活","有"," ","城市","自动","分钟","看到","这个","知道","下单","要","一系","工业","机械","移动机器人","里面","等等","之前","各种","已经","一系列","中","将要","买米","这套","京东"],"title":"自动化仓储","title_tokens":["仓储","自动","自动化"]},{"location":"hhp/1.1_%E6%99%BA%E8%83%BD%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8F%91%E5%B1%95%E4%B8%8E%E7%8E%B0%E7%8A%B6/#_5","text":"第三个案例，那就是当今最为热门的技术之一——自动驾驶。 自动驾驶汽车也是典型的移动机器人系统，为了保证绝对安全的驾驶过程，汽车上装配了非常多的传感器，以及极为复杂的控制算法。 视频中我们看到的是华为自动驾驶系统在实际路面上测试的效果，自动驾驶汽车通过多个相机、雷达、超声波，实时构建周围环境的三维信息，不仅可以动态识别路面上的行人车辆、车道线、交通指示灯等，还可以安全完成超车、会车、跟车、转向等重要功能，同时对突发状况也可以及时处理，比如躲避突然出现的车辆、礼让行人等，最终自动行驶入库，把我们安全顺利的送到目的地。 虽然自动驾驶相关的技术和法律法规还在不断完善中，但是相信有一天我们每个人都可以体验自动驾驶的乐趣，而且这一天不会太远。","text_tokens":["行人","交通","复杂","华为","可以","及时","功能","一天","技术","传感器","最终","环境","以及","动态","不断完善","都","热门","目的地","体验","、","超声波","传感","状况","法律","指示灯","车辆","机器","就是","控制","礼让","完善","周围","不断","过程","系统","还","线","动机","路面","汽车","机器人","控制算法","我们","但是","完成","每个","躲避","，","实时","而且","相信","超声","出现","入库","及时处理","突发","重要","装配","视频","第三","绝对","当今","了","比如","之一","等","乐趣","相关","目的","最为","顺利","太远","那","车","通过","识别","信息","在","移动","人","指示","实际","典型","同时","保证","三个","突然","案例","算法","第三个","虽然","送到","法律法规","对","也","上","测试","周围环境","不仅","会","驾驶","。","跟车","超车","车道","为了","是","雷达","处理","的","不会","发状","声波","构建","极为","和","转向","有","这"," ","自动","看到","—","效果","突发状况","感器","三维","移动机器人","多个","多","行驶","把","律法","法规","相机","中","非常","安全"],"title":"自动驾驶","title_tokens":["自动","驾驶"]},{"location":"hhp/1.1_%E6%99%BA%E8%83%BD%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8F%91%E5%B1%95%E4%B8%8E%E7%8E%B0%E7%8A%B6/#_6","text":"机器人的发展横跨几十年，经历了三个重要时期。 2000年前，机器人主要应用于工业生产，俗称工业机器人，由示教器操控，帮助工厂释放劳动力，此时的机器人并没有太多智能而言，完全按照人类的命令执行动作，更加关注电气层面驱动器、伺服电机、减速机、控制器等设备，这是机器人的电气时代。 2000年后，计算机和视觉技术逐渐应用，机器人的类型不断丰富，出现了AGV、视觉检测等应用，此时的机器人传感器更加丰富，但是依然缺少自主思考的过程，智能化有限，只能感知局部环境，这是机器人的数字时代，不过这也是机器人大时代的前夜。 2015年之后，随着人工智能技术的快速发展，机器人成为了AI技术的最佳载体，家庭服务机器人、送餐机器人、四足仿生机器狗、自动驾驶汽车等应用呈井喷状爆发，智能机器人时代正式拉开序幕。 2015年之后，智能机器人市场迅速爆发，到2025年，国内人工智能市场有望达到1164亿元，而作为人工智能重要载体的机器人，市场更会达到1463亿元。 行业的快速发展，必将带动大量专业人才的需求，人才缺口也将逐年扩大，2025年，预计国内机器人行业的人才缺口将超过450万，人工智能方面的缺口更会达到1000万。 面对如此严峻的人才需求，国内各高校从2016年起，陆续开设机器人和人工智能专业，为人才的供给提供有力保障。 智能机器人的快速发展，必将对机器人开发提出更高的要求，软件层面最为热点的技术之一就是机器人操作系统，这也是我们课程的主角。","text_tokens":["人才","太","主要","载体","高校","四足","只能","感知","驱动","自主","技术","陆续","传感器","时代","环境","更","大量","智能化","逐渐","计算机","有望","劳动","应用","后","达到","、","要求","仿生","由示","局部","随着","而言","传感","高","带动","提出","机器","就是","控制","算机","十年","不断","人工","动力","2016","过程","最佳","2025","开发","不断丰富","系统","前夜","软件","机器人","但是","汽车","按照","市场","劳动力","万","扩大","家庭","年","我们","，","有限","类型","丰富","出现","数字","拉开","必将","不过","生产","重要","严峻","各","视觉","这是","逐年","年前","了","操控","课程","操作","1164","之一","时期","等","最为","并","完全","依然","行业","电气","工厂","送餐","俗称","开设","工业生产","人才需求","命令","减速","操作系统","到","成为","从","之后","控制器","没有","ai","检测","三个","有力","发展","几十年","动作","电机","此时","专业","对","也","agv","拉开序幕","迅速","如此","序幕","层面","人工智能","状","专业人才","正式","作为","1000","计算","。","狗","2000","驾驶","伺服电机","呈","而","超过","2015","人类","经历","缺口","保障","主角","是","思考","亿元","需求","快速","于","450","的","大","供给","为","将","执行","和","横跨","这","帮助","提供"," ","服务","自动","更会","设备","热点","爆发","智能","工业","业生","感器","井喷","预计","驱动器","伺服","几十","多","释放","教器","关注","方面","1463","起","缺少","面对","减速机","国内","更加"],"title":"智能机器人发展","title_tokens":["机器","智能","发展","机器人"]},{"location":"hhp/1.1_%E6%99%BA%E8%83%BD%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8F%91%E5%B1%95%E4%B8%8E%E7%8E%B0%E7%8A%B6/#_7","text":"对于越来越复杂的智能机器人系统，已经不是一个人或者一个团队可以独立完成的，如何高效开发机器人，是技术层面上非常重要的一个问题，针对这个问题，一群斯坦福大学的有志青年尝试给出一个答案，那就是机器人操作系统。","text_tokens":["是","机器人","那","对于","复杂","问题","可以","完成","越来越","操作系统","的","，","技术","斯坦福大学","斯坦福","越来","或者","人","重要","开发","大学","如何","这个","答案","智能","针对","操作","一群","青年","团队","有志","一个","上","尝试","已经","层面","高效","机器","就是","。","独立","不是","系统","给出","非常","福大"],"title":"机器人操作系统","title_tokens":["机器","操作","机器人","操作系统","系统"]},{"location":"hhp/1.1_%E6%99%BA%E8%83%BD%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8F%91%E5%B1%95%E4%B8%8E%E7%8E%B0%E7%8A%B6/#ros","text":"2007年，他们诞生了这样一个想法，我们有没有可能做一款个人服务机器人，帮助我们完成洗衣、做饭、收拾家等一切你不想做的事情，甚至还可以在你无聊的时候，陪你聊天玩耍，最后他们真的做出来了。 当时，他们深知做出这样一款机器人并不容易，机械、电路、软件等都要涉及，而且横跨很多个专业，光靠自己肯定做不到，此时他们诞生了这样一个想法：既然自己做不到，那为什么不联合所有人一起干呢？如果设计一套标准的机器人平台和其中的软件，大家都可以在这个平台上做应用开发，既然应用软件都基于同一平台，应用的分享也很容易实现，这就类似别人开发的苹果手机应用，只要你有苹果手机，同样也可以用。 说干就干，初期的机器人原型是用实验室可以找到的木头和一些零部件组成的，后期有了充足的资金，才得以实现图中这款外观精致、性能强悍的机器人——PR2，Personal Robot 2代。 在这几个图中，我们可以看到PR2机器人已经可以完成叠毛巾、熨烫衣服、打台球、剪头发等一系列复杂的应用功能，以叠毛巾为例，这在当时是轰动机器人圈的重要研究，因为第一次有机器人可以完成柔性物体的处理，虽然效率很低，在100分钟之内只完成了5条毛巾的整理，但是在学术层面，却推动机器人向前走了一大步。 这款机器人中的软件框架就是ROS的原型，所以ROS因这款个人服务机器人而生，很快也从中独立出来，成为一款用于更多机器人的软件系统。 ROS怀揣“提高机器人软件复用率”的目标，促使社区快速发展和繁荣，时至今日，ROS已经广泛用于各种机器人的开发，无论是机械臂、移动机器人、水下机器人，还是人形机器人、复合机器人，统统都可以看到ROS的身影，ROS已经成为机器人领域的普遍标准。","text_tokens":["如果","2","这样","复杂","只","可以","其中","整理","功能","统统","向前走","分享","苹果","一套","剪头发","更","充足","平台","第一","后期","？","都","外观","所有人","应用","电路","为什么","、","臂","类似","就","100","基于","促使","深知","推动","怀揣","真的","机器","就是","得以","ros","最后","独立","软件系统","什么","实现","可能","家","开发","还","系统","率","想法","动机","软件","组成","自己","机器人","玩耍","我们","但是","完成","既然","年","，","而且","无论","衣服","做出","轰动","学术","复合","个人","性能","当时","只要","重要","无论是","领域","物体","做饭","初期","一些","复用","款","呢","了","肯定","robot","资金","广泛","personal","有没有","叠","零部件","因为","而生","提高","以叠","等","大家","代","无聊","并","设计","却","图中","台球","繁荣","找到","所以","洗衣","用于","他们","标准","一大","那","有人","光靠","很","框架","成为","pr2","水下","头发","为例","在","个","移动","一大步","所有","2007","没有","系列","研究","干","很多","部件","很快","木头","身影","虽然","发展","低","条","此时","专业","才","也","5","人形","还是","一个","上","手机","精致","层面","普遍","圈","目标","熨烫","同样","。","出来","至今","第一次","一起","收拾","向前","时候","一次","社区","事情","联合","是","快速","之内","容易","：","处理","应用软件","用","的","一款","诞生","毛巾","原型","不到","你","柔性","甚至","和","横跨","这","别人","帮助","有"," ","服务","这款","分钟","说干就干","看到","这个","今日","时至今日","因","不","涉及","—","要","一系","效率","机械","实验室","移动机器人","“","同一","一切","聊天","陪","多","几个","各种","已经","不想","”","一系列","实验","打","中","做","从中","强悍","大步"],"title":"ROS的诞生","title_tokens":["诞生","的","ros"]},{"location":"hhp/1.1_%E6%99%BA%E8%83%BD%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8F%91%E5%B1%95%E4%B8%8E%E7%8E%B0%E7%8A%B6/#ros_1","text":"提高机器人软件复用率，这个目标简单来讲就是 不要重新造轮子 。 正如一家做汽车的公司，从零制造汽车并不是一个明智的做法，他们通常会采购A家的轮子、B家的引擎、C家的多媒体系统，最后把这些整合到一起做成汽车。同理，我们也可以将ROS社区中已有的各种软件集合到一起，在此之上去实现自己的创意，同时还可以将自己的成果分享给别人，这样大家都可以站在巨人的肩膀上，向前走的更远，一步一步，智能机器人才会有更多沉淀和更长远的进步。 围绕这个核心目标，ROS在自身的设计上也尽量做到了模块化，由 通信机制、开发工具、应用功能、生态系统 四大部分组成。同时ROS具备多项特点，这里的ROS是ROS1和ROS2的总称， 比如： 社区是全球化 的，那就可以集合全人类的智慧来推进机器人的智能化发展； 这些智慧的结晶都会以各种各样的 应用案例在社区中沉淀 下来； ROS本身也是完全开源的， 商业许可证非常宽松 ； 对商业应用功能友好，这就代表着公司可以直接使用ROS开发商业化的机器人产品， 缩短了产品的上市时间 ； ROS也可以 跨平台使用 ，Linux、Windows、嵌入式系统都可以跑； ROS2中也新增了很多 支持工业应用 的新特性和新技术，促使ROS在越来越多领域中被使用。","text_tokens":["人才","各样","这样","可以","功能","向前走","技术","分享","越来","一家","更","智能化","平台","工具","都","站","应用","、","跑","远","已有","就","模块","全球化","全人","做成","生态系统","这些","非常","许可证","促使","以","做到","多项","生态","机器","就是","ros","最后","新增","ros2","实现","尽量","家","沉淀","系统","还","率","开发","支持","被","软件","组成","自己","机器人","汽车","我们","全人类","，","下来","巨人","使用","直接","友好","产品","进步","缩短","四大","领域","肩膀","总称","同理","这里","开发工具","全球","宽松","复用","a","采购","具备","了","结晶","明智","上市","比如","不要","提高","大家","零","并","成果","设计","完全","引擎","多媒体","他们","特点","做法","此","部分","正如","那","简单","创意","越来越","到","自身","由","在","从","同时","跨平台","通常","很多","案例","公司","windows","各种各样","发展","c","重新","对","整合","也","造","给","特性","体系","一个","上","制造","会","模块化","ros1","目标","机制","。","生态系","不是","一起","人类","向前","开源","社区","是","智慧","：","嵌入式","的","着","来","将","和","别人","这","轮子","b","有","推进","；"," ","商业化","上去","商业","这个","智能","之","围绕","工业","新","linux","多","各种","嵌入","长远","媒体","来讲","时间","代表","多媒体系统","核心","集合","通信","中","一步","做","本身","把","许可"],"title":"ROS的特点","title_tokens":["特点","的","ros"]},{"location":"hhp/1.1_%E6%99%BA%E8%83%BD%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8F%91%E5%B1%95%E4%B8%8E%E7%8E%B0%E7%8A%B6/#ros_2","text":"社区是ROS快速发展的核心动力，什么是社区呢？其实就是ROS相关资源的整合方式，比如wiki说明、问答网站、应用源码、论坛讨论等都算是社区中的元素。 ROS全球社区有几个重要网站： answers.ros.org，这是一个ROS问答网站，大家可以在上边提出任何关于ROS的问题，全球很多开发者都很乐意回答我们的问题； wiki.ros.org，这是ROS的维基百科，记录了ROS教程和各种功能包的使用； discourse.ros.org，这是ROS论坛，关于ROS开发的新鲜事都可以在这里发表和查看，比如ROS的活动、新功能包的发布等等。 index.ros.org，是ROS各种资源的一个索引网站； packages.ros.org，是ROS功能包存储的数据库。 这几个网站的使用情况基本就可以代表ROS社区的活跃度了。 上图是近几年ROS社区页面浏览量的增长曲线，从总体趋势上来看，各项增长速度都非常快，wiki作为日常使用最为频繁的网站，使用度无疑是最高的，现在每个月有 150万左右 的访问量，answers和packages现在差不多，每个月有 80万 左右，其他两个不多，四项加起来每个月基本有 250万左右 的访问量，已经是一个活跃度非常棒的社区了。 从访问人数上来看，上边这张图更为清晰， wiki每个月有20到25万人使用 ， answers每个月有15万人以上使用 ，四项加起来每个月差不多有40多万的使用人数，这些用户绝大部分都是机器人开发者，可以看到ROS使用人数是越来越多了。 这张图是根据功能包下载次数统计得到的地域排名，基本上可以代表不同国家机器人研发的活跃程度，给大家作为一个参考。 总而言之，通过这些数据，我们可以看到的是ROS发展迅猛，正在助推机器人革命这一波大浪潮，大家每一个人在其中都大有可为。","text_tokens":["多万","索引","基本","可以","其中","功能","数据","上图","绝大","绝大部分","这一波","越来","清晰","差不多","其他","？","网站","都","应用","近几年","方式","、","就","40","存储","answers","开发者","这些","讨论","地域","大部分","频繁","革命","而言","访问量","提出","总体","加","就是","机器","150","ros","增长速度","研发","每","问答","发表","什么","关于","活跃","教程","动力","趋势","统计","开发","25","上边","新鲜事","查看","页面","20","起来","机器人","80","我们","万","说明","每个","，","使用","活跃度","重要","情况","这是","这里","回答","全球","大部",".","呢","了","度","百科","比如","参考","发布","左右","等","大家","根据","相关","程度","浏览","最为","增长","15","大有可为","数据库","用户","棒","元素","部分","万人","问题","两个","越来越","到","很","维基百科","通过","几年","日常","月","在","其实","从","人","新鲜","packages","万左右","discourse","维基","org","很多","排名","现在","发展","访问","整合","基本上","论坛","得到","给","总而言之","速度","来看","一个","上","乐意","最高","算是","作为","快","包","人数","张图","。","记录","四项","250","曲线","社区","是","快速","：","的","不同","大","浏览量","和","这","有","次数","；"," ","任何","看到","不","资源","不多","国家","等等","新","据库","活动","下载","更为","多","几个","各种","已经","以上","代表","源码","核心","维基百","各项","正在","中","index","浪潮","迅猛","可为","助推","wiki","非常","无疑"],"title":"ROS的社区","title_tokens":["的","ros","社区"]},{"location":"hhp/1.2_%E5%9C%B0%E5%B9%B3%E7%BA%BF%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0%E4%BB%8B%E7%BB%8D/","text":"地平线机器人开发平台(HHP)介绍 机器人是一个非常复杂的系统，硬件部分包括：各种各样感知环境信息的传感器、作为大脑进行计算的主控平台、执行动作的电机等等。软件层面包括：感知算法，规控算法，数据驱动的程式，操作系统等。 以操作系统为例，应用最为广泛的ROS系统在不断迭代，不过在智能时代洪流的冲击下，还是涌现出一些问题。 ROS的一些问题 ROS逐渐成为标准，大量机器人应用被贡献到社区，虽然提高了代码的通用性，但却难以发挥硬件的完整性能； 大量应用聚焦在机器人运动控制与定位导航等基础功能，智能化的应用较少； 在软件资源格外丰富的社区中，还缺少系统化的内容，帮助用户快速实现相关资源的复用。 很多开发者都在魔改ROS，去适配自己的机器人，所以机器人的研发成本非常高。从机械选型、系统定制、算法开发到数据闭环，每个过程都要付出高昂的成本，在这么高昂的成本下，做机器人是非常困难的一件事情。 在算法层面，机器人算法仍处于早期阶段，很多感知算法还停留在理论阶段，无法服务与实际场景，机器学习发展迅速，不过对于很多开发者来讲，数据的采集、标注、训练都是一个庞大的工作量，部署运行不仅十分困难，还要消耗大量的算力成本。 智能机器人涉及的领域和方法较多，目前整体的学习成本偏高，想要实现智能化应用的难度就更高，问题的出现，也带来了机遇与挑战。 地平线机器人开发平台 2022年6月，地平线机器人正式推出全新一代机器人开发平台——Horizon Hobot Platform（HHP），在软件、算法、工具层面给行业带来更多帮助。这套机器人开发平台的目的是打造软硬协同、极致优化、丰富易用的机器人开发组件与生态，由图中这几个部分组成，我们来看下。 平台的底层主要依托于地平线AIOT边缘AI芯片——旭日3和旭日5，内部集成了地平线最先进的伯努利2.0架构的AI 引擎，可提供 5TOPS 以上的等效算力。如此强大的算力支持，保证了智能机器人开发的基础条件。 芯片是基础建设，在此之上更重要的是一系列软件设施，正如我们电脑上的windows和linux，一套优质的操作系统，是上层应用软件开发的必要条件，TogetherROS在ROS系统的基础上，进行了大量的改良和优化，可以为开发者提供高效实用的系统环境。 在此之上，平台还会提供大量的机器人参考算法和应用功能示例，比如常用的建图、定位、导航，还有智能机器人中至关重要的智能化功能，比如一些基础算法，图像分类、图像分割、目标检测等，还有应用功能，人脸检测、人体跟踪、骨骼点检测、手势识别、语音处理等等，提供基于大量数据训练的模型，借助底层AI引擎的支持，可以快速、稳定的实现各种各样的智能应用。 同时平台还会配套一系列加速机器人开发的工具链，比如代码编写工具、系统调试工具、数据标注和训练工具等。 古月居和地平线也会共同打造机器人开发者社区，持续分享技术内容，沉淀更多开发者的智慧，更多机器人产业中的合作伙伴也会陆续加入，共同打造最为丰富的机器人开发者套件，建设智能机器人开发的生态圈。 在这个机器人开发平台之中，最为重要的就是TogetherROS系统了，起到了承上启下、连接各项功能的作用。 TogetherROS的特点 在ROS系统庞大社区资源的基础上，结合智能机器人的发展和产业需求，TogetherROS应运而生。 TogetherROS有三个核心特点： 开源兼容，秉承开源精神的力量 TogetherROS和ROS系统一样，也是一套完全开源的系统，所有开发者都可以继续二次开发，接口方面和ROS2完全兼容，ROS2原有的功能也都可以继续复用，已有的机器人代码可以十分便利的迁移过来。 极致性能优化 相比ROS的通用化，TogetherROS更多考虑的是如何充分挖掘底层硬件的性能，比如提高数据传输的效率、增强人工智能处理的能力，在后续的使用案例中，大家可以充分感受到这一点。 丰富易用的软硬件组件 比如各种各样的传感器和开发套件，再比如算法模块、感知应用、机器人功能，还有提高开发效率的各种编程、部署工具。 TogetherROS系统框架 具体展开来看，TogetherROS的系统框架如图所示，其中深蓝色部分为地平线优化、新增的模块，其他是目前复用ROS2中的模块： 在系统通信的中间件部分，保留了ROS2中原本针对不同DDS的通信框架，与ROS2 foxy版本的接口完全兼容，方便复用ROS丰富工具包进行原型验证，在此之上增加了“zero-copy” 零拷贝 的通信机制，降低大数据传输时延和系统资源消耗。 在组件功能部分，TogetherROS提供“hobot CV” 视觉加速库 ，软硬件协同，可以提升CV算子性能、降低系统资源消耗；针对AI模型的推理，封装了“hobot_dnn” 功能包，可以调用底层芯片的AI引擎，简化板端AI开发与部署，释放BPU的算力。可以支持丰富的机器人传感器型号，比如相机、雷达、IMU、GPS等，节省驱动开发的时间，可以聚焦在机器人应用开发上。 除此之外，TogetherROS还会提供丰富的 软件调试和性能调优工具 ，方便用户定位问题和优化系统性能，在具体的行业应用中，还支持最小化和模块化的剪裁，利于部署在资源受限的嵌入式产品中。 总之，TogetherROS出于ROS，又不止于ROS，ROS原有的功能依然继承，重点是借助硬件能力，充分优化系统的性能，提高机器人开发的效率。","text_tokens":["各样","应运而生","据传","主要","功能","可","陆续","主控","必要条件","其他","平台","总之","应用","想要","就","力量","贡献","剪裁","高","不止","通用","易用","机器","就是","十分","验证","研发","ros","场景","强大","方便","新增","除此","实现","居","5tops","兼容","困难","aiot","还有","6","先进","每个","丰富","使用","不过","重要","二次开发","相比","广泛","深蓝色","参考","中间件","零","最为","充分","依然","行业","聚焦","成本","建图","特点","之中","冲击","继承","进行","从","蓝色","社区资源","下","等效","同时","三个","togetherros","很多","各种各样","算法","考虑","魔","-","利于","电机","还是","层面","边缘","去","目标","会","一件","正式","。","板端",")","起到","嵌入式","处理","调试","借助","挖掘","执行","仍","条件","方法","如何","如图所示","还会","涉及","代码","—","早期","hobot","效率","规控","linux","大脑","链","zero","方面","提升","时延","工具包","各项","通信","继续","传输","这套","伙伴","节省","对于","展开","之外","定位","一套","环境","再","处于","调优","工具","与","都","分类","bpu","已有","秉承","除此之外","基于","以","过来","停留","降低","最","理论","沉淀","开发","系统","支持","套件","接口","持续","自己","迁移","打造","地平线","标注","出现","古月","工作","产品","整体","算力","优化","机遇","提高","horizon","较","调用","完全","此","跟踪","十分困难","推出","platform","操作系统","定位导航","信息","在","迭代","设施","硬件","闭环","挑战","动作","原有","5","_","连接","一个","上","格外","imu","通用化","计算","最小化","社区","事情","是","快速","涌现出","智慧","（","至关重要","旭日","这","提供","这个","一系","目前","中间","运动","一样","“","多","嵌入","版本","以上","缺少","核心","非常","保留","加速","洪流","可以","其中","驱动","foxy","合作伙伴","传感器","时代","智能化","少","逐渐","cv","定制","、","至关","现出","结合","开发者","采集","介绍","部署","生态","导航","伯努利","ros2","难以","配套","组成","机器人","，","具体","性能","学习","领域","视觉","内部","复用","(","数据传输","依托","操作","骨骼","比如","组件","承上启下","等","感受","目的","引擎","用户","所以","模型","标准","部分","问题","出于","成为","原本","识别","为例","软件资源","二次","训练","运行","所有","适配","极致","系列","但","检测","案例","图像","语音","共同","算子","深蓝","也","如此","人工智能","模块化","作为","改良","包","copy","程式","开源","能力","必要","需求","于","：","一代","的","为","和","常用","有","帮助","增强","生态圈"," ","工作量","3","重点","一点","优质","阶段","2022","发挥","等等","建设","推理","各种","定位问题","释放","”","集成","地平","中","点","软硬件","复杂","感知","基础","数据","技术","通用性","分享","更","大量","编程","庞大","hhp","所示","无法","高昂","模块","带来","由图","全新","传感","最小","高效","控制","内容","架构","拷贝","人工","不断","分割","被","过程","还","dnn","软件","涌现","示例","我们","人体","年","上层","应运","后续","一些","dds","系统资源","了","针对","软硬","实用","协同","大家","偏高","相关","2.0","型号","却","系统化","电脑","正如","芯片","到","这么","稳定","框架","之上","改","月","包括","实际","ai","保证","windows","合作","虽然","发展","精神","作用","人脸","手势","封装","迅速","给","gps","来看","不仅","机制","非常复杂","选型","雷达","编写","应用软件","简化","不同","又","大","原型","消耗","加入","；","服务","）","智能","产业","要","机械","感器","资源","库","付出","完整","几个","底层","增加","一系列","来讲","还要","时间","难度","相机","受限","便利","做"],"title":"HHP介绍","title_tokens":["介绍","hhp"]},{"location":"hhp/1.2_%E5%9C%B0%E5%B9%B3%E7%BA%BF%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0%E4%BB%8B%E7%BB%8D/#hhp","text":"机器人是一个非常复杂的系统，硬件部分包括：各种各样感知环境信息的传感器、作为大脑进行计算的主控平台、执行动作的电机等等。软件层面包括：感知算法，规控算法，数据驱动的程式，操作系统等。 以操作系统为例，应用最为广泛的ROS系统在不断迭代，不过在智能时代洪流的冲击下，还是涌现出一些问题。","text_tokens":["是","各样","部分","软件","机器人","涌现","复杂","冲击","：","洪流","涌现出","感知","操作系统","驱动","的","，","数据","传感器","信息","进行","主控","环境","为例","在","时代","执行","问题","不过","包括","迭代","平台"," ","下","硬件","应用","一些","智能","各种各样","、","算法","感器","动作","电机","现出","操作","等等","广泛","还是","规控","以","传感","各种","一个","等","大脑","层面","最为","机器","作为","计算","。","ros","不断","非常复杂","程式","系统","非常"],"title":"地平线机器人开发平台(HHP)介绍","title_tokens":["机器","地平","机器人","平台","hhp","地平线","开发","(","介绍",")"]},{"location":"hhp/1.2_%E5%9C%B0%E5%B9%B3%E7%BA%BF%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0%E4%BB%8B%E7%BB%8D/#ros","text":"ROS逐渐成为标准，大量机器人应用被贡献到社区，虽然提高了代码的通用性，但却难以发挥硬件的完整性能； 大量应用聚焦在机器人运动控制与定位导航等基础功能，智能化的应用较少； 在软件资源格外丰富的社区中，还缺少系统化的内容，帮助用户快速实现相关资源的复用。 很多开发者都在魔改ROS，去适配自己的机器人，所以机器人的研发成本非常高。从机械选型、系统定制、算法开发到数据闭环，每个过程都要付出高昂的成本，在这么高昂的成本下，做机器人是非常困难的一件事情。 在算法层面，机器人算法仍处于早期阶段，很多感知算法还停留在理论阶段，无法服务与实际场景，机器学习发展迅速，不过对于很多开发者来讲，数据的采集、标注、训练都是一个庞大的工作量，部署运行不仅十分困难，还要消耗大量的算力成本。 智能机器人涉及的领域和方法较多，目前整体的学习成本偏高，想要实现智能化应用的难度就更高，问题的出现，也带来了机遇与挑战。","text_tokens":["对于","感知","基础","功能","数据","通用性","定位","更","大量","智能化","少","逐渐","处于","庞大","与","都","定制","应用","无法","、","高昂","想要","就","贡献","带来","开发者","采集","高","部署","通用","停留","机器","导航","十分","研发","ros","控制","内容","场景","实现","难以","理论","被","开发","系统","还","过程","困难","软件","自己","机器人","每个","，","标注","丰富","出现","工作","不过","性能","学习","领域","整体","算力","复用","了","机遇","提高","等","偏高","相关","较","却","聚焦","用户","成本","所以","系统化","标准","十分困难","问题","到","这么","成为","定位导航","改","在","软件资源","从","训练","实际","运行","下","适配","硬件","但","很多","闭环","虽然","算法","发展","魔","挑战","也","迅速","一个","不仅","层面","格外","去","一件","。","选型","社区","事情","是","快速","的","消耗","和","仍","帮助","方法","；"," ","工作量","服务","智能","代码","涉及","要","早期","目前","机械","阶段","运动","资源","发挥","付出","完整","多","来讲","还要","难度","缺少","中","做","非常"],"title":"ROS的一些问题","title_tokens":["的","问题","一些","ros"]},{"location":"hhp/1.2_%E5%9C%B0%E5%B9%B3%E7%BA%BF%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0%E4%BB%8B%E7%BB%8D/#_1","text":"2022年6月，地平线机器人正式推出全新一代机器人开发平台——Horizon Hobot Platform（HHP），在软件、算法、工具层面给行业带来更多帮助。这套机器人开发平台的目的是打造软硬协同、极致优化、丰富易用的机器人开发组件与生态，由图中这几个部分组成，我们来看下。 平台的底层主要依托于地平线AIOT边缘AI芯片——旭日3和旭日5，内部集成了地平线最先进的伯努利2.0架构的AI 引擎，可提供 5TOPS 以上的等效算力。如此强大的算力支持，保证了智能机器人开发的基础条件。 芯片是基础建设，在此之上更重要的是一系列软件设施，正如我们电脑上的windows和linux，一套优质的操作系统，是上层应用软件开发的必要条件，TogetherROS在ROS系统的基础上，进行了大量的改良和优化，可以为开发者提供高效实用的系统环境。 在此之上，平台还会提供大量的机器人参考算法和应用功能示例，比如常用的建图、定位、导航，还有智能机器人中至关重要的智能化功能，比如一些基础算法，图像分类、图像分割、目标检测等，还有应用功能，人脸检测、人体跟踪、骨骼点检测、手势识别、语音处理等等，提供基于大量数据训练的模型，借助底层AI引擎的支持，可以快速、稳定的实现各种各样的智能应用。 同时平台还会配套一系列加速机器人开发的工具链，比如代码编写工具、系统调试工具、数据标注和训练工具等。 古月居和地平线也会共同打造机器人开发者社区，持续分享技术内容，沉淀更多开发者的智慧，更多机器人产业中的合作伙伴也会陆续加入，共同打造最为丰富的机器人开发者套件，建设智能机器人开发的生态圈。 在这个机器人开发平台之中，最为重要的就是TogetherROS系统了，起到了承上启下、连接各项功能的作用。","text_tokens":["各样","主要","加速","可以","基础","可","功能","数据","技术","陆续","分享","合作伙伴","定位","一套","环境","更","必要条件","大量","智能化","平台","工具","与","分类","hhp","应用","、","带来","至关","由图","基于","开发者","全新","生态","易用","机器","伯努利","高效","导航","就是","强大","ros","架构","内容","实现","居","最","分割","5tops","沉淀","开发","支持","系统","aiot","套件","配套","还有","软件","6","组成","机器人","示例","我们","先进","持续","人体","年","，","打造","地平线","标注","丰富","古月","上层","重要","内部","算力","一些","优化","了","依托","操作","比如","组件","骨骼","承上启下","软硬","参考","实用","horizon","协同","等","目的","最为","2.0","行业","引擎","模型","建图","电脑","此","部分","之中","正如","芯片","推出","platform","跟踪","操作系统","稳定","识别","之上","进行","月","在","训练","设施","下","极致","系列","等效","ai","保证","检测","同时","togetherros","windows","合作","算法","图像","各种各样","语音","共同","人脸","作用","5","也","手势","给","连接","来看","上","如此","层面","边缘","会","目标","正式","改良","。","必要","社区","是","快速","于","智慧","编写","一代","处理","应用软件","起到","的","调试","（","为","至关重要","借助","和","旭日","常用","这","条件","帮助","提供","加入","生态圈"," ","3","这个","）","还会","智能","代码","—","产业","hobot","一系","优质","2022","等等","建设","linux","多","几个","底层","各种","链","集成","以上","一系列","地平","各项","中","点","这套","伙伴"],"title":"地平线机器人开发平台","title_tokens":["机器","地平","机器人","平台","地平线","开发"]},{"location":"hhp/1.2_%E5%9C%B0%E5%B9%B3%E7%BA%BF%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0%E4%BB%8B%E7%BB%8D/#togetherros","text":"在ROS系统庞大社区资源的基础上，结合智能机器人的发展和产业需求，TogetherROS应运而生。 TogetherROS有三个核心特点： 开源兼容，秉承开源精神的力量 TogetherROS和ROS系统一样，也是一套完全开源的系统，所有开发者都可以继续二次开发，接口方面和ROS2完全兼容，ROS2原有的功能也都可以继续复用，已有的机器人代码可以十分便利的迁移过来。 极致性能优化 相比ROS的通用化，TogetherROS更多考虑的是如何充分挖掘底层硬件的性能，比如提高数据传输的效率、增强人工智能处理的能力，在后续的使用案例中，大家可以充分感受到这一点。 丰富易用的软硬件组件 比如各种各样的传感器和开发套件，再比如算法模块、感知应用、机器人功能，还有提高开发效率的各种编程、部署工具。","text_tokens":["应运而生","各样","据传","可以","感知","基础","功能","数据","传感器","一套","更","再","编程","庞大","都","工具","应用","、","力量","秉承","已有","模块","结合","开发者","过来","传感","部署","通用","易用","机器","十分","ros","人工","ros2","兼容","开发","系统","套件","接口","还有","机器人","，","迁移","丰富","使用","性能","二次开发","应运","后续","复用","优化","相比","数据传输","比如","组件","软硬","提高","大家","感受","充分","完全","特点","到","在","二次","社区资源","所有","极致","硬件","三个","togetherros","案例","考虑","各种各样","发展","算法","精神","原有","也","上","人工智能","通用化","。","开源","能力","社区","是","需求","：","处理","的","挖掘","和","这","有","增强"," ","如何","一点","智能","代码","产业","效率","感器","资源","一样","多","各种","底层","方面","核心","中","便利","继续","传输","软硬件"],"title":"TogetherROS的特点","title_tokens":["特点","的","togetherros"]},{"location":"hhp/1.2_%E5%9C%B0%E5%B9%B3%E7%BA%BF%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0%E4%BB%8B%E7%BB%8D/#togetherros_1","text":"具体展开来看，TogetherROS的系统框架如图所示，其中深蓝色部分为地平线优化、新增的模块，其他是目前复用ROS2中的模块： 在系统通信的中间件部分，保留了ROS2中原本针对不同DDS的通信框架，与ROS2 foxy版本的接口完全兼容，方便复用ROS丰富工具包进行原型验证，在此之上增加了“zero-copy” 零拷贝 的通信机制，降低大数据传输时延和系统资源消耗。 在组件功能部分，TogetherROS提供“hobot CV” 视觉加速库 ，软硬件协同，可以提升CV算子性能、降低系统资源消耗；针对AI模型的推理，封装了“hobot_dnn” 功能包，可以调用底层芯片的AI引擎，简化板端AI开发与部署，释放BPU的算力。可以支持丰富的机器人传感器型号，比如相机、雷达、IMU、GPS等，节省驱动开发的时间，可以聚焦在机器人应用开发上。 除此之外，TogetherROS还会提供丰富的 软件调试和性能调优工具 ，方便用户定位问题和优化系统性能，在具体的行业应用中，还支持最小化和模块化的剪裁，利于部署在资源受限的嵌入式产品中。 总之，TogetherROS出于ROS，又不止于ROS，ROS原有的功能依然继承，重点是借助硬件能力，充分优化系统的性能，提高机器人开发的效率。","text_tokens":["据传","节省","加速","其中","展开","可以","功能","foxy","驱动","数据","之外","定位","传感器","其他","调优","工具","与","cv","总之","所示","应用","bpu","、","除此之外","模块","剪裁","传感","最小","部署","不止","机器","验证","ros","降低","方便","拷贝","新增","ros2","除此","兼容","系统","开发","支持","dnn","还","接口","软件","机器人","，","地平线","丰富","产品","具体","性能","视觉","算力","复用","dds","优化","系统资源","了","针对","数据传输","深蓝色","比如","组件","软硬","提高","协同","中间件","等","零","调用","充分","型号","完全","引擎","行业","依然","聚焦","用户","模型","此","部分","芯片","问题","出于","原本","框架","继承","之上","进行","在","蓝色","硬件","ai","togetherros","-","利于","算子","深蓝","原有","_","封装","gps","来看","上","模块化","imu","机制","包","。","板端","copy","最小化","能力","是","雷达","于","嵌入式","：","的","调试","简化","不同","又","大","原型","为","消耗","借助","和","提供","；"," ","重点","如图所示","还会","效率","hobot","目前","中间","感器","资源","库","“","推理","底层","释放","版本","”","增加","zero","定位问题","嵌入","时间","提升","时延","地平","工具包","相机","通信","中","受限","传输","软硬件","保留"],"title":"TogetherROS系统框架","title_tokens":["togetherros","框架","系统"]},{"location":"hhp/1.3_HHP%E4%B8%8EROS%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/","text":"地平线机器人开发平台(HHP)与ROS性能对比 ROS2 vs ROS1 先来看下两个大版本ROS的系统架构。 在这张图中，左侧是ROS1，右侧是ROS2，两者最明显的变化，就是Master。 在ROS1中，应用层里Master这个节点管理器的角色至关重要，所有节点都得听它指挥，类似是一个公司的CEO，有且只有一个，如果这个CEO突然消失，公司肯定会成一团乱麻。ROS2把这个最不稳定的角色请走了，节点可以通过另外一套discovery——自发现机制，找到彼此，从而建立稳定的通信连接。 中间层是ROS封装好的标准通信接口，我们写程序的时候，会频繁和这些通信接口打交道，比如发布一个图像的数据，接收一个雷达的信息，客户端库会再调用底层复杂的驱动和通信协议，让我们的开发变得更加简单明了。 在ROS1中，ROS通信依赖底层的TCP和UDP协议，而在ROS2中，通信协议更换成了更加复杂但也更加完善的DDS系统。 如果是在进程内需要进行大量数据的通信，ROS1和ROS2都提供了基于共享内存的通信方法，只不过名字不太一样而已。 最下边是系统层，也就是可以将ROS安装在哪些操作系统上，ROS1主要安装在Linux上，ROS2的可选项就很多了，Linux、windows、MacOS、RTOS都可以。 ROS2系统架构 ROS2相比ROS1最大的变化，除了省略了Master之外，应该就是通信系统的变化了。ROS1中基于TCP/UDP的通信系统，频繁诟病于延迟、丢数据、无法加密等问题，ROS2中的DDS在通信层面的功能就丰富多了。 DDS其实是物联网中广泛应用的一种通信协议，类似于我们常听说的5G通信一样，DDS是一个国际标准，能够实现该标准的软件系统并不是唯一的，所以我们可以选择多个厂家提供的DDS系统，比如这里的OpenSplice、FastRTPS，还有更多厂家提供的，每一家的性能不同，适用的场景也不同。 不过这就带来一个问题，每个DDS厂家的软件接口肯定是不一样的，如果我们按照某一家的接口写完了程序，想要切换其他厂家的DDS，不是要重新写代码么？这当然不符合ROS提高软件复用率的目标。 为了解决这个问题，ROS2设计了一个ROS Middleware，简称RMW，也就是制定一个标准的接口，比如如何发数据，如何收数据，数据的各种属性如何配置，都定义好了，如果厂家想要接入ROS社区，就得按照这个标准写一个适配的接口，把自家的DDS给移植过来，这样就把问题交给了最熟悉自家DDS的厂商。对于我们这些用户来讲，某一个DDS用的不爽，只要安装另一个，然后做一个简单的配置，程序一行的都不用改，轻松更换底层的通信系统。 举一个例子，比如我们在产品开发时，可以先用开源版本的DDS满足基本需求，部署交付的产品时，再更换为商业版本更稳定的DDS，这样可以减少开发成本。 HHP/TogetherROS vs ROS2 HHP中的TogetherROS就是在这样一个ROS2架构的基础上，继续进行了优化，原本DDS通信的部分依然保留，可以适配不同厂家的DDS通信系统，在此之上，针对功能性的组件进行了众多优化和补充，在上一节中我们也给大家介绍了这套框架。 HHP在数据传输和AI处理方面，到底有多少提升呢，我们来看具体的对比数据。 通信效率量化对比 先来看下操作系统至关重要的数据通信功能，我们针对ROS中最为常用的大数据传输模式——话题通信进行了测试。 在单元测试中，使用同样的算力平台，分别安装HHP和ROS2系统，然后在其中运行一个话题通信的发布者与订阅者，实现不同数据量的传输。经过数据统计，我们可以看到，在数据通信延时方面，随着数据量的增加，ROS2系统在通信延时、发送端和接收端的CPU占用率上，都会程线性增加，可以预想，在数据量较大的情况下，系统的通信负荷会非常严重。 而在HHP中的TogetherROS，由于使用了零拷贝的传输机制，传输数据量的增加，并不会导致延时和CPU占用率的增加，极大程度节省了系统资源。 在场景测试中，我们尽量模拟真实机器人的应用，使用HHP和ROS2系统连接了多个相机、雷达和里程计等传感器，作为大量数据的输入来源，继续进行了测试，结果和之前的单元测试类似，ROS2系统此时的CPU占用率已经超过90%，想要运行数据传输之外的应用功能，几乎是不可能的，通信延时也达到了15ms以上，这在某些实时性要求比较高的应用中，是不可接受的。 而在HHP中，CPU占用和通信延时也微乎其微，更多系统资源都可以让给应用处理。 CV图像处理量化对比 再来看下智能机器人中视觉感知层面的处理，HHP集成了地平线Hobot CV视觉加速库，通过底层芯片中的硬件引擎，软硬件协同，可以提升常用CV算子的性能，降低系统资源的消耗，例如高斯滤波、图像缩放、畸变校正等常用的视觉处理方法。 而且在接口风格上兼容OpenCV，可以做到与OpenCV混合编程，便于视觉应用的开发。 具体测试CV加速库的效率，与OpenCV中软件实现的效率进行对比，我们分别对比图像缩放的帧率，图像旋转的帧率，高斯滤波的帧率，通过Hobot CV视觉加速库运行的帧率可以做到OpenCV的2到3倍，甚至更多倍。 模型推理 在AI处理方面，ROS2原生系统中并没有太多支持，只能依赖社区中的资源，很难充分发挥硬件的算力。 对此，HHP集成了Hobot DNN模型推理库，集成了众多开源模型，借助底层芯片中的AI引擎BPU，提供充足的算力保障，开发者实际使用中，就不用花费很多时间在模型的调教和数据的训练上，基于这套系统，很快就可以部署人工智能应用啦。 传感器驱动管理 在传感器层面，是大量数据传输的来源，HHP也重点进行了优化，针对常用的传感器类型，系统中内置参数配置、系统调用和内存管理机制，同样是在芯片的硬件层面进行了加速和隔离，保障数据流的稳定生成。 机器人开发工具 机器人开发过程中的性能优化和调试，也是非常繁杂的工作，HHP自带火焰图等工具，可以实现系统层面的调优和测试，便于开发者挖掘系统性能。 以上这些都是HHP以及其中TogetherROS在ROS系统之上的优化和补充，未来更多特性也会不断迭代推出，让智能机器人的开发更加简单。","text_tokens":["据传","主要","可选","例如","物","功能","线性","一家","里程计","充足","其他","平台","好","补充","由于","定义","opensplice","应用","订阅","省略","就","想要","写","便于","频繁","对此","高","例子","发布者","机器","就是","ros","场景","15ms","实现","兼容","产品开发","还有","每个","类型","丰富","使用","成","选择","不过","重要","彼此","通信接口","节点","依赖","相比","该","广泛","风格","发","占用率","完","零","最为","并","另外","充分","一团","依然","用率","预想","找到","成本","简单","客户端","通过","数据通","进行","发现","占用","当然","没有","下","需要","togetherros","很多","很快","公司","进程","middleware","左侧","重新","乱麻","会","层面","内","目标","。","角色","通信协议",")","为了","处理","调试","借助","挖掘","混合","厂家","方法","国际","如何","代码","—","效率","hobot","到底","之前","linux","帧","制定","方面","提升","而已","通信","更加","继续","传输","这套","应用层","节省","对于","基本","之外","一套","再","调优","？","与","都","适用","移植","工具","一团乱麻","先","bpu","延迟","基于","极大","这些","多倍","过来","5g","层","降低","完善","最","一行","可能","系统","开发","支持","接口","rtos","广泛应用","切换","数据通信","按照","只不过","实时","地平线","几乎","90%","工作","产品","接入","程序","算力","优化","图像处理","联网","呢","除了","模拟","简称","中间层","数据量","提高","程度","调用","设计","国际标准","诟病","此","推出","操作系统","信息","在","迭代","名字","硬件","配置","此时","收","连接","延时","一个","ceo","上","测试","ros1","发送","同样","张图","不是","能够","更换","时候","变得","社区","旋转","保障","是","真实","指挥","不爽","一种","生成","端","至关重要","将","共享","甚至","这","提供","商业","这个","中间","一样","多个","减少","来源","多","版本","已经","以上","功能性","tcp","opencv","/","自","常","非常","保留","2","太","加速","可以","其中","驱动","哪些","传感器","以及","明显","cv","、","微乎其微","类似","一团乱","至关","开发者","么","单元","管理","选项","随着","它","有且","介绍","部署","严重","交道","vs","ros2","理器","统计","率","机器人","应该","可选项","，","而且","然后","不用","具体","性能","只要","较大","视觉","充分发挥","右侧","里","开发工具","复用","(","肯定","数据传输","啦","操作","调教","比如","组件","数据流","等","引擎","用户","所以","接收端","模型","繁杂","标准","部分","问题","原本","走","其实","训练","所有","运行","安装","适配","但","负荷","下边","图像","加密","只有","算子","也","解决","话题","特性","里程","人工智能","库会","轻松","作为","经过","图","让给","udp","自带","开源","唯一","master","需求","未来","macos","于","满足","管理机制","的","输入","不会","客户","为","和","常用","有","fastrtps"," ","熟悉","会成","3","某","重点","厂商","发挥","推理","多少","各种","集成","丢","地平","最大","不可","中","内存","cpu","众多","发成","把","软硬件","如果","复杂","这样","模式","只能","感知","基础","数据","不太","更","大量","编程","rmw","hhp","无法","达到","对比","要求","单元测试","带来","量","传感","让","开发成本","做到","交给","属性","每","架构","拷贝","软件系统","人工","不断","尽量","得","过程","消失","dnn","软件","我们","接受","畸变","倍","符合","情况","打交道","这里","原生","请","dds","举","导致","系统资源","了","针对","会程","一节","从而","软硬","很难","发布","协同","大家","火焰","简单明了","传输数据","比较","内置","校正","协议","另","芯片","两个","间层","discovery","到","稳定","框架","听说","之上","改","分别","交付","实际","ai","管理器","突然","变化","windows","实时性","两者","者","花费","封装","给","高斯","来看","机制","而","超过","自家","结果","雷达","缩放","用","接收","不同","大","共享内存","滤波","消耗","分发","量化","看到","不","智能","要","感器","资源","库","时","某些","底层","增加","参数","隔离","来讲","时间","相机","建立","做","听"],"title":"HHP vs ROS性能对比","title_tokens":["性能","ros"," ","vs","hhp","对比"]},{"location":"hhp/1.3_HHP%E4%B8%8EROS%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/#hhpros","text":"","text_tokens":[],"title":"地平线机器人开发平台(HHP)与ROS性能对比","title_tokens":["机器","地平","性能","机器人","平台","ros","与","hhp","地平线","开发","(",")","对比"]},{"location":"hhp/1.3_HHP%E4%B8%8EROS%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/#ros2-vs-ros1","text":"先来看下两个大版本ROS的系统架构。 在这张图中，左侧是ROS1，右侧是ROS2，两者最明显的变化，就是Master。 在ROS1中，应用层里Master这个节点管理器的角色至关重要，所有节点都得听它指挥，类似是一个公司的CEO，有且只有一个，如果这个CEO突然消失，公司肯定会成一团乱麻。ROS2把这个最不稳定的角色请走了，节点可以通过另外一套discovery——自发现机制，找到彼此，从而建立稳定的通信连接。 中间层是ROS封装好的标准通信接口，我们写程序的时候，会频繁和这些通信接口打交道，比如发布一个图像的数据，接收一个雷达的信息，客户端库会再调用底层复杂的驱动和通信协议，让我们的开发变得更加简单明了。 在ROS1中，ROS通信依赖底层的TCP和UDP协议，而在ROS2中，通信协议更换成了更加复杂但也更加完善的DDS系统。 如果是在进程内需要进行大量数据的通信，ROS1和ROS2都提供了基于共享内存的通信方法，只不过名字不太一样而已。 最下边是系统层，也就是可以将ROS安装在哪些操作系统上，ROS1主要安装在Linux上，ROS2的可选项就很多了，Linux、windows、MacOS、RTOS都可以。","text_tokens":["如果","应用层","主要","复杂","可选","可以","驱动","数据","不太","哪些","一套","大量","再","明显","好","都","应用","一团乱麻","先","、","类似","一团乱","就","至关","基于","写","这些","管理","频繁","选项","让","它","有且","交道","就是","ros","层","架构","完善","ros2","理器","最","得","系统","消失","开发","接口","rtos","我们","可选项","，","只不过","成","不过","重要","打交道","程序","彼此","通信接口","右侧","里","节点","依赖","请","dds","了","肯定","操作","从而","中间层","比如","发布","另外","调用","一团","简单明了","找到","协议","标准","两个","间层","简单","操作系统","客户端","discovery","稳定","通过","走","进行","信息","发现","在","所有","下","需要","名字","安装","管理器","但","很多","突然","变化","公司","图像","下边","windows","只有","进程","左侧","两者","也","乱麻","封装","连接","来看","一个","ceo","上","会","ros1","库会","内","机制","张图","。","而","角色","更换","通信协议","udp","时候","变得","是","master","雷达","指挥","macos","的","接收","客户","大","共享内存","至关重要","将","共享","和","这","提供","方法"," ","会成","这个","不","—","中间","一样","linux","底层","版本","tcp","而已","通信","中","建立","内存","更加","自","把","听"],"title":"ROS2 vs ROS1","title_tokens":[" ","vs","ros1","ros2"]},{"location":"hhp/1.3_HHP%E4%B8%8EROS%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/#ros2","text":"ROS2相比ROS1最大的变化，除了省略了Master之外，应该就是通信系统的变化了。ROS1中基于TCP/UDP的通信系统，频繁诟病于延迟、丢数据、无法加密等问题，ROS2中的DDS在通信层面的功能就丰富多了。 DDS其实是物联网中广泛应用的一种通信协议，类似于我们常听说的5G通信一样，DDS是一个国际标准，能够实现该标准的软件系统并不是唯一的，所以我们可以选择多个厂家提供的DDS系统，比如这里的OpenSplice、FastRTPS，还有更多厂家提供的，每一家的性能不同，适用的场景也不同。 不过这就带来一个问题，每个DDS厂家的软件接口肯定是不一样的，如果我们按照某一家的接口写完了程序，想要切换其他厂家的DDS，不是要重新写代码么？这当然不符合ROS提高软件复用率的目标。 为了解决这个问题，ROS2设计了一个ROS Middleware，简称RMW，也就是制定一个标准的接口，比如如何发数据，如何收数据，数据的各种属性如何配置，都定义好了，如果厂家想要接入ROS社区，就得按照这个标准写一个适配的接口，把自家的DDS给移植过来，这样就把问题交给了最熟悉自家DDS的厂商。对于我们这些用户来讲，某一个DDS用的不爽，只要安装另一个，然后做一个简单的配置，程序一行的都不用改，轻松更换底层的通信系统。 举一个例子，比如我们在产品开发时，可以先用开源版本的DDS满足基本需求，部署交付的产品时，再更换为商业版本更稳定的DDS，这样可以减少开发成本。","text_tokens":["如果","这样","对于","基本","物","之外","可以","功能","数据","一家","更","其他","再","好","？","rmw","都","适用","移植","定义","opensplice","应用","无法","省略","、","类似","延迟","就","想要","先","带来","基于","写","么","这些","频繁","过来","开发成本","5g","例子","部署","就是","交给","属性","场景","每","ros","软件系统","ros2","实现","最","得","一行","系统","开发","率","接口","产品开发","还有","广泛应用","软件","切换","应该","我们","按照","每个","，","丰富","符合","然后","选择","不用","产品","不过","性能","只要","接入","程序","这里","复用","dds","举","联网","了","除了","相比","肯定","该","简称","广泛","比如","发","完","提高","等","并","设计","国际标准","用户","成本","所以","诟病","协议","另","标准","问题","简单","稳定","听说","改","在","其实","交付","当然","安装","适配","变化","加密","middleware","配置","重新","也","收","解决","给","一个","层面","ros1","目标","轻松","。","不是","能够","更换","通信协议","udp","自家","开源","社区","唯一","是","为了","master","需求","不爽","于","满足","一种","用","的","不同","为","这","厂家","国际","提供","fastrtps"," ","熟悉","某","如何","这个","商业","不","代码","厂商","要","一样","时","多个","减少","多","各种","底层","版本","把","来讲","丢","制定","tcp","最大","通信","中","做","/","发成","常"],"title":"ROS2系统架构","title_tokens":["架构","ros2","系统"]},{"location":"hhp/1.3_HHP%E4%B8%8EROS%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/#hhptogetherros-vs-ros2","text":"HHP中的TogetherROS就是在这样一个ROS2架构的基础上，继续进行了优化，原本DDS通信的部分依然保留，可以适配不同厂家的DDS通信系统，在此之上，针对功能性的组件进行了众多优化和补充，在上一节中我们也给大家介绍了这套框架。 HHP在数据传输和AI处理方面，到底有多少提升呢，我们来看具体的对比数据。","text_tokens":["此","部分","众多","据传","我们","这样","可以","处理","基础","功能","的","，","原本","框架","不同","数据","之上","进行","在","和","具体","厂家","有"," ","适配","补充","ai","hhp","togetherros","dds","优化","呢","了","对比","针对","数据传输","一节","也","到底","多少","给","组件","来看","一个","上","大家","介绍","方面","功能性","就是","提升","依然","架构","。","通信","中","ros2","系统","继续","传输","这套","保留"],"title":"HHP/TogetherROS vs ROS2","title_tokens":[" ","vs","ros2","hhp","togetherros","/"]},{"location":"hhp/1.3_HHP%E4%B8%8EROS%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/#_1","text":"先来看下操作系统至关重要的数据通信功能，我们针对ROS中最为常用的大数据传输模式——话题通信进行了测试。 在单元测试中，使用同样的算力平台，分别安装HHP和ROS2系统，然后在其中运行一个话题通信的发布者与订阅者，实现不同数据量的传输。经过数据统计，我们可以看到，在数据通信延时方面，随着数据量的增加，ROS2系统在通信延时、发送端和接收端的CPU占用率上，都会程线性增加，可以预想，在数据量较大的情况下，系统的通信负荷会非常严重。 而在HHP中的TogetherROS，由于使用了零拷贝的传输机制，传输数据量的增加，并不会导致延时和CPU占用率的增加，极大程度节省了系统资源。 在场景测试中，我们尽量模拟真实机器人的应用，使用HHP和ROS2系统连接了多个相机、雷达和里程计等传感器，作为大量数据的输入来源，继续进行了测试，结果和之前的单元测试类似，ROS2系统此时的CPU占用率已经超过90%，想要运行数据传输之外的应用功能，几乎是不可能的，通信延时也达到了15ms以上，这在某些实时性要求比较高的应用中，是不可接受的。 而在HHP中，CPU占用和通信延时也微乎其微，更多系统资源都可以让给应用处理。","text_tokens":["据传","节省","模式","其中","可以","之外","功能","数据","线性","传感器","更","里程计","大量","平台","与","都","由于","hhp","应用","订阅","达到","先","、","类似","要求","想要","微乎其微","单元测试","至关","极大","量","单元","随着","传感","高","严重","发布者","机器","ros","场景","拷贝","15ms","ros2","实现","尽量","可能","统计","系统","数据通信","机器人","我们","接受","，","实时","使用","然后","几乎","90%","重要","较大","情况","算力","系统资源","导致","了","模拟","针对","数据传输","操作","会程","数据量","占用率","发布","等","零","程度","最为","并","预想","传输数据","用率","比较","接收端","操作系统","数据通","进行","分别","在","占用","运行","下","安装","负荷","togetherros","实时性","此时","也","者","连接","话题","延时","来看","一个","上","测试","里程","会","发送","同样","机制","作为","经过","。","而","让给","超过","结果","真实","是","雷达","处理","的","端","接收","不会","不同","输入","大","至关重要","常用","和","这"," ","看到","不","—","感器","资源","某些","多个","之前","来源","多","已经","增加","以上","方面","相机","不可","通信","中","cpu","继续","传输","非常"],"title":"通信效率量化对比","title_tokens":["效率","量化","通信","对比"]},{"location":"hhp/1.3_HHP%E4%B8%8EROS%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/#cv","text":"再来看下智能机器人中视觉感知层面的处理，HHP集成了地平线Hobot CV视觉加速库，通过底层芯片中的硬件引擎，软硬件协同，可以提升常用CV算子的性能，降低系统资源的消耗，例如高斯滤波、图像缩放、畸变校正等常用的视觉处理方法。 而且在接口风格上兼容OpenCV，可以做到与OpenCV混合编程，便于视觉应用的开发。 具体测试CV加速库的效率，与OpenCV中软件实现的效率进行对比，我们分别对比图像缩放的帧率，图像旋转的帧率，高斯滤波的帧率，通过Hobot CV视觉加速库运行的帧率可以做到OpenCV的2到3倍，甚至更多倍。","text_tokens":["2","例如","加速","可以","感知","更","再","编程","cv","与","hhp","应用","、","对比","便于","多倍","做到","机器","降低","实现","兼容","开发","系统","率","接口","软件","机器人","我们","畸变","倍","，","而且","地平线","具体","性能","视觉","系统资源","了","风格","软硬","协同","等","引擎","校正","芯片","到","通过","分别","进行","在","运行","下","硬件","图像","算子","高斯","来看","上","测试","层面","。","旋转","缩放","处理","的","滤波","消耗","甚至","常用","混合","方法"," ","3","智能","效率","hobot","资源","库","帧","底层","集成","提升","地平","中","opencv","软硬件"],"title":"CV图像处理量化对比","title_tokens":["量化","图像","cv","处理","图像处理","对比"]},{"location":"hhp/1.3_HHP%E4%B8%8EROS%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/#_2","text":"在AI处理方面，ROS2原生系统中并没有太多支持，只能依赖社区中的资源，很难充分发挥硬件的算力。 对此，HHP集成了Hobot DNN模型推理库，集成了众多开源模型，借助底层芯片中的AI引擎BPU，提供充足的算力保障，开发者实际使用中，就不用花费很多时间在模型的调教和数据的训练上，基于这套系统，很快就可以部署人工智能应用啦。","text_tokens":["保障","众多","太","芯片","只能","处理","可以","，","的","数据","使用","不用","分发","在","借助","充足","和","训练","实际","提供","开发","没有"," ","硬件","ai","原生","充分发挥","算力","hhp","很多","依赖","这套","很快","智能","bpu","应用","了","hobot","就","资源","啦","发挥","库","基于","调教","开发者","推理","花费","对此","很难","多","开源","底层","上","部署","人工智能","集成","时间","方面","并","充分","系统","。","引擎","人工","中","ros2","支持","模型","dnn","社区"],"title":"模型推理","title_tokens":["模型","推理"]},{"location":"hhp/1.3_HHP%E4%B8%8EROS%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/#_3","text":"在传感器层面，是大量数据传输的来源，HHP也重点进行了优化，针对常用的传感器类型，系统中内置参数配置、系统调用和内存管理机制，同样是在芯片的硬件层面进行了加速和隔离，保障数据流的稳定生成。","text_tokens":["保障","是","据传","芯片","加速","管理机制","生成","，","数据","的","稳定","类型","进行","传感器","在","常用","和","大量","硬件","重点","hhp","优化","、","了","配置","感器","数据传输","针对","也","来源","管理","数据流","传感","层面","参数","隔离","机制","同样","调用","。","中","内置","内存","系统","传输"],"title":"传感器驱动管理","title_tokens":["感器","管理","驱动","传感","传感器"]},{"location":"hhp/1.3_HHP%E4%B8%8EROS%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/#_4","text":"机器人开发过程中的性能优化和调试，也是非常繁杂的工作，HHP自带火焰图等工具，可以实现系统层面的调优和测试，便于开发者挖掘系统性能。 以上这些都是HHP以及其中TogetherROS在ROS系统之上的优化和补充，未来更多特性也会不断迭代推出，让智能机器人的开发更加简单。","text_tokens":["繁杂","是","机器人","未来","推出","可以","其中","简单","的","调试","，","之上","挖掘","工作","在","更","和","以及","性能","迭代","调优"," ","工具","都","补充","hhp","togetherros","优化","智能","也","开发者","这些","便于","特性","多","让","等","测试","层面","会","以上","机器","图","火焰","系统","。","ros","不断","中","实现","过程","开发","自带","更加","非常"],"title":"机器人开发工具","title_tokens":["机器","机器人","工具","开发工具","开发"]},{"location":"hhp/1.4_HHP%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/","text":"地平线机器人开发平台(HHP)应用场景 相比手机、电脑等通用平台，机器人的类型可是千变万化，构建机器人操作系统的难度就远比手机和电脑的操作系统要复杂很多。机器人的主流应用大致可以分为 服务机器人、工业机器人、特种机器人 三个方向，无论是在哪一方向，都会面临很多问题。比如传感器、执行器等器件选型复杂，不同场景下需要的性能和参数都有所不同，这就要求操作系统得兼容尽量多的器件。 不同场景下的计算平台算力和资源差异很大，一般都需要进行定制化的裁剪和优化，这就得有一系列工具便于系统的定制和裁剪。每个场景中的应用功能变化也很大，各种算法的集成和开发要尽量简单，算法基于的数据也在持续迭代，需要一套工具链来提供迭代和升级。 针对各种各样的需求变化，HHP都提供了支持。 服务机器人 在服务机器人领域，场景和功能尤其复杂，有家里的扫地机器人，有餐厅里的送餐机器人，有咖啡店里的双臂机器人，还有物流送货的飞行机器人，虽然每一个机器人平台的构型不同，但都需要动态处理多种多样的环境变化，这就需要HHP基于大量数据的AI处理和丰富的组件功能支持，快速推动各种功能的落地。 工业机器人 在工业机器人领域，目前的机器人主要以工业机械臂和物流移动机器人形态为主，场景相比服务机器人要标准很多，核心目的是要提高生产效率，这就要求机器人可以长期稳定的运行，同时实时处理各项运动功能，HHP可裁剪和性能稳定等特点，都可以符合要求。 特种机器人 而在特种机器人的应用领域，结合了服务和工业场景中的不少特点，机器人形态多变，得动态处理各种复杂场景里的事件，例如火灾、地震、管道等场景，更是会发生很多不可预料的情况，HHP中的AI处理可以较好的保障不同环境中的感知效果，同时端云联动，可以实现大量数据的训练和部署，不断提高对复杂环境的处理能力。 可见，HHP充分考虑了众多应用场景的需求，不仅可以满足智能机器人开发过程中的每一个环节，也考虑到了机器人未来在产业中的应用效果。","text_tokens":["各样","主要","复杂","咖啡店","例如","可以","差异","感知","功能","可","尤其","数据","飞行","端云","传感器","构型","一套","环境","多样","大量","动态","有所","平台","更是","好","工具","都","定制","链来","咖啡","餐厅","hhp","应用","、","臂","远","要求","就","结合","基于","形态","便于","以","传感","可见","推动","部署","充分考虑","通用","机器","场景","每","事件","不断","实现","尽量","得","过程","兼容","系统","开发","支持","动机","还有","持续","机器人","物流","每个","，","实时","无论","器件","类型","地平线","丰富","符合","生产","性能","情况","无论是","有所不同","领域","多种","算力","里","(","一","优化","了","相比","针对","操作","家里","符合要求","比如","组件","发生","提高","等","主流","很大","目的","较","充分","为主","实时处理","多变","送餐","升级","特点","电脑","标准","问题","简单","操作系统","方向","管道","到","稳定","进行","在","移动","环节","训练","迭代","运行","下","需要","系列","ai","同时","但","三个","大致","很多","变化","执行器","算法","分为","各种各样","扫地","虽然","考虑","裁剪","对","也","手机","化","一个","不仅","会","计算","。","而","不少","一般","选型",")","应用领域","能力","地震","保障","联动","是","需求","未来","快速","满足","长期","处理","千变万化","的","不同","火灾","构建","和","执行","这","有","提供","可是"," ","服务","智能","效率","效果","要","一系","工业","目前","感器","资源","机械","运动","产业","移动机器人","多种多样","双臂","比","多","各种","参数","一系列","集成","难度","地平","预料","落地","核心","各项","不可","中","哪","送货","特种","众多","面临"],"title":"HHP应用场景","title_tokens":["场景","hhp","应用"]},{"location":"hhp/1.4_HHP%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/#hhp","text":"相比手机、电脑等通用平台，机器人的类型可是千变万化，构建机器人操作系统的难度就远比手机和电脑的操作系统要复杂很多。机器人的主流应用大致可以分为 服务机器人、工业机器人、特种机器人 三个方向，无论是在哪一方向，都会面临很多问题。比如传感器、执行器等器件选型复杂，不同场景下需要的性能和参数都有所不同，这就要求操作系统得兼容尽量多的器件。 不同场景下的计算平台算力和资源差异很大，一般都需要进行定制化的裁剪和优化，这就得有一系列工具便于系统的定制和裁剪。每个场景中的应用功能变化也很大，各种算法的集成和开发要尽量简单，算法基于的数据也在持续迭代，需要一套工具链来提供迭代和升级。 针对各种各样的需求变化，HHP都提供了支持。","text_tokens":["各样","复杂","可以","差异","功能","数据","传感器","一套","有所","平台","工具","都","定制","链来","hhp","应用","、","远","要求","就","基于","便于","传感","通用","机器","场景","尽量","得","兼容","系统","开发","支持","持续","机器人","每个","，","无论","器件","类型","性能","无论是","有所不同","算力","一","优化","了","相比","针对","操作","比如","等","主流","很大","升级","电脑","问题","简单","操作系统","方向","进行","在","迭代","下","需要","系列","三个","大致","很多","变化","执行器","算法","分为","各种各样","裁剪","也","手机","化","会","计算","。","一般","选型","需求","千变万化","的","不同","构建","和","执行","这","有","提供","可是"," ","服务","要","一系","工业","感器","资源","比","多","各种","参数","一系列","集成","难度","中","哪","特种","面临"],"title":"地平线机器人开发平台(HHP)应用场景","title_tokens":["机器","地平","机器人","平台","场景","hhp","地平线","开发","(","应用",")"]},{"location":"hhp/1.4_HHP%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/#_1","text":"在服务机器人领域，场景和功能尤其复杂，有家里的扫地机器人，有餐厅里的送餐机器人，有咖啡店里的双臂机器人，还有物流送货的飞行机器人，虽然每一个机器人平台的构型不同，但都需要动态处理多种多样的环境变化，这就需要HHP基于大量数据的AI处理和丰富的组件功能支持，快速推动各种功能的落地。","text_tokens":["还有","机器人","快速","复杂","咖啡店","物流","处理","功能","，","尤其","的","飞行","不同","数据","丰富","构型","在","环境","和","多样","大量","动态","有","这","平台","领域","需要","多种","服务","都","ai","咖啡","餐厅","里","但","hhp","变化","虽然","扫地","就","家里","基于","多种多样","双臂","组件","各种","一个","推动","机器","场景","每","落地","。","送货","送餐","支持"],"title":"服务机器人","title_tokens":["机器","服务","机器人"]},{"location":"hhp/1.4_HHP%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/#_2","text":"在工业机器人领域，目前的机器人主要以工业机械臂和物流移动机器人形态为主，场景相比服务机器人要标准很多，核心目的是要提高生产效率，这就要求机器人可以长期稳定的运行，同时实时处理各项运动功能，HHP可裁剪和性能稳定等特点，都可以符合要求。","text_tokens":["特点","是","标准","机器人","主要","物流","长期","可以","处理","功能","可","，","的","稳定","实时","符合","在","移动","和","生产","这","性能","运行","领域","服务","都","同时","hhp","很多","效率","臂","要","目前","工业","机械","相比","就","要求","运动","裁剪","移动机器人","符合要求","形态","以","提高","等","目的","机器","为主","场景","。","核心","各项","实时处理","动机"],"title":"工业机器人","title_tokens":["机器","机器人","工业"]},{"location":"hhp/1.4_HHP%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/#_3","text":"而在特种机器人的应用领域，结合了服务和工业场景中的不少特点，机器人形态多变，得动态处理各种复杂场景里的事件，例如火灾、地震、管道等场景，更是会发生很多不可预料的情况，HHP中的AI处理可以较好的保障不同环境中的感知效果，同时端云联动，可以实现大量数据的训练和部署，不断提高对复杂环境的处理能力。 可见，HHP充分考虑了众多应用场景的需求，不仅可以满足智能机器人开发过程中的每一个环节，也考虑到了机器人未来在产业中的应用效果。","text_tokens":["复杂","例如","可以","感知","端云","数据","环境","大量","动态","更是","好","hhp","应用","、","结合","形态","可见","部署","充分考虑","机器","场景","每","事件","不断","实现","得","过程","开发","机器人","，","情况","领域","里","了","发生","提高","等","较","充分","多变","特点","管道","到","在","环节","训练","ai","同时","很多","考虑","对","也","一个","不仅","会","。","而","不少","能力","应用领域","地震","保障","联动","需求","未来","满足","处理","的","火灾","不同","和"," ","服务","智能","效果","产业","工业","各种","预料","不可","中","特种","众多"],"title":"特种机器人","title_tokens":["机器","特种","机器人"]},{"location":"hhp/2.1_%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6%E4%BB%8B%E7%BB%8D/","text":"机器人开发套件(旭日X3派)介绍 HHP是一个软件+硬件的系统，硬件层面当然需要一个强有力的计算平台啦。之前我们提到，HHP会基于地平线的AI芯片，充分发挥硬件性能，我们如何使用这颗芯片呢？ 旭日X3派 没问题，地平线已经为我们准备好了，那就是搭载旭日X3芯片的机器人开发板——旭日X3派。 第一眼看上去，大家是否会想到树莓派呢？没错，为了适应开发者的使用习惯，兼容市面上大量已有的模块，旭日X3派的整体外观和接口形态都接近树莓派，不过面向的开发对象以及板卡的计算实力，和树莓派就完全不同了。 类似这些常用的传感器，旭日X3派统统都可以支持，未来还有更多机器人套件会出现在大家身边。 大家可以在这张表中，看到旭日X3派的硬件资源，CPU是四核A53，频率1.2Hz，在系统内还可以进行超频，BPU就是硬件级的AI引擎，这是旭日X3派相比市面上其他开发板，最大的不同，也是核心性能的主要来源，类似于业界常听到的NPU，这里使用的是地平线机器人独有的伯努利2.0架构，可以提供5Tops的等效算力支持。 内存方面，大家可以选择2GB或者4GB的版本，存储使用的是SD卡，我们可以自行选择，只要大于8GB就可以啦。 在多媒体方面，旭日X3派支持硬件级别的H265和H264编解码，常用的图像和视频都可以流畅播放。 接口方面，尽量可以满足我们常用外接设备和开发的需求，这里是一个CSI的相机接口，板载USB有3个，包含1个USB3.0和2个USB2.0，这里是一个板载的调试串口，我们可以通过它获取系统层面的很多调试信息，也可以与板卡进行通信。 板卡上也搭载了有线网络和无线网络，这个有线网口我们可以直接用网线连接到电脑，就可以在电脑上远程登录和板卡通信了，或者连接到路由器，让板卡直接上网，无线网络和蓝牙是一个二合一的模块，我们也可以直接通过wiki，让板卡连接到某个网络中。 显示接口主要是这里的HDMI，如果我们先要看到系统界面，或者后续很多视觉例程的识别效果，都可以通过HDMI外接一个显示器进行显示。 最后还有至关重要的扩展接口，有40个引脚，和树莓派的接口定义一致，什么GPIO、串口、I2C、SPI等等，一应俱全。 这块板卡我们在使用的时候，推荐使用5V3A的电源，通过TypeC线连接到这里供电，官方提供的系统目前是Ubuntu20.04，使用起来和原生系统没有太大差别。 总体来讲， 旭日X3派是一款面向生态开发者的嵌入式AI开发板，接口兼容树莓派，具有5Tops的端侧推理算力，以及4核ARM A53的处理能力。 面对个人开发者，旭日X3派可以让每一位开发者拥有自己的AI开发套件，不再受开发板高昂的价格限制，面对高等院校，使用旭日X3派开发套件探索AI和机器人应用是学习的开始，有助于学生快速入门人工智能与机器人开发，面对产业，旭日X3派以及地平线的AI工具链，可以帮助客户将产品尽快推向市场，快速落地智能机器人方向的解决方案。 旭日X3M芯片 在旭日X3派上，最为核心的当然就是这颗AI芯片了，这是关于芯片的具体信息，供大家参考。 值得一提的是，随着芯片的技术迭代，2023年，地平线将推出X5芯片，比较大的变化是CPU升级到了8核A55，主频提升到1.8GHz，BPU的算力也将达到8Tops，还加入了GPU，以及更多可扩展的接口。 在使用旭日X3派的过程中，大家也可以期待旭日X5派了。 旭日X3派接口 好啦，还是回到旭日X3派的开发接口上来，我们再做一个整理，这些就是我们使用开发板进行智能机器人开发过程中，最为常用的接口啦。 大家目前在树莓派或者其他开发板上使用的绝大部分模块，基本都可以在旭日X3派上复用，同时还有更多智能化的玩法等着大家。 关于40Pin扩展接口的序号排布，大家可以看这里，引脚的序号是从靠近HDMI板卡内测的开始算起，是引脚1，然后依次蛇形计数，分别是1、2、3、4、5，一直到这里是39和40。 上图是40PIN扩展接口的详细定义，有3.3V和5V的电源信号，有I2C、I2S、SPI、UART等通信接口，还有很多可动态配置的GPIO信号，基本可以满足各种各样的机器人开发啦。 好啦，关于旭日X3派这块开发板我们已经了解清楚了，具体该如何使用呢，我们后续操作起来。","text_tokens":["各样","主要","hdmi","可","探索","其他","平台","好","定义","派","8tops","应用","流畅","就","合一","40pin","院校","电源","机器","就是","gpio","最后","什么","5tops","兼容","值得一提的是","还有","业界","外","使用","选择","不过","重要","8gb","i2s","引脚","a55","通信接口","这块","v","相比","该","参考","最为","充分","usb","具有","解码","升级","卡","级别","通过","玩法","进行","当然","没有","需要","等效","同时","供电","很多","俱全","usb2.0","各种各样","一应俱全","回到","hz","拥有","ghz","还是","看","层面","会","内","8","。","上来","i2c",")","二合一","为了","主频","嵌入式","sd","处理","调试","一款","csi","常听到","上去","如何","—","第一眼","内测","之前","链","方面","高等院校","提升","通信","外接","1.8","wiki","无线网","基本","二合","上图","接近","蛇形","再","第一","？","都","与","工具","3.3","外观","bpu","先","已有","没错","基于","形态","这些","大部分","高等","助于","关于","typec","开发","系统","支持","套件","线","接口","起来","自己","推向","有线网","地平线","出现","网络","产品","不再","整体","这是","算力","呢","x3","供","口","大于","板载","了解","一位","完全","强有力","那","推出","推向市场","方向","信息","在","听到","迭代","板卡","硬件","计数","扩展","配置","5","实力","连接","一个","上","计算","npu","想到","h265","时候","接设备","是","远程","快速","核","一致","频率","至关重要","或者","将","旭日","这","提供","编解码","这个","对象","路由","目前","包含","序号","级","官方","来源","多","嵌入","版本","已经","期待","有助","核心","面对","2","太","值得","可以","整理","绝大","传感器","以及","智能化","动态","市面上","详细","一直","面向","39","搭载","、","类似","40","至关","存储","开发者","随着","它","介绍","四核","生态","伯努利","无线网络","一眼","准备","机器人","市场","树莓","，","然后","直接","具体","性能","只要","学习","视觉","充分发挥","复用","(","啦","一应","操作","价格","等","引擎","多媒体","登录","部分","是从","问题","x5","识别","个","串口","图像","usb3.0","spi","学生","尽快","也","解决","网线","受","人工智能","uart","端侧","4gb","方案","能力","需求","未来","于","满足","某个","的","自行","着","客户","+","为","和","常用","有","帮助","解决方案"," ","3","设备","适应","播放","上网","靠近","发挥","等等","推理","无线","各种","起","地平","提到","落地","最大","中","内存","cpu","ubuntu20.04","如果","例程","统统","技术","绝大部分","路由器","更","大量","推荐","1","hhp","arm","达到","高昂","模块","传感","让","总体","每","架构","4","人工","尽量","过程","还","软件","我们","线网","超频","年","没","有助于","身边","差别","个人","这里","市面","视频","5v3a","原生","后续","入门","2023","大部","有线","信号","了","gpu","面上","看上去","接口定义","算","蓝牙","大家","是否","限制","2.0","比较","开始","电脑","芯片","硬件资源","习惯","到","分别","独有","5v","ai","有力","变化","排布","这颗","h264","显示器","2gb","清楚","x3m","依次","用","不同","看上","大","开发板","分发","界面","加入","1.2","看到","智能","效果","要","产业","感器","资源","获取","张表中","媒体","来讲","显示","相机","做","a53","调试信息"],"title":"机器人开发套件介绍","title_tokens":["机器","机器人","开发","介绍","套件"]},{"location":"hhp/2.1_%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6%E4%BB%8B%E7%BB%8D/#x3","text":"HHP是一个软件+硬件的系统，硬件层面当然需要一个强有力的计算平台啦。之前我们提到，HHP会基于地平线的AI芯片，充分发挥硬件性能，我们如何使用这颗芯片呢？","text_tokens":["是","软件","强有力","我们","芯片","的","，","地平线","+","使用","分发","性能","当然","平台","需要","？","硬件","ai","充分发挥","如何","hhp","有力","呢","啦","发挥","基于","之前","这颗","一个","层面","会","充分","地平","计算","。","提到","系统"],"title":"机器人开发套件(旭日X3派)介绍","title_tokens":["机器","旭日","x3","机器人","派","开发","(","介绍","套件",")"]},{"location":"hhp/2.1_%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6%E4%BB%8B%E7%BB%8D/#x3_1","text":"没问题，地平线已经为我们准备好了，那就是搭载旭日X3芯片的机器人开发板——旭日X3派。 第一眼看上去，大家是否会想到树莓派呢？没错，为了适应开发者的使用习惯，兼容市面上大量已有的模块，旭日X3派的整体外观和接口形态都接近树莓派，不过面向的开发对象以及板卡的计算实力，和树莓派就完全不同了。 类似这些常用的传感器，旭日X3派统统都可以支持，未来还有更多机器人套件会出现在大家身边。 大家可以在这张表中，看到旭日X3派的硬件资源，CPU是四核A53，频率1.2Hz，在系统内还可以进行超频，BPU就是硬件级的AI引擎，这是旭日X3派相比市面上其他开发板，最大的不同，也是核心性能的主要来源，类似于业界常听到的NPU，这里使用的是地平线机器人独有的伯努利2.0架构，可以提供5Tops的等效算力支持。 内存方面，大家可以选择2GB或者4GB的版本，存储使用的是SD卡，我们可以自行选择，只要大于8GB就可以啦。 在多媒体方面，旭日X3派支持硬件级别的H265和H264编解码，常用的图像和视频都可以流畅播放。 接口方面，尽量可以满足我们常用外接设备和开发的需求，这里是一个CSI的相机接口，板载USB有3个，包含1个USB3.0和2个USB2.0，这里是一个板载的调试串口，我们可以通过它获取系统层面的很多调试信息，也可以与板卡进行通信。 板卡上也搭载了有线网络和无线网络，这个有线网口我们可以直接用网线连接到电脑，就可以在电脑上远程登录和板卡通信了，或者连接到路由器，让板卡直接上网，无线网络和蓝牙是一个二合一的模块，我们也可以直接通过wiki，让板卡连接到某个网络中。 显示接口主要是这里的HDMI，如果我们先要看到系统界面，或者后续很多视觉例程的识别效果，都可以通过HDMI外接一个显示器进行显示。 最后还有至关重要的扩展接口，有40个引脚，和树莓派的接口定义一致，什么GPIO、串口、I2C、SPI等等，一应俱全。 这块板卡我们在使用的时候，推荐使用5V3A的电源，通过TypeC线连接到这里供电，官方提供的系统目前是Ubuntu20.04，使用起来和原生系统没有太大差别。 总体来讲， 旭日X3派是一款面向生态开发者的嵌入式AI开发板，接口兼容树莓派，具有5Tops的端侧推理算力，以及4核ARM A53的处理能力。 面对个人开发者，旭日X3派可以让每一位开发者拥有自己的AI开发套件，不再受开发板高昂的价格限制，面对高等院校，使用旭日X3派开发套件探索AI和机器人应用是学习的开始，有助于学生快速入门人工智能与机器人开发，面对产业，旭日X3派以及地平线的AI工具链，可以帮助客户将产品尽快推向市场，快速落地智能机器人方向的解决方案。","text_tokens":["主要","hdmi","探索","其他","好","定义","派","应用","流畅","就","合一","院校","电源","机器","就是","gpio","最后","什么","5tops","兼容","还有","业界","外","使用","选择","不过","重要","8gb","引脚","这块","相比","usb","具有","解码","卡","级别","通过","进行","没有","等效","供电","很多","俱全","usb2.0","一应俱全","hz","拥有","会","层面","内","。","i2c","二合一","为了","嵌入式","sd","处理","调试","一款","csi","常听到","上去","—","第一眼","链","方面","高等院校","通信","外接","wiki","无线网","二合","接近","第一","？","都","与","工具","外观","bpu","先","已有","没错","形态","这些","高等","助于","typec","开发","支持","系统","套件","线","接口","起来","自己","推向","有线网","地平线","出现","网络","产品","不再","整体","这是","算力","呢","x3","口","大于","板载","一位","完全","那","推向市场","方向","信息","在","听到","板卡","硬件","扩展","实力","连接","一个","上","计算","npu","想到","h265","时候","接设备","是","远程","快速","核","一致","频率","至关重要","或者","将","旭日","这","提供","编解码","这个","对象","路由","目前","包含","级","官方","来源","多","嵌入","版本","已经","有助","核心","面对","2","太","可以","传感器","以及","市面上","面向","搭载","、","类似","40","至关","存储","开发者","它","四核","生态","伯努利","无线网络","一眼","准备","机器人","市场","树莓","，","直接","性能","只要","学习","视觉","啦","一应","价格","引擎","多媒体","登录","问题","识别","个","串口","图像","usb3.0","spi","学生","尽快","也","解决","网线","受","人工智能","端侧","4gb","方案","能力","需求","未来","于","满足","某个","的","自行","客户","为","和","常用","有","帮助","解决方案"," ","3","设备","适应","播放","上网","等等","推理","无线","地平","落地","最大","中","内存","cpu","ubuntu20.04","如果","例程","统统","路由器","更","大量","推荐","1","arm","高昂","模块","传感","让","总体","每","架构","4","人工","尽量","还","我们","线网","超频","没","有助于","身边","差别","个人","这里","市面","视频","5v3a","原生","后续","入门","有线","了","面上","看上去","接口定义","蓝牙","大家","是否","限制","2.0","开始","电脑","芯片","硬件资源","习惯","到","独有","ai","h264","显示器","2gb","用","不同","看上","大","开发板","界面","1.2","看到","智能","产业","要","效果","感器","资源","获取","张表中","媒体","来讲","显示","相机","a53","调试信息"],"title":"旭日X3派","title_tokens":["旭日","x3","派"]},{"location":"hhp/2.1_%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6%E4%BB%8B%E7%BB%8D/#x3m","text":"在旭日X3派上，最为核心的当然就是这颗AI芯片了，这是关于芯片的具体信息，供大家参考。 值得一提的是，随着芯片的技术迭代，2023年，地平线将推出X5芯片，比较大的变化是CPU升级到了8核A55，主频提升到1.8GHz，BPU的算力也将达到8Tops，还加入了GPU，以及更多可扩展的接口。 在使用旭日X3派的过程中，大家也可以期待旭日X5派了。","text_tokens":["是","主频","芯片","值得","推出","接口","x5","可以","年","可","，","的","技术","到","地平线","核","信息","大","使用","在","将","更","旭日","具体","以及","迭代","当然","加入"," ","这是","ai","a55","2023","算力","派","8tops","变化","bpu","达到","扩展","了","gpu","x3","也","供","这颗","ghz","随着","参考","多","上","大家","8","最为","就是","提升","地平","期待","。","核心","比较","中","关于","cpu","1.8","过程","还","值得一提的是","升级"],"title":"旭日X3M芯片","title_tokens":["x3m","旭日","芯片"]},{"location":"hhp/2.1_%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6%E4%BB%8B%E7%BB%8D/#x3_2","text":"好啦，还是回到旭日X3派的开发接口上来，我们再做一个整理，这些就是我们使用开发板进行智能机器人开发过程中，最为常用的接口啦。 大家目前在树莓派或者其他开发板上使用的绝大部分模块，基本都可以在旭日X3派上复用，同时还有更多智能化的玩法等着大家。 关于40Pin扩展接口的序号排布，大家可以看这里，引脚的序号是从靠近HDMI板卡内测的开始算起，是引脚1，然后依次蛇形计数，分别是1、2、3、4、5，一直到这里是39和40。 上图是40PIN扩展接口的详细定义，有3.3V和5V的电源信号，有I2C、I2S、SPI、UART等通信接口，还有很多可动态配置的GPIO信号，基本可以满足各种各样的机器人开发啦。 好啦，关于旭日X3派这块开发板我们已经了解清楚了，具体该如何使用呢，我们后续操作起来。","text_tokens":["各样","2","基本","整理","可以","hdmi","可","上图","绝大","绝大部分","更","蛇形","其他","智能化","动态","再","详细","好","一直","都","1","3.3","定义","派","39","、","模块","40","这些","大部分","40pin","电源","机器","就是","gpio","4","关于","过程","开发","接口","还有","起来","机器人","我们","树莓","，","使用","然后","具体","i2s","引脚","这里","通信接口","后续","大部","复用","信号","这块","v","了","呢","啦","x3","该","操作","算","等","大家","最为","了解","开始","部分","是从","到","玩法","分别","进行","5v","在","板卡","同时","计数","很多","各种各样","扩展","spi","配置","回到","5","排布","还是","一个","上","看","uart","。","上来","i2c","清楚","是","依次","满足","的","着","开发板","或者","常用","旭日","和","有"," ","3","如何","智能","目前","靠近","序号","内测","多","各种","已经","起","通信","中","做"],"title":"旭日X3派接口","title_tokens":["旭日","x3","派","接口"]},{"location":"hhp/2.2_HHP%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/","text":"地平线机器人开发平台(HHP)系统安装 我们在旭日X3派上安装系统镜像，并进一步完成HHP的安装，大家如果手上有旭日X3派开发板的话，建议跟随一起操作。 先来了解一下HHP安装的整体流程： 第一步，要完成硬件的准备，我们需要找到一块旭日X3派的开发板，并且准备好电源线、SD卡、读卡器、串口模块等必要的配件，当然还需要有一台操作的电脑啦。 硬件都准备好之后，就可以进入第二步，给旭日X3派下载并安装Ubuntu系统镜像，这是HHP软件运行必要的底层环境。 第三步，就可以开始安装HHP啦。 安装完成后，我们还需要进一步完成一些配置工作，可以也让旭日X3派板卡上的各项功能都运行起来，保证HHP的顺利运行。 最后一步，就是体验HHP出厂自带的一些例程啦，确定一切安装顺利，为后续机器人开发最好准备。 接下来，我们就按照这个流程，开始操作。 硬件准备 先来完成硬件准备： 找到一块旭日X3派的板卡，准备好一套5V3A的电源和TypeC电源线，稍后会连接到这里的电源接口，给板卡供电。 然后准备好一张8GB以上的SD卡和读卡器，下一步我们会在上边烧写系统镜像。 接下来使用一个串口模块，连接旭日X3派和笔记本电脑，便于下一步看到系统镜像的启动信息。 如果大家有网线和HDMI显示器的话，也可以先准备好，在之后的操作中用的上，如果没有也没关系，不影响HHP的基本使用。 硬件准备齐全之后，就可以进入第二步了。 安装Ubuntu系统 我们来给旭日X3派安装Ubuntu系统，关于系统镜像和烧写工具，都可以在 地平线AI社区 中找到。 下载SD卡镜像 首先登录地平线AI社区，点击”产品中心——资源中心“， 进入页面后下拉至”X3派资料包“专区，其中有两个镜像，点击下载其中的”旭日X3派系统镜像（服务版）“，会有一个压缩包，把它保存到当前电脑桌面。 此外，我们稍后将镜像烧写到SD卡里，需要用到烧写小工具，如果大家电脑上没有合适的工具，可以下拉到”工具“专区，点击下载”烧录 工具rufus\"。 下载完后我们来看一下两个压缩文件中的内容： 其中一个是烧写X3派镜像文件的工具，压缩包中有两个文件，一个是system_sdcard.img文件，是我们稍后会用于烧写SD卡的镜像文件；另一个是disk_nand.img文件，用于烧写旭日X3派中的flash文件，大多数情况下都用不到； 另一个压缩包里是我们稍后用于烧写镜像的rufus工具。 我们把两个压缩包都解压出来，然后把SD卡放进读卡器、插到电脑端 接下来就可以开始烧写SD卡镜像。 烧写SD卡镜像 运行解压出来的烧写工具rufus。启动后需要确认几个参数： 第一个是确定烧写到哪个磁盘上。工具软件会默认搜索当前读取到的SD卡，下图所示磁盘名称，就是演示时插好的16GB的SD卡。 下一步我们点击“选择”，找到需要烧写的镜像文件。演示中已经把需要的system_sdcrd.img文件放在了桌面上，选中它点击“打开”； 下面的内容就可以用默认的配置，点击“开始”会弹出警告告诉我们将把磁盘里的所有文件都清除掉，这没有问题，我们点击“选择“，就开始烧写SD卡镜像了。 进度条显示“准备就绪”后，点击“关闭”，此时你的SD卡镜像就已经烧写完成了，我们把SD卡的读卡器拔出来。 连接串口 接下来把SD卡插到旭日X3派上。 把串口模块连接到电脑的USB上。 连接好串口模块后，为了确保串口已经跟电脑连接成功、并且安装好了驱动，我们可以右键“我的电脑”图标、选择“管理”，在打开的”计算机管理“界面中找到”设备管理器——端口“，检查一下你的USB串口是否已经显示出了对应的设备。演示中的端口号为COM6,说明串口已经成功驱动了。 如果没有看到自己的设备号、或者设备号前有一个叹号或者问号标记，说明你的驱动没有安装好，可以搜索网络上的技术博客，来完成串口模块的驱动安装。 关闭“计算机管理”窗口，接下来就要通过串口与旭日X3派进行连接了。这里我们需要用到一个串口小工具，大家可以使用自己常用的工具。 演示中使用的串口工具是MobaXterm,十分推荐大家使用这个工具，里面集成了开发过程中需要使用的各种小工具，我们后续的串口通讯、SSH网络通讯，都会使用这些工具完成。 打开MobaXterm,点击左上角的\"Session\"； 找到里面的“Serial\"串口选项，点击打开；串口号选择本机连接到旭日X3派的相应端口，演示中为COM6; 波特率选择921600。选项好后点击“OK”。 现在串口已经连接成功了，但当前旭日X3派的板子还没有上电，所以没有任何信息弹出。 我们把电源线与旭日X3派连接好。 可以看到弹出了日志提醒：“当前系统正在启动”。等待系统加载完成。 现在可以看到系统已经加载成功了。 串口登录系统 接下来我们需要登录系统。我们有两个账号可以用来登录： 账号1：用户名为root，密码也为root； 账号2：用户名为storise，密码也为storise； 这里演示使用root用户来登录。输入用户名、密码，回车，需要等待大约1分钟，因为第一次登录需要展开一些系统必要的安装软件，安装好后系统会自动重启。 系统自动重启后，再次使用root用户登录。现在你的UBUNTU系统就已经安装好了。 我们可以使用LINUX系统常用的一些命令行进行查看和设置，比如ls查看当前命令，pwd查看当前路径，还可以使用mkdir命令创建文件夹，比如这里,一个test文件夹就创建成功了。 到这里为止，旭日X3派上的Ubuntu系统就安装成功啦，我们继续下一步。 安装HHP/TogetherROS 接下来安装地平线机器人开发平台HHP，TogetherROS系统包含其中。 为了达到更好的通信效率，我们后续使用有线网络连接旭日X3派，这里大家可以拿出一根网线，直接连接电脑和旭日X3派的网口。 旭日X3派中出厂已经配置好了静态IP地址，是192.168.1.10，我们将使用的电脑也配置到同一网段即可。 配置有线网络 接下来请大家拿一根网线，连接旭日X3派和电脑。 然后，在电脑端打开控制面板，找到“查看网络状态和任务”。 找到已经连接成功的以太网，点击它； 会弹出一个窗口，我们点击“属性”。 再次弹出窗口，我们双击选择“Internet协议版本4”。 然后会弹出一个配置IP地址的窗口，我们勾选”使用下面的IP地址“。 按照如下信息填入： IP地址：192.168.1.100 子网掩码：255.255.255.0 默认网关：192.168.1.1 我们使用的旭日X3派的板子IP为192.168.1.10，所以IP后三位除了.10和网关.1以外，大家可以选用1-255之间的任意数字，这里使用.100； 填写完在所有窗口点击“确定”，最后关闭窗口。现在网络的配置就完成了，此时电脑端的静态IP就是192.168.1.100,我们通过这个IP与旭日X3派产生连接。 SSH远程登录 我们再次打开MobaXterm软件,点击左上角的\"Session\"，找到里面的\"SSH\",输入 旭日X3派板子的IP192.168.1.10，点击”OK“。 弹出登录窗口，我们用root账户登录：用户名为root，密码为root。这里会弹窗询问是否保存登录密码，如果需要保存就点“YES”，不需要保存就点“NO”。 现在我们就成功通过网络SSH协议登录到了旭日X3派板子上，和之前我们用串口登录的效果几乎是一样的，但现在我们是用网络通讯，所以现在通讯的效率和传输的速度会更高。 配置完成网络通讯后，我们来正式安装HHP。 安装HHP 我们在登录成功的SSH终端中，直接使用如下命令即可安装HHP： $ sudo apt install hhp 等待安装完成： $ root@ubuntu:~# sudo apt install hhp Reading package lists... Done Building dependency tree Reading state information... Done The following NEW packages will be installed: hhp 0 upgraded, 1 newly installed, 0 to remove and 52 not upgraded. Need to get 384 MB of archives. After this operation, 512 MB of additional disk space will be used. Get:1 http://42.62.85.28/ubuntu-ports focal/main arm64 hhp arm64 1 .0.1 [ 384 MB ] Fetched 384 MB in 6min 43s ( 954 kB/s ) Selecting previously unselected package hhp. ( Reading database ... 110406 files and directories currently installed. ) Preparing to unpack .../archives/hhp_1.0.1_arm64.deb ... Unpacking hhp ( 1 .0.1 ) ... Setting up hhp ( 1 .0.1 ) ... Generating locales ( this might take a while ) ... en_US.ISO-8859-1... done en_US.UTF-8... done Generation complete. 安装完成后，查看/opt目录下的文件，可以看到已经安装： $ root@ubuntu:/userdata# ls /opt/ tros 如果觉得终端里看不方便，也可以使用MobaXterm软件的可视化浏览器来查看。 大家可以点击/opt/tros文件夹，看看其中的文件结构。 /include文件夹里，是我们后续会用到的关于系统的头文件的调用路径； /lib文件夹里面是库文件； /share文件夹里是安装好的功能包的路径； /src文件夹里是后续会用到的代码； /tools文件夹里是一些小工具。 除此之外，还有很多.bat、.sh脚本文件，它们是用来设置环境变量的。这是因为，你的LINUX系统不知道你安装包的路径在哪，所以需要通过环境变量的脚本来告诉系统，如何找到对应的TogetherROS的功能包、和功能包里的命令工具。 环境变量在我们后续操作里会频繁地使用到，我们会使用到一个”source\"命令来配置环境变量，例如： $ source /opt/tros/setup.bash 运行上面这行命令，就会把当前环境变量设置到系统里去；下次再运行ROS2、TogetherROS指令时，就能找到功能包的路径了。 到这里，HHP软件系统安装完成，下一节我们将对开发板和HHP进行配置。","text_tokens":["进一步","after","例如","ip地址","功能","hdmi","填写","指令","打开","平台","following","子网","一下","好","计算机","电脑桌","派","并且","跟","端口","就","100","对应","building","写","便于","频繁","高","operation","电源","255","机器","就是","十分","名为","算机","最后","方便","10","1.10","除此","mb","还有","85.28","压缩文件","选中","数字","使用","选择","8gb","第三","拔出","任务",".","ok","拿","255.255","准备就绪","检查","浏览","并","大多","usb",";","上角","提醒","找到","搜索","看看","环境变","地址","命令","卡","警告","通过","#","session","yes","首先","进行","波特率","等待","一根","读卡","就要","网络通讯","读卡器","当然","之后","需要","下","没有","供电","togetherros","之间","tree","很多","mobaxterm","-","information","下拉","110406","速度","看","会","去","询问","叹","波特","正式","8","。","出来","512","42.62","三步","网络连接","installed","日志","additional",")","一次","产生","opt","为了","to","下拉至","清除","会弹","bash","sd","影响","be","nand","可视化","tools","自动","如何","能","以太","确定","—","效率","代码","之前","以太网","头文件","linux","建议","我","确认","focal","0","再次","各项","通信","机","include","三位","继续","传输","1.0","基本","展开","此外","之外","of","一套","环境","用到","not","再","第一","us","reading","工具","都","与","source","一块","的话","先","除此之外","upgraded","拿出","这些","1.100","1.1","是因为","954","桌面","博客","第三步","检查一下","就点","好后","关于","previously","typec","开发","系统","任意","接口","查看","起来","自己","lists","按照","说明","拉到","端的","回车","地平线","下来","网络","tros","几乎","工作","计算机管理","成功","产品","setting","中为","整体","这是","网段","a","账户","填入","除了","unpacking","x3","它们","就绪","deb","generating","配件","掩码","了解","告诉","serial","调用","确保","unpack","pwd","默认","最好","用于","preparing","版","以外","ssh","921600","没关系","userdata","卡里","utf","no","文件","信息","在","进度条","rufus","电源接口","面板","ls","...","板卡","硬件","弹出","done","internet","配置","此时","标记","哪个","大约","接下","没关","_","对","the","连接","下面","用来","一个","上","unselected","计算","generation","社区","是","结构","远程","资料","take","演示","端","（","笔记","将","或者","旭日","这","下拉到","这个","知道","启动","一样","包含","“","同一","一切","flash","一台","跟随","已经","版本","完在","以上","浏览器","0.1","掉","名称","本","sudo","/","手上","up","2","可以","其中","驱动","账号","directories","locales","@","进入","]","终端",":","目录","src","\"","setup","后","体验","、","中心","apt","管理","选项","状态","它","sdcard","解压","arm64","ros2","理器","准备","页面","控制面板","机器人","压缩包","完成","remove","ip192.168","，","need","newly","然后","直接","多数","镜像","读取","里","(","384","啦","操作","电源线","左上角","比如","and","complete","等","窗口","database","图标","如下","com6","用户","in","所以","dependency","登录","板子","test","问题","大多数","双击","255.0","所有","运行","安装","第一个","packages","img","但","设置","52","串口","命令行","网关","也","8859","弹","might","网线","当前","密码","16gb","勾选","包","镜像文件","install","disk","烧录","完后","自带","文件夹","必要","点击","：","串","的","输入","不到","你","为","和","常用","有"," ","任何","currently","设备","磁盘","中用","包里","selecting","放在","静态","$","插","各种","state","”","集成","前","this","重启","地平","ip","正在","一步","中","fetched","放进","http","把","如果","例程","en","上电","技术","更","推荐","1","件夹","hhp","所示","出厂","达到","端口号","模块","小","new","笔记本电脑","package","地","让","烧","属性","控制","内容","4","第一步","软件系统","口号","过程","关系","还","上边","6min","子网掩码","软件","s","我们","files","下图","main","进度","情况","户名","路径","5v3a","这里","ports","上面","后续","更好","一些","请","有线","archives","了","工具软件","下次","面上","电脑桌面","一节","桌面上","因为","root","大家","专区","是否","space","顺利","号","创建","出","环境变量","开始","另","协议","电脑","选用","两个","流程","制面","二步","到","接下来","通讯",",","ai","保证","管理器","可视","第二","现在","烧写","中有","sdcrd","弹窗","左上","while","给","used","笔记本","来看","脚本","行","一张","显示器","加载","压缩","lib","ubuntu","192.168","第一次","一起","相应","mkdir","kb","即可","关闭","用","来","43s","觉得","bat","开发板","合适","界面","will","system","sh","share","；","稍后","服务","分钟","看到","）","storise","不","安装包","效果","要","用户名","资源","变量","库","时","里面","拔出来","下载","保存","为止","~","几个","底层","iso","参数","显示","齐全","右键","第二步","网口","哪","里会","问号","get","["],"title":"HHP系统安装","title_tokens":["安装","hhp","系统"]},{"location":"hhp/2.2_HHP%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/#hhp","text":"我们在旭日X3派上安装系统镜像，并进一步完成HHP的安装，大家如果手上有旭日X3派开发板的话，建议跟随一起操作。 先来了解一下HHP安装的整体流程： 第一步，要完成硬件的准备，我们需要找到一块旭日X3派的开发板，并且准备好电源线、SD卡、读卡器、串口模块等必要的配件，当然还需要有一台操作的电脑啦。 硬件都准备好之后，就可以进入第二步，给旭日X3派下载并安装Ubuntu系统镜像，这是HHP软件运行必要的底层环境。 第三步，就可以开始安装HHP啦。 安装完成后，我们还需要进一步完成一些配置工作，可以也让旭日X3派板卡上的各项功能都运行起来，保证HHP的顺利运行。 最后一步，就是体验HHP出厂自带的一些例程啦，确定一切安装顺利，为后续机器人开发最好准备。 接下来，我们就按照这个流程，开始操作。","text_tokens":["如果","手上","例程","进一步","可以","功能","环境","进入","第一","一下","好","都","派","hhp","并且","一块","后","的话","体验","先","、","出厂","就","模块","让","第三步","电源","机器","就是","第一步","最后","开发","系统","还","准备","软件","起来","机器人","我们","按照","完成","，","下来","工作","镜像","整体","这是","第三","后续","一些","x3","啦","操作","电源线","等","大家","配件","并","了解","顺利","最好","找到","开始","电脑","卡","流程","二步","接下来","在","读卡","当然","之后","读卡器","安装","需要","运行","板卡","硬件","保证","第二","串口","配置","接下","也","给","上","。","ubuntu","一起","三步","自带","必要","：","sd","的","来","开发板","为","旭日","有"," ","这个","确定","要","下载","一切","一台","建议","底层","跟随","各项","第二步","一步"],"title":"地平线机器人开发平台(HHP)系统安装","title_tokens":["机器","地平","机器人","平台","系统","安装","hhp","地平线","开发","(",")"]},{"location":"hhp/2.2_HHP%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/#_1","text":"先来完成硬件准备： 找到一块旭日X3派的板卡，准备好一套5V3A的电源和TypeC电源线，稍后会连接到这里的电源接口，给板卡供电。 然后准备好一张8GB以上的SD卡和读卡器，下一步我们会在上边烧写系统镜像。 接下来使用一个串口模块，连接旭日X3派和笔记本电脑，便于下一步看到系统镜像的启动信息。 如果大家有网线和HDMI显示器的话，也可以先准备好，在之后的操作中用的上，如果没有也没关系，不影响HHP的基本使用。 硬件准备齐全之后，就可以进入第二步了。","text_tokens":["如果","基本","可以","hdmi","一套","进入","好","派","hhp","一块","的话","先","就","模块","笔记本电脑","便于","电源","typec","系统","关系","上边","接口","准备","我们","完成","，","下来","使用","然后","8gb","镜像","5v3a","这里","了","x3","操作","电源线","大家","找到","电脑","没关系","卡","二步","到","接下来","信息","读卡","在","之后","电源接口","读卡器","下","没有","板卡","硬件","供电","第二","串口","烧写","接下","也","没关","连接","给","笔记本","一个","网线","上","会","一张","显示器","。","：","sd","影响","的","来","笔记","和","旭日","有"," ","稍后","看到","不","启动","中用","以上","显示","齐全","第二步","一步"],"title":"硬件准备","title_tokens":["硬件","准备"]},{"location":"hhp/2.2_HHP%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/#ubuntu","text":"我们来给旭日X3派安装Ubuntu系统，关于系统镜像和烧写工具，都可以在 地平线AI社区 中找到。","text_tokens":["我们","可以","，","来","地平线","在","和","旭日","安装"," ","工具","镜像","都","ai","派","x3","写","给","烧","地平","。","ubuntu","中","关于","系统","找到","社区"],"title":"安装Ubuntu系统","title_tokens":["ubuntu","安装","系统"]},{"location":"hhp/2.2_HHP%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/#sd","text":"首先登录地平线AI社区，点击”产品中心——资源中心“， 进入页面后下拉至”X3派资料包“专区，其中有两个镜像，点击下载其中的”旭日X3派系统镜像（服务版）“，会有一个压缩包，把它保存到当前电脑桌面。 此外，我们稍后将镜像烧写到SD卡里，需要用到烧写小工具，如果大家电脑上没有合适的工具，可以下拉到”工具“专区，点击下载”烧录 工具rufus\"。 下载完后我们来看一下两个压缩文件中的内容： 其中一个是烧写X3派镜像文件的工具，压缩包中有两个文件，一个是system_sdcard.img文件，是我们稍后会用于烧写SD卡的镜像文件；另一个是disk_nand.img文件，用于烧写旭日X3派中的flash文件，大多数情况下都用不到； 另一个压缩包里是我们稍后用于烧写镜像的rufus工具。 我们把两个压缩包都解压出来，然后把SD卡放进读卡器、插到电脑端 接下来就可以开始烧写SD卡镜像。","text_tokens":["如果","其中","可以","此外","用到","进入","一下","工具","都","\"","电脑桌","派","后","、","就","中心","小","写","桌面","它","烧","sdcard","内容","解压","系统","页面","压缩包","我们","拉到","，","压缩文件","地平线","下来","然后","多数","产品","情况","镜像","里",".","x3","电脑桌面","大家","专区","大多","用于","开始","另","电脑","版","登录","两个","卡","卡里","大多数","到","接下来","文件","首先","读卡","rufus","读卡器","没有","需要","下","ai","img","烧写","中有","接下","_","下拉","来看","一个","上","会","当前","包","压缩","。","出来","镜像文件","disk","烧录","完后","社区","是","下拉至","点击","：","资料","sd","用","的","端","（","nand","合适","不到","将","system","旭日","有","下拉到","；"," ","稍后","服务","）","—","资源","“","下载","保存","flash","插","”","地平","中","放进","把"],"title":"下载SD卡镜像","title_tokens":["下载","卡","sd","镜像"]},{"location":"hhp/2.2_HHP%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/#sd_1","text":"运行解压出来的烧写工具rufus。启动后需要确认几个参数： 第一个是确定烧写到哪个磁盘上。工具软件会默认搜索当前读取到的SD卡，下图所示磁盘名称，就是演示时插好的16GB的SD卡。 下一步我们点击“选择”，找到需要烧写的镜像文件。演示中已经把需要的system_sdcrd.img文件放在了桌面上，选中它点击“打开”； 下面的内容就可以用默认的配置，点击“开始”会弹出警告告诉我们将把磁盘里的所有文件都清除掉，这没有问题，我们点击“选择“，就开始烧写SD卡镜像了。 进度条显示“准备就绪”后，点击“关闭”，此时你的SD卡镜像就已经烧写完成了，我们把SD卡的读卡器拔出来。","text_tokens":["可以","打开","第一","好","工具","都","所示","后","就","写","桌面","它","烧","就是","内容","解压","准备","软件","我们","完成","，","选中","下图","选择","进度","读取","镜像","拔出","里",".","了","工具软件","面上","就绪","桌面上","准备就绪","告诉","默认","找到","出","搜索","开始","问题","卡","到","警告","文件","读卡","进度条","rufus","运行","所有","没有","需要","第一个","下","读卡器","img","烧写","sdcrd","配置","此时","哪个","_","下面","一个","上","会","当前","16gb","。","出来","镜像文件","是","清除","点击","会弹","：","sd","关闭","演示","的","用","你","将","system","这","；"," ","磁盘","启动","确定","放在","时","“","拔出来","插","几个","”","确认","参数","已经","显示","掉","一步","中","名称","把"],"title":"烧写SD卡镜像","title_tokens":["卡","烧写","sd","镜像"]},{"location":"hhp/2.2_HHP%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/#_2","text":"接下来把SD卡插到旭日X3派上。 把串口模块连接到电脑的USB上。 连接好串口模块后，为了确保串口已经跟电脑连接成功、并且安装好了驱动，我们可以右键“我的电脑”图标、选择“管理”，在打开的”计算机管理“界面中找到”设备管理器——端口“，检查一下你的USB串口是否已经显示出了对应的设备。演示中的端口号为COM6,说明串口已经成功驱动了。 如果没有看到自己的设备号、或者设备号前有一个叹号或者问号标记，说明你的驱动没有安装好，可以搜索网络上的技术博客，来完成串口模块的驱动安装。 关闭“计算机管理”窗口，接下来就要通过串口与旭日X3派进行连接了。这里我们需要用到一个串口小工具，大家可以使用自己常用的工具。 演示中使用的串口工具是MobaXterm,十分推荐大家使用这个工具，里面集成了开发过程中需要使用的各种小工具，我们后续的串口通讯、SSH网络通讯，都会使用这些工具完成。 打开MobaXterm,点击左上角的\"Session\"； 找到里面的“Serial\"串口选项，点击打开；串口号选择本机连接到旭日X3派的相应端口，演示中为COM6; 波特率选择921600。选项好后点击“OK”。 现在串口已经连接成功了，但当前旭日X3派的板子还没有上电，所以没有任何信息弹出。 我们把电源线与旭日X3派连接好。 可以看到弹出了日志提醒：“当前系统正在启动”。等待系统加载完成。 现在可以看到系统已经加载成功了。","text_tokens":["如果","可以","驱动","上电","打开","技术","用到","推荐","一下","好","计算机","与","工具","都","\"","派","并且","后","跟","、","端口","端口号","模块","小","对应","这些","管理","选项","博客","检查一下","电源","十分","算机","好后","口号","理器","过程","开发","还","系统","自己","我们","说明","完成","，","下来","网络","使用","选择","计算机管理","成功","中为","这里","后续","了","ok","x3","电源线","左上角","窗口","大家","是否","检查","serial","usb","确保","图标",";","号","上角","com6","提醒","找到","出","所以","搜索","电脑","板子","ssh","921600","卡","到","接下来","通过","session","进行","波特率","信息","等待","在","就要","网络通讯","通讯","没有","安装",",","需要","弹出","管理器","但","串口","现在","mobaxterm","标记","接下","左上","连接","弹","一个","上","会","当前","叹","波特","加载","计算","。","相应","日志","为了","是","点击","：","sd","关闭","演示","的","串","来","界面","你","为","或者","常用","旭日","有","；"," ","任何","看到","这个","设备","启动","—","里面","“","插","各种","我","已经","”","集成","前","显示","右键","正在","中","机","本","问号","把"],"title":"连接串口","title_tokens":["串口","连接"]},{"location":"hhp/2.2_HHP%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/#_3","text":"接下来我们需要登录系统。我们有两个账号可以用来登录： 账号1：用户名为root，密码也为root； 账号2：用户名为storise，密码也为storise； 这里演示使用root用户来登录。输入用户名、密码，回车，需要等待大约1分钟，因为第一次登录需要展开一些系统必要的安装软件，安装好后系统会自动重启。 系统自动重启后，再次使用root用户登录。现在你的UBUNTU系统就已经安装好了。 我们可以使用LINUX系统常用的一些命令行进行查看和设置，比如ls查看当前命令，pwd查看当前路径，还可以使用mkdir命令创建文件夹，比如这里,一个test文件夹就创建成功了。 到这里为止，旭日X3派上的Ubuntu系统就安装成功啦，我们继续下一步。","text_tokens":["2","可以","展开","账号","第一","好","1","件夹","派","后","、","就","名为","好后","系统","还","查看","软件","我们","，","回车","下来","使用","成功","户名","路径","这里","一些","了","x3","啦","比如","因为","root","pwd","用户","创建","登录","test","两个","命令","到","接下来","文件","进行","等待","需要","安装","ls",",","下","设置","命令行","现在","大约","接下","也","用来","一个","上","会","密码","当前","。","ubuntu","第一次","mkdir","文件夹","必要","一次","：","演示","输入","的","来","为","你","常用","和","旭日","有","；"," ","分钟","自动","storise","用户名","为止","linux","已经","再次","重启","一步","继续"],"title":"串口登录系统","title_tokens":["串口","登录","系统"]},{"location":"hhp/2.2_HHP%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/#hhptogetherros","text":"接下来安装地平线机器人开发平台HHP，TogetherROS系统包含其中。 为了达到更好的通信效率，我们后续使用有线网络连接旭日X3派，这里大家可以拿出一根网线，直接连接电脑和旭日X3派的网口。 旭日X3派中出厂已经配置好了静态IP地址，是192.168.1.10，我们将使用的电脑也配置到同一网段即可。","text_tokens":["为了","电脑","是","机器人","我们","地址","即可","ip地址","其中","可以","，","接下来","的","到","下来","地平线","一根","使用","网络","直接","将","和","旭日","平台","安装"," ","好","这里","hhp","togetherros","更好","后续","有线","派","达到","效率","出厂","了",".","配置","x3","包含","接下","也","拿出","同一","连接","静态","网线","大家","已经","网段","机器","地平","系统","。","192.168","通信","中","网口","1.10","网络连接","开发"],"title":"安装HHP/TogetherROS","title_tokens":["安装","/","hhp","togetherros"]},{"location":"hhp/2.2_HHP%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/#_4","text":"接下来请大家拿一根网线，连接旭日X3派和电脑。 然后，在电脑端打开控制面板，找到“查看网络状态和任务”。 找到已经连接成功的以太网，点击它； 会弹出一个窗口，我们点击“属性”。 再次弹出窗口，我们双击选择“Internet协议版本4”。 然后会弹出一个配置IP地址的窗口，我们勾选”使用下面的IP地址“。 按照如下信息填入： IP地址：192.168.1.100 子网掩码：255.255.255.0 默认网关：192.168.1.1 我们使用的旭日X3派的板子IP为192.168.1.10，所以IP后三位除了.10和网关.1以外，大家可以选用1-255之间的任意数字，这里使用.100； 填写完在所有窗口点击“确定”，最后关闭窗口。现在网络的配置就完成了，此时电脑端的静态IP就是192.168.1.100,我们通过这个IP与旭日X3派产生连接。","text_tokens":["ip地址","可以","填写","打开","子网","1","与","派","后","就","100","1.100","1.1","状态","它","255","就是","属性","控制","4","最后","10","1.10","任意","查看","子网掩码","控制面板","我们","按照","完成","，","端的","下来","数字","网络","然后","使用","选择","成功","这里","任务","请",".","填入","了","除了","x3","拿","255.255","窗口","大家","掩码","如下","默认","找到","出","所以","协议","电脑","板子","以外","地址","选用","制面","接下来","通过","双击","一根","信息","255.0","在","所有","面板",",","之间","internet","现在","-","配置","此时","接下","网关","连接","弹","下面","一个","网线","勾选","。","192.168","产生","点击","会弹","：","关闭","的","端","为","和","旭日","；"," ","这个","以太","确定","“","以太网","静态","版本","”","已经","完在","再次","ip","三位"],"title":"配置有线网络","title_tokens":["有线","网络","配置"]},{"location":"hhp/2.2_HHP%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/#ssh","text":"我们再次打开MobaXterm软件,点击左上角的\"Session\"，找到里面的\"SSH\",输入 旭日X3派板子的IP192.168.1.10，点击”OK“。 弹出登录窗口，我们用root账户登录：用户名为root，密码为root。这里会弹窗询问是否保存登录密码，如果需要保存就点“YES”，不需要保存就点“NO”。 现在我们就成功通过网络SSH协议登录到了旭日X3派板子上，和之前我们用串口登录的效果几乎是一样的，但现在我们是用网络通讯，所以现在通讯的效率和传输的速度会更高。 配置完成网络通讯后，我们来正式安装HHP。","text_tokens":["如果","打开","更","\"","派","hhp","后","就","高","名为","就点","1.10","软件","我们","完成","ip192.168","，","网络","几乎","成功","这里",".","账户","了","ok","x3","左上角","root","窗口","是否","上角","用户","找到","所以","出","协议","登录","板子","ssh","到","no","通过","session","yes","网络通讯","通讯",",","需要","安装","但","串口","现在","mobaxterm","配置","弹窗","左上","弹","速度","上","会","密码","询问","正式","。","是","点击","：","用","的","输入","来","为","和","旭日"," ","不","效率","效果","一样","里面","“","保存","之前","”","再次","传输"],"title":"SSH远程登录","title_tokens":["ssh","登录","远程"]},{"location":"hhp/2.2_HHP%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/#hhp_1","text":"我们在登录成功的SSH终端中，直接使用如下命令即可安装HHP： $ sudo apt install hhp 等待安装完成： $ root@ubuntu:~# sudo apt install hhp Reading package lists... Done Building dependency tree Reading state information... Done The following NEW packages will be installed: hhp 0 upgraded, 1 newly installed, 0 to remove and 52 not upgraded. Need to get 384 MB of archives. After this operation, 512 MB of additional disk space will be used. Get:1 http://42.62.85.28/ubuntu-ports focal/main arm64 hhp arm64 1 .0.1 [ 384 MB ] Fetched 384 MB in 6min 43s ( 954 kB/s ) Selecting previously unselected package hhp. ( Reading database ... 110406 files and directories currently installed. ) Preparing to unpack .../archives/hhp_1.0.1_arm64.deb ... Unpacking hhp ( 1 .0.1 ) ... Setting up hhp ( 1 .0.1 ) ... Generating locales ( this might take a while ) ... en_US.ISO-8859-1... done en_US.UTF-8... done Generation complete. 安装完成后，查看/opt目录下的文件，可以看到已经安装： $ root@ubuntu:/userdata# ls /opt/ tros 如果觉得终端里看不方便，也可以使用MobaXterm软件的可视化浏览器来查看。 大家可以点击/opt/tros文件夹，看看其中的文件结构。 /include文件夹里，是我们后续会用到的关于系统的头文件的调用路径； /lib文件夹里面是库文件； /share文件夹里是安装好的功能包的路径； /src文件夹里是后续会用到的代码； /tools文件夹里是一些小工具。 除此之外，还有很多.bat、.sh脚本文件，它们是用来设置环境变量的。这是因为，你的LINUX系统不知道你安装包的路径在哪，所以需要通过环境变量的脚本来告诉系统，如何找到对应的TogetherROS的功能包、和功能包里的命令工具。 环境变量在我们后续操作里会频繁地使用到，我们会使用到一个”source\"命令来配置环境变量，例如： $ source /opt/tros/setup.bash 运行上面这行命令，就会把当前环境变量设置到系统里去；下次再运行ROS2、TogetherROS指令时，就能找到功能包的路径了。 到这里，HHP软件系统安装完成，下一节我们将对开发板和HHP进行配置。","text_tokens":["如果","1.0","up","after","en","例如","可以","其中","之外","功能","指令","of","directories","locales","环境","@","用到","not","终端","]","following","us",":","reading","目录","好","1","件夹","src","工具","\"","setup","hhp","source","后","、","就","除此之外","upgraded","小","apt","对应","building","new","package","954","是因为","频繁","地","operation","方便","软件系统","arm64","除此","previously","关于","ros2","6min","系统","开发","mb","还有","查看","软件","lists","s","我们","完成","85.28","files","remove","，","need","newly","使用","tros","直接","成功","setting","main","路径","上面","ports","这里","里","archives","后续","a","一些",".","(","384","了","unpacking","下次","它们","操作","一节","complete","and","因为","deb","generating","root","大家","space","database","浏览","调用","告诉","如下","unpack","in","找到","环境变量","preparing","dependency","所以","看看","登录","环境变","ssh","命令","再","userdata","utf","到","通过","#","文件","进行","等待","在","运行","安装",",","...","packages","下","ls","需要","可视","tree","设置","很多","52","done","togetherros","-","mobaxterm","配置","对","information","while","_","8859","the","也","used","110406","might","用来","一个","看","脚本","会","行","当前","去","8","unselected","包","。","ubuntu","512","42.62","lib","install","disk","文件夹","generation","installed","additional",")","opt","是","to","结构","点击","kb","即可","：","bash","take","be","的","来","43s","觉得","bat","开发板","will","你","将","和","这","sh","share","；"," ","可视化","tools","如何","currently","看到","知道","能","不","代码","安装包","包里","变量","selecting","库","里面","时","~","头文件","$","linux","state","iso","已经","focal","”","把","0","this","浏览器","0.1","中","include","sudo","哪","fetched","里会","get","http","/","["],"title":"安装HHP","title_tokens":["安装","hhp"]},{"location":"hhp/2.3_HHP%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/","text":"地平线机器人开发平台(HHP)系统配置 无论是旭日X3派，还是HHP，在正式使用之前，都还需要进行一些必要的配置，完善必要的功能模块，提供完整的算力支持，达到最佳状态。 网络连接 第一个配置，是无线网络连接。 当然，大家也可以直接用网线连接旭日X3派和一个可以上网的路由器，不过更多时候，我们还是会使用无线网络来上网。 我们打开MobaXterm,选择SSH，使用root用户登录板卡；如果之前登录过板卡、还没有关闭的话，也可以继续使用。 现在我们可以通过命令行搜索周边环境有哪些WIFI信号，命令如下： $ sudo nmcli device wifi rescan #扫描当前环境里所有WIFI名称，但扫描结果不会显示 $ nmcli device wifi list #显示扫描到的WIFI名称 $ sudo nmcli device wifi connect <账号> password <密码> #连接WIFI $ sudo vim /etc/network/interfaces #修改DHCP配置 比如，我的办公室里wifi的名称是psmicro,我们就可以使用“sudo nmcli device wifi connect psmicro password <密码>”来连接。 等到终端返回信息“successfully activated\",就说明WIFI连接成功； 我们可以Ping古月居的网址，来检查一下连接。如果能够Ping通，就说明网络已经连接成功，现在就可以成功连接到互联网，进行后续的软件下载和更新了。 网络配置完成后，在后续开发中，大家就可以直接下载或更新各种软件包了。 系统更新 第二个配置，是更新当前旭日X3派所使用的Ubuntu镜像，和在电脑上使用的命令相同。 我们更新一下当前的系统镜像： $ sudo apt update #会按照当前软件源的域名设置去连接远程软件源 $ sudo apt full-upgrade #升级所有可以升级的软件包 弹出如下对话，我们选择“Y”，回车； 这样我们就完成了对系统更新的检查，并安装好了更新包。 CPU调频策略 第三个配置，设置CPU的调频策略，这是一个可选项，大家了解之后，在未来需要使用的时候进行配置即可。 动态调频 $ echo > ondemand /sys/devices/system/cpu/cpufreq/policy0/scaling_governor #让系统根据当前负载，动态调整CPU频率 满频模式 $ echo > performance /sys/devices/system/cpu/cpufreq/policy0/scaling_governor #让CPU始终以满频，也就1.2GHz的频率工作 打开超频 $ echo 1 > /sys/devices/system/cpu/cpufreq/boost #使CPU以超频，也就是1.5GHz的频率工作 关闭超频 $ echo 0 > /sys/devices/system/cpu/cpufreq/boost 这里CPU频率为，满频模式：1.2GHz，超频模式：1.5GHz。 大家需要注意，默认的系统配置是关闭超频、并且动态调频的配置。这样可以比较好地保证功率最优。 安装ROS2功能包 接下来，还有一个很重要的配置，那就是安装ROS2功能包，我们说TogetherROS是基于ROS2深度优化的，很多模块还是会复用ROS2中的功能，所有ROS2的原生功能也可以支持，这里我们就把ROS2必要的功能包都安装一下，让系统的功能模块更加完整。 熟悉ROS2的同学，应该对这些指令并不陌生，和ROS2官方手册中的安装步骤一致，不过还是建议大家跟着课程的步骤一起来安装一下。 添加ROS2源 第一步我们需要更新系统软件源，并安装必要的下载工具。 $ sudo apt update && sudo apt install curl gnupg lsb-release #更新软件源 $ sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg #设置ROS2软件源秘钥 $ echo \"deb [arch= $( dpkg --print-architecture ) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $( source /etc/os-release && echo $UBUNTU_CODENAME ) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null #设置ROS2软件源 Attention 大部分国内开发者在这都会遇到同一个问题：网址无法连接。解决方案可以参考古月居官网上的这篇帖子： 《解决”Failed to connect to raw.githubusercontent.com“报错》 安装ROS2包 $ sudo apt update #更新软件源 $ sudo apt install ros-foxy-ros-base ros-foxy-demo-nodes-cpp # 安装ROS2功能包 时间会有些长，需要稍微等待一下。 现在ROS2就安装完成了。 大家可以使用同样的命令，继续安装ROS2中的更多功能包。 这里推荐大家先安装ROS2之后会使用到的编译器，比如python3-colcon-common-extensions。我们后续一些TogetherROS功能包的编译，也会使用python3-colcon-common的命令来安装。 $ sudo apt install python3-colcon-common-extensions # ROS2编译器 另外，我们推荐大家安装一个git工具，大家可以通过它下载GitHub、GitLab上的软件包，我们后续也会用到。安装命令为本小节代码第四行。 $ sudo apt install git # 安装git工具 到这里，我们常用的软件和功能包就安装完成了。我们可以看到，在旭日X3派文件目录/opt底下，除了之前的/tros文件夹外，还多出来一个/ros文件夹，里面就是我们刚才安装好的ros-foxy版本的所有系统文件。 如果大家要使用ROS2的功能包，也需要source里面的.bash或者.bat脚本文件。 建立软链接 为了方便我们在TogetherROS系统里调用ROS2的功能，在TogetherROS里提供了一个叫create_soft_link创建软链接的脚本，它而已通过软链接，把ROS2的环境变量链接到当前TogetherROS的环境包里来。执行以下命令： $ cd /opt/tros ## 使用/opt/tros目录下的create_soft_link.py创建ROS package至TogetherROS的软链接 $ python3 create_soft_link.py --foxy /opt/ros/foxy/ --tros /opt/tros 这样设置以后，假如你source了TogetherROS的环境变量，那么同样的配置也会对ROS2生效。 好啦，到这里为止，所有必要的配置项我们都做完了，是不是有点迫不及待想要使用TogetherROS了呢？","text_tokens":["说","是不是","可选","py","github","功能","指令","打开","gnupg","有点","为本","平台","failed","一下","好","派","并且","就","想要","boost","机器","就是","ros","方便","居","connect","还有","多功能","scaling","vim","遇到","使用","外","选择","不过","重要","策略","第三",".","课程","keyring","完","参考","根据","更新","假如","检查","以后","并","另外","搜索","升级","环境变","命令","通过","#","很","进行","等待","之后","当然","没有","需要","下","达到最佳","三个","togetherros","很多","mobaxterm","-","update","password","还是","ghz","系统文件","会","去","正式","。","出来","办公","网络连接",")","opt","为了","to","bash","稍微","执行","interfaces","代码","底下","之前","gpg","编译器","建议","rosdistro","我","0","而已","sources","手册","更加","互联网","继续","有些","以下","dhcp","无线网","base","深度","二个","环境","用到","第一","工具","都","？","source","的话","先","y","基于","这些","release","大部分","以","githubusercontent","检查一下","满频","完善","开发","支持","系统","刚才","起来","按照","说明","回车","无论","古月","地平线","下来","网络","tros","lsb","工作","成功","叫","》","这是","算力","device","优化","一","联网","呢","除了","x3","devices","d","始终","deb","第四","了解","调用","对系统","默认","跟着","python3","帖子","系统配置","ssh","那","长","--","raw","文件","信息","在","soft","项","extensions","sys","板卡","o","周边","org","etc","配置","以满频","软","对","接下","_","连接","网上","四行","一个","上","full","同样","link","不是","能够","时候","attention","是","系统配","同一个","远程","cd","wifi","一致","频率","key","或者","旭日","统配","这","提供","编译","修改","路由","注意","“","官方","同一","或","demo","多","=","版本","已经","network","gitlab","git","sudo","名称","国内","/","<","com","可以","foxy","账号","办公室","哪些","&&","公室","nmcli","终端","动态","]",":","目录","\"","后","、","《","apt","不及","开发者","步骤","选项","状态","添加","它","无线网络","ros2","signed","文件目录","包都","机器人","应该","完成","源","可选项","，","直接","ondemand","create","镜像","负载","里","复用","(","居官","啦","迫不及待","比如","小节","秘钥","相同","链接","cpp","如下","用户","登录","部分","问题","dev","##","echo","governor","所有","第四行","安装","第一个","packages","但","设置","命令行","第三个","by","也","解决","弹","activated","网线","当前","密码","keyrings","|","方案","包","1.5","install","文件夹","必要","陌生","master","未来","：","的","不会","为","你","和",">","常用","有","最优","解决方案"," ","熟悉","那么","生效","dpkg","包里","上网","域名","$","无线","各种","”","报错","地平","这篇","中","一步","list","cpu","http","把","如果","这样","模式","软件包","os","performance","路由器","更","cpufreq","推荐","upgrade","1","件夹","hhp","无法","使","达到","至","模块","网址","archive","地","package","让","nodes","第一步","rescan","所","最佳","还","软件","下载工具","线网","我们","超频","policy0","第二个","main","无论是","通","原生","这里","调频","功率","后续","common","一些","大部","信号","ping","了","返回","对话","更新包","root","大家","ssl","比较","创建","出","环境变量","电脑","colcon","到","接下来","usr","周边环境","architecture",",","互联","arch","保证","successfully","第二","等到","现在","扫描","脚本","curl","ubuntu","功能模块","codename","同学","结果","print","即可","关闭","用","来","bat","system","过","share","；","调整","https","1.2","看到","不","要","tee","变量","里面","下载","完整","为止","psmicro","系统软件","时间","显示","null","建立","做","["],"title":"HHP系统配置","title_tokens":["统配","系统配","系统配置","hhp","系统","配置"]},{"location":"hhp/2.3_HHP%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/#hhp","text":"无论是旭日X3派，还是HHP，在正式使用之前，都还需要进行一些必要的配置，完善必要的功能模块，提供完整的算力支持，达到最佳状态。","text_tokens":["功能","，","的","无论","进行","使用","在","旭日","提供","无论是","需要","都","达到最佳","算力","派","hhp","一些","达到","配置","模块","x3","之前","完整","还是","状态","正式","。","完善","功能模块","最佳","支持","还","必要"],"title":"地平线机器人开发平台(HHP)系统配置","title_tokens":["机器","统配","系统配","地平","机器人","平台","系统","系统配置","hhp","地平线","开发","(",")","配置"]},{"location":"hhp/2.3_HHP%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/#_1","text":"第一个配置，是无线网络连接。 当然，大家也可以直接用网线连接旭日X3派和一个可以上网的路由器，不过更多时候，我们还是会使用无线网络来上网。 我们打开MobaXterm,选择SSH，使用root用户登录板卡；如果之前登录过板卡、还没有关闭的话，也可以继续使用。 现在我们可以通过命令行搜索周边环境有哪些WIFI信号，命令如下： $ sudo nmcli device wifi rescan #扫描当前环境里所有WIFI名称，但扫描结果不会显示 $ nmcli device wifi list #显示扫描到的WIFI名称 $ sudo nmcli device wifi connect <账号> password <密码> #连接WIFI $ sudo vim /etc/network/interfaces #修改DHCP配置 比如，我的办公室里wifi的名称是psmicro,我们就可以使用“sudo nmcli device wifi connect psmicro password <密码>”来连接。 等到终端返回信息“successfully activated\",就说明WIFI连接成功； 我们可以Ping古月居的网址，来检查一下连接。如果能够Ping通，就说明网络已经连接成功，现在就可以成功连接到互联网，进行后续的软件下载和更新了。 网络配置完成后，在后续开发中，大家就可以直接下载或更新各种软件包了。","text_tokens":["如果","dhcp","无线网","可以","软件包","账号","打开","办公室","哪些","路由器","环境","更","公室","nmcli","终端","第一","一下","\"","派","后","的话","、","就","网址","检查一下","无线网络","居","rescan","connect","开发","还","软件","线网","我们","说明","完成","，","古月","vim","网络","使用","直接","选择","成功","不过","通","里","后续","device","信号","ping","联网","了","x3","返回","比如","root","大家","更新","检查","如下","用户","搜索","登录","ssh","命令","到","通过","#","进行","信息","在","周边环境","当然","所有","没有",",","第一个","互联","板卡","但","successfully","周边","等到","命令行","现在","mobaxterm","etc","配置","扫描","也","password","连接","还是","activated","一个","网线","会","当前","密码","。","办公","能够","时候","是","结果","：","关闭","用","的","来","不会","wifi","和","旭日","过",">","有","interfaces","；"," ","修改","路由","上网","“","下载","之前","$","或","无线","多","各种","我","psmicro","”","network","已经","显示","中","sudo","名称","list","互联网","继续","/","<"],"title":"网络连接","title_tokens":["网络","网络连接","连接"]},{"location":"hhp/2.3_HHP%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/#_2","text":"第二个配置，是更新当前旭日X3派所使用的Ubuntu镜像，和在电脑上使用的命令相同。 我们更新一下当前的系统镜像： $ sudo apt update #会按照当前软件源的域名设置去连接远程软件源 $ sudo apt full-upgrade #升级所有可以升级的软件包 弹出如下对话，我们选择“Y”，回车； 这样我们就完成了对系统更新的检查，并安装好了更新包。","text_tokens":["是","电脑","软件","远程","我们","按照","这样","命令","：","源","可以","软件包","完成","，","的","回车","#","使用","二个","在","第二个","选择","和","旭日","所有","；"," ","一下","安装","好","镜像","upgrade","第二","派","设置","-","了","配置","就","y","x3","update","apt","域名","“","连接","对话","$","弹","更新包","上","更新","”","会","full","当前","去","检查","相同","并","对系统","。","ubuntu","如下","sudo","所","系统","出","升级"],"title":"系统更新","title_tokens":["更新","系统"]},{"location":"hhp/2.3_HHP%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/#cpu","text":"第三个配置，设置CPU的调频策略，这是一个可选项，大家了解之后，在未来需要使用的时候进行配置即可。 动态调频 $ echo > ondemand /sys/devices/system/cpu/cpufreq/policy0/scaling_governor #让系统根据当前负载，动态调整CPU频率 满频模式 $ echo > performance /sys/devices/system/cpu/cpufreq/policy0/scaling_governor #让CPU始终以满频，也就1.2GHz的频率工作 打开超频 $ echo 1 > /sys/devices/system/cpu/cpufreq/boost #使CPU以超频，也就是1.5GHz的频率工作 关闭超频 $ echo 0 > /sys/devices/system/cpu/cpufreq/boost 这里CPU频率为，满频模式：1.2GHz，超频模式：1.5GHz。 大家需要注意，默认的系统配置是关闭超频、并且动态调频的配置。这样可以比较好地保证功率最优。","text_tokens":["可选","模式","这样","可以","打开","performance","cpufreq","动态","好","1","并且","使","、","就","选项","地","以","让","boost","就是","满频","系统","scaling","可选项","超频","，","policy0","使用","工作","ondemand","这是","负载","第三","策略","调频","这里","功率","devices","始终","根据","大家","了解","比较","默认","系统配置","echo","#","进行","在","governor","之后","需要","sys","保证","三个","设置","第三个","配置","以满频","也","_","ghz","一个","当前","1.5","。","时候","是","系统配","未来","即可","：","关闭","的","为","频率","system",">","统配","最优","调整"," ","1.2","注意","$","0","cpu","/"],"title":"CPU调频策略","title_tokens":["策略","调频","cpu"]},{"location":"hhp/2.3_HHP%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/#ros2","text":"接下来，还有一个很重要的配置，那就是安装ROS2功能包，我们说TogetherROS是基于ROS2深度优化的，很多模块还是会复用ROS2中的功能，所有ROS2的原生功能也可以支持，这里我们就把ROS2必要的功能包都安装一下，让系统的功能模块更加完整。 熟悉ROS2的同学，应该对这些指令并不陌生，和ROS2官方手册中的安装步骤一致，不过还是建议大家跟着课程的步骤一起来安装一下。","text_tokens":["还有","说","是","包都","陌生","起来","应该","那","我们","可以","功能","，","接下来","很","的","指令","下来","深度","一致","和","不过","重要","所有","安装","一下"," ","熟悉","原生","这里","togetherros","很多","复用","优化","不","一","配置","就","模块","课程","对","接下","基于","也","官方","这些","完整","步骤","还是","建议","让","一个","大家","会","并","就是","包","系统","。","中","ros2","功能模块","手册","跟着","更加","支持","同学","把","必要"],"title":"安装ROS2功能包","title_tokens":["安装","包","ros2","功能"]},{"location":"hhp/2.3_HHP%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/#ros2_1","text":"第一步我们需要更新系统软件源，并安装必要的下载工具。 $ sudo apt update && sudo apt install curl gnupg lsb-release #更新软件源 $ sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg #设置ROS2软件源秘钥 $ echo \"deb [arch= $( dpkg --print-architecture ) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $( source /etc/os-release && echo $UBUNTU_CODENAME ) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null #设置ROS2软件源 Attention 大部分国内开发者在这都会遇到同一个问题：网址无法连接。解决方案可以参考古月居官网上的这篇帖子： 《解决”Failed to connect to raw.githubusercontent.com“报错》","text_tokens":["com","可以","os","gnupg","&&","]","第一",":","failed","工具","都","\"","source","无法","《","apt","开发者","网址","release","archive","大部分","githubusercontent","ros","第一步","ros2","signed","connect","系统","开发","软件","下载工具","我们","源","，","古月","遇到","lsb","main","》","大部",".","(","居官","keyring","d","deb","参考","秘钥","更新","ssl","并","帖子","部分","问题","dev","usr","#","raw","echo","--","在","architecture","需要","安装","arch","packages","o","设置","org","etc","-","update","by","_","解决","连接","网上","一个","会","keyrings","curl","|","方案","。","ubuntu","install","codename",")","必要","attention","同一个","master","to","print","：","的","key",">","这","解决方案","share"," ","https","dpkg","tee","“","下载","同一","gpg","$","rosdistro","=","系统软件","”","报错","这篇","sources","一步","null","sudo","list","国内","http","/","["],"title":"添加ROS2源","title_tokens":["添加","源","ros2"]},{"location":"hhp/2.3_HHP%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/#ros2_2","text":"$ sudo apt update #更新软件源 $ sudo apt install ros-foxy-ros-base ros-foxy-demo-nodes-cpp # 安装ROS2功能包 时间会有些长，需要稍微等待一下。 现在ROS2就安装完成了。 大家可以使用同样的命令，继续安装ROS2中的更多功能包。 这里推荐大家先安装ROS2之后会使用到的编译器，比如python3-colcon-common-extensions。我们后续一些TogetherROS功能包的编译，也会使用python3-colcon-common的命令来安装。 $ sudo apt install python3-colcon-common-extensions # ROS2编译器 另外，我们推荐大家安装一个git工具，大家可以通过它下载GitHub、GitLab上的软件包，我们后续也会用到。安装命令为本小节代码第四行。 $ sudo apt install git # 安装git工具 到这里，我们常用的软件和功能包就安装完成了。我们可以看到，在旭日X3派文件目录/opt底下，除了之前的/tros文件夹外，还多出来一个/ros文件夹，里面就是我们刚才安装好的ros-foxy版本的所有系统文件。 如果大家要使用ROS2的功能包，也需要source里面的.bash或者.bat脚本文件。","text_tokens":["有些","如果","可以","github","功能","foxy","软件包","base","更","推荐","用到","为本","目录","一下","好","工具","件夹","派","source","先","、","就","apt","它","nodes","就是","ros","ros2","文件目录","系统","还","刚才","多功能","软件","我们","源","完成","，","外","使用","tros","这里","common","后续","一些",".","了","除了","x3","比如","小节","第四","更新","大家","另外","cpp","python3","colcon","命令","长","到","通过","#","文件","等待","在","之后","extensions","第四行","安装","需要","所有","togetherros","现在","-","update","也","四行","一个","上","系统文件","脚本","会","同样","包","。","出来","install","文件夹","opt","bash","的","来","bat","稍微","常用","和","旭日","或者"," ","编译","看到","代码","要","底下","里面","下载","之前","$","编译器","demo","多","版本","时间","gitlab","中","git","sudo","继续","/"],"title":"安装ROS2包","title_tokens":["安装","包","ros2"]},{"location":"hhp/2.3_HHP%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/#_3","text":"为了方便我们在TogetherROS系统里调用ROS2的功能，在TogetherROS里提供了一个叫create_soft_link创建软链接的脚本，它而已通过软链接，把ROS2的环境变量链接到当前TogetherROS的环境包里来。执行以下命令： $ cd /opt/tros ## 使用/opt/tros目录下的create_soft_link.py创建ROS package至TogetherROS的软链接 $ python3 create_soft_link.py --foxy /opt/ros/foxy/ --tros /opt/tros 这样设置以后，假如你source了TogetherROS的环境变量，那么同样的配置也会对ROS2生效。 好啦，到这里为止，所有必要的配置项我们都做完了，是不是有点迫不及待想要使用TogetherROS了呢？","text_tokens":["以下","是不是","py","这样","功能","foxy","环境","有点","目录","好","？","都","source","至","想要","不及","package","它","ros","方便","ros2","系统","我们","，","tros","使用","create","叫","这里","里",".","呢","了","啦","迫不及待","完","假如","以后","调用","链接","python3","创建","环境变量","环境变","命令","##","到","通过","--","在","soft","项","所有","下","togetherros","设置","配置","软","对","也","_","一个","脚本","会","当前","同样","link","。","不是","必要","opt","为了","：","cd","的","来","你","执行","提供"," ","那么","生效","包里","变量","为止","$","而已","做","/","把"],"title":"建立软链接","title_tokens":["建立","链接","软"]},{"location":"hhp/2.4_HHP%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C/","text":"地平线机器人开发平台(HHP)示例运行 接下来，我们就在安装配置好HHP的旭日X3派上，试一试系统自带的一些例程，确保整个系统已经可以正常运行。 通信测试 先来测试一下HHP中TogetherROS系统的通信功能。 我们需要启动两个终端，分别连接到旭日X3派上，并分别按以下命令配置环境变量。 终端1： $ source /opt/tros/local_setup.bash $ ros2 run examples_rclcpp_minimal_publisher publisher_member_function 终端2： $ source /opt/tros/local_setup.bash $ ros2 run examples_rclcpp_minimal_subscriber subscriber_member_function 接下来，我们用ros2 run命令运行节点： 运行第一个例程： ros2 run example_rclcpp_minimal_publisher publisher_member_function 这是一个用C++写的最小化的发布者程序，其中节点叫publisher_member+function，按回车运行该节点。 可以看到这个节点开始不断循环发布信息，每次发布的信息为字符串形式，内容是“Hello,world! +数字”。 同样，在终端2的命令行窗口，输入以下命令并回车开启订阅者节点。 ros2 run examples_rclcpp_minimal_subscriber subscriber_member_function 这个订阅者节点会获取到、并显示出刚才发布者节点发布的信息。 通过这样一个例程，我们验证了两个节点之间的通信没有问题。这这是一个基于DDS的话题通信。 按CTRL+C可以关闭该例程。 通信系统没有问题了，如果你是一个ROS2的开发者，可能对刚才我们使用的ROS2命令比较熟悉，这时你可能也会产生一个问题：我们之前也安装了ROS2系统，那ROS2的原生功能还可以正常运行么？ 我们再来试一试ROS2中自带的一个例程。 和刚才一样打开两个终端，这里我们需要source一下ROS里的环境变量。该环境变量我们刚才已经设置了过软连接，所以配置过程中它也会配置ROS2的功能包路径。 在终端1输入命令： $ source /opt/tros/local_setup.bash 在终端2，也输入同样的命令，配置环境变量的脚本： 接下来运行两个ROS2的节点。 这两个节点的功能包是属于ROS2里的功能包,可以直接调用到。我们来尝试一下输入命令ros2 run，再输入功能包名称，如果按Tab自动补全文件名，说明可以找到对应的这个功能包： ros2 run demo_nodes_cpp talker talker也是一个发布者节点。按回车运行，可以看到终端1的发布者节点以每秒1次的频率发布消息。 同样，我们到终端2中打开订阅者节点： ros2 run demo_nodes_cpp listener 回车运行，很快两个终端间就建立了通讯。 这样就使用ROS2里的例程实现了话题通信连接，只不过这里我们使用的就是ROS2原生的功能包了，而不是TogetherROS的功能。 通信系统已经没问题了，但看上去似乎还不太直观。 目标检测 没问题，接下来，我们就运行一个更为直观的案例——目标检测。 在这个案例中，需要大家找一个USB的相机，连接到旭日X3拍的USB接口上。 在运行这个例程之前，需要确认两点：1.有一个USB相机已经连接到了旭日X3派板子上；2.有一个HDMI的显示器也连接到了旭日X3派板子上，它主要用于显示后续的图像检测的效果。 要确认USB相机已经正确连接到开发板，可以在终端输入命令“ls - dv\"查看当前设备号，默认把USB相机识别为vedio8，如果当前列表里能找到vedio8就说明相机被成功识别到了。 输入以下命令运行例程： $ cd /app/ai_inference/02_usb_camera_sample/ $ python3 ./usb_camera_fcos.py 代码第一行，02例程的功能是通过相机动态采集图像，并对图像里的目标物体进行实时识别。 代码第二行，我们用python3来运行例程usb_camera_fcos.py，它的目标识别的功能是通过我们板卡中CPU的AI引擎来实现的。 我们输入以上两行代码，就开始驱动相机、并对相机里的图像做动态识别了。 此时如果有连接HDMI的显示器，就可以在显示器里看到动态识别的效果。 我们可以调整USB相机镜头的范围，去拍一些杯子、电脑、显示器等等，都可以把对应的目标物体识别到，并把对应的物体用彩色框给框出来；在框的左上角，就是识别到物体的名称、以及它识别的概率值了。 几个示例程序都可以正常运行了，说明当前的软硬件系统都已经准备就绪，到这里，我们才算是可以正式开始机器人开发了。","text_tokens":["框","主要","py","功能","hdmi","打开","平台","一下","好","派","订阅","c++","就","对应","写","两行","发布者","机器","验证","就是","ros","实现","数字","使用","不过","节点",".","字符串","minimal","该","talker","尝试","准备就绪","并","二行","usb","上角","找到","hello","环境变","member","命令","通过","进行","试一试","没有","需要","togetherros","之间","很快","-","会","去","目标","正式","。","出来","example","镜头",")","产生","opt","bash","local","上去","自动","能","代码","—","之前","更为","确认","通信","tab","ctrl","以下","消息","环境","再","第一","？","都","source","开启","先","基于","以","一行","可能","系统","开发","刚才","接口","查看","次","说明","只不过","回车","找","实时","地平线","下来","tros","成功","叫","第一行","程序","这是","物体","值","文件名","x3","就绪","examples","调用","确保","每秒","fcos","默认","python3","用于","那","文件","信息","在","形式","ls","板卡","硬件","配置","此时","软","对","接下","_","循环","框出来","连接","一个","上","测试","同样","补全","不是","最小化","框给","是","cd","频率","旭日","直观","这","app","这个","camera","!","启动","vedio8","一样","“","demo","已经","以上","名称","/","2","太","可以","其中","驱动","动态","以及","终端","列表","\"","setup","、","开发者","么","采集","它","两点","杯子","ros2","准备","function","机器人","，","正常","直接","里","(","02","左上角","rclcpp","窗口","cpp","引擎","所以","板子","问题","识别","运行","间","安装","第一个","但","检测","设置","案例","命令行","图像","正确","才","也","run","话题","当前","包","自带","：","的","输入","+","为","你","和","有","每次"," ","整个","熟悉","概率","设备","等等","$","”","地平","中","cpu","把","软硬件","如果","例程","这样","似乎","1","hhp","这时","第二行","彩色","最小","nodes","内容","不断","过程","被","还","按","dv","示例","我们","属于","没","路径","原生","这里","后续","一些","dds","了","看上去","软硬","发布","大家","比较","号","环境变量","出","开始","电脑","两个","sample","到","接下来","分别","通讯",",","ai","第二","c","inference","左上","者","框出","脚本","范围","算是","字符","显示器","而","包是","world","关闭","用","来","看上","开发板","过","；","调整","看到","不","效果","要","变量","获取","拍","subscriber","几个","显示","publisher","相机","建立","做","包了","listener"],"title":"HHP示例运行","title_tokens":["运行","hhp","示例"]},{"location":"hhp/2.4_HHP%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C/#hhp","text":"接下来，我们就在安装配置好HHP的旭日X3派上，试一试系统自带的一些例程，确保整个系统已经可以正常运行。","text_tokens":["例程","我们","可以","，","接下来","的","正常","下来","在","旭日","试一试","运行","安装","整个","好","hhp","派","一些","配置","就","x3","接下","上","已经","确保","。","自带","系统"],"title":"地平线机器人开发平台(HHP)示例运行","title_tokens":["机器","地平","机器人","平台","示例","运行","hhp","地平线","开发","(",")"]},{"location":"hhp/2.4_HHP%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C/#_1","text":"先来测试一下HHP中TogetherROS系统的通信功能。 我们需要启动两个终端，分别连接到旭日X3派上，并分别按以下命令配置环境变量。 终端1： $ source /opt/tros/local_setup.bash $ ros2 run examples_rclcpp_minimal_publisher publisher_member_function 终端2： $ source /opt/tros/local_setup.bash $ ros2 run examples_rclcpp_minimal_subscriber subscriber_member_function 接下来，我们用ros2 run命令运行节点： 运行第一个例程： ros2 run example_rclcpp_minimal_publisher publisher_member_function 这是一个用C++写的最小化的发布者程序，其中节点叫publisher_member+function，按回车运行该节点。 可以看到这个节点开始不断循环发布信息，每次发布的信息为字符串形式，内容是“Hello,world! +数字”。 同样，在终端2的命令行窗口，输入以下命令并回车开启订阅者节点。 ros2 run examples_rclcpp_minimal_subscriber subscriber_member_function 这个订阅者节点会获取到、并显示出刚才发布者节点发布的信息。 通过这样一个例程，我们验证了两个节点之间的通信没有问题。这这是一个基于DDS的话题通信。 按CTRL+C可以关闭该例程。 通信系统没有问题了，如果你是一个ROS2的开发者，可能对刚才我们使用的ROS2命令比较熟悉，这时你可能也会产生一个问题：我们之前也安装了ROS2系统，那ROS2的原生功能还可以正常运行么？ 我们再来试一试ROS2中自带的一个例程。 和刚才一样打开两个终端，这里我们需要source一下ROS里的环境变量。该环境变量我们刚才已经设置了过软连接，所以配置过程中它也会配置ROS2的功能包路径。 在终端1输入命令： $ source /opt/tros/local_setup.bash 在终端2，也输入同样的命令，配置环境变量的脚本： 接下来运行两个ROS2的节点。 这两个节点的功能包是属于ROS2里的功能包,可以直接调用到。我们来尝试一下输入命令ros2 run，再输入功能包名称，如果按Tab自动补全文件名，说明可以找到对应的这个功能包： ros2 run demo_nodes_cpp talker talker也是一个发布者节点。按回车运行，可以看到终端1的发布者节点以每秒1次的频率发布消息。 同样，我们到终端2中打开订阅者节点： ros2 run demo_nodes_cpp listener 回车运行，很快两个终端间就建立了通讯。 这样就使用ROS2里的例程实现了话题通信连接，只不过这里我们使用的就是ROS2原生的功能包了，而不是TogetherROS的功能。 通信系统已经没问题了，但看上去似乎还不太直观。","text_tokens":["如果","ctrl","以下","2","例程","太","这样","其中","可以","功能","打开","消息","似乎","环境","终端","再","第一","一下","？","1","setup","hhp","派","source","订阅","开启","先","c++","、","就","这时","基于","对应","开发者","写","么","以","最小","它","nodes","发布者","验证","就是","ros","内容","不断","ros2","实现","可能","过程","系统","开发","还","按","刚才","function","我们","次","属于","说明","没","，","回车","正常","只不过","下来","数字","tros","使用","直接","不过","叫","程序","这是","原生","这里","路径","里","文件名","节点",".","字符串","dds","了","minimal","x3","看上去","该","examples","talker","发布","rclcpp","窗口","尝试","并","调用","cpp","每秒","比较","找到","环境变量","出","hello","开始","所以","环境变","member","那","问题","两个","命令","到","接下来","通过","文件","分别","信息","在","形式","试一试","运行","通讯","没有","需要","第一个",",","安装","间","但","togetherros","之间","设置","很快","命令行","c","配置","软","对","接下","也","_","循环","者","连接","run","话题","一个","上","测试","脚本","会","同样","字符","包","。","而","补全","不是","包是","example","自带","最小化","产生","world","opt","是","：","bash","关闭","用","的","输入","来","看上","+","为","你","频率","和","旭日","过","这","local","直观","每次"," ","熟悉","上去","自动","看到","这个","!","不","启动","变量","获取","一样","“","之前","subscriber","$","demo","”","已经","显示","publisher","通信","中","名称","建立","tab","/","包了","listener"],"title":"通信测试","title_tokens":["测试","通信"]},{"location":"hhp/2.4_HHP%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C/#_2","text":"没问题，接下来，我们就运行一个更为直观的案例——目标检测。 在这个案例中，需要大家找一个USB的相机，连接到旭日X3拍的USB接口上。 在运行这个例程之前，需要确认两点：1.有一个USB相机已经连接到了旭日X3派板子上；2.有一个HDMI的显示器也连接到了旭日X3派板子上，它主要用于显示后续的图像检测的效果。 要确认USB相机已经正确连接到开发板，可以在终端输入命令“ls - dv\"查看当前设备号，默认把USB相机识别为vedio8，如果当前列表里能找到vedio8就说明相机被成功识别到了。 输入以下命令运行例程： $ cd /app/ai_inference/02_usb_camera_sample/ $ python3 ./usb_camera_fcos.py 代码第一行，02例程的功能是通过相机动态采集图像，并对图像里的目标物体进行实时识别。 代码第二行，我们用python3来运行例程usb_camera_fcos.py，它的目标识别的功能是通过我们板卡中CPU的AI引擎来实现的。 我们输入以上两行代码，就开始驱动相机、并对相机里的图像做动态识别了。 此时如果有连接HDMI的显示器，就可以在显示器里看到动态识别的效果。 我们可以调整USB相机镜头的范围，去拍一些杯子、电脑、显示器等等，都可以把对应的目标物体识别到，并把对应的物体用彩色框给框出来；在框的左上角，就是识别到物体的名称、以及它识别的概率值了。 几个示例程序都可以正常运行了，说明当前的软硬件系统都已经准备就绪，到这里，我们才算是可以正式开始机器人开发了。","text_tokens":["如果","框","例程","2","以下","主要","py","可以","hdmi","功能","驱动","动态","以及","终端","第一","1","列表","\"","都","派","、","就","第二行","对应","彩色","采集","两点","它","两行","机器","就是","杯子","实现","一行","被","开发","系统","dv","接口","准备","查看","示例","机器人","我们","说明","没","，","找","实时","正常","下来","成功","第一行","程序","物体","这里","值","里","后续","一些",".","了","02","x3","就绪","左上角","软硬","大家","准备就绪","并","二行","usb","引擎","号","fcos","默认","上角","python3","用于","找到","开始","电脑","板子","问题","命令","sample","到","接下来","通过","识别","进行","在","运行","需要","ls","板卡","硬件","ai","检测","第二","案例","图像","-","inference","此时","正确","对","才","接下","也","_","左上","框出来","连接","框出","一个","上","范围","当前","目标","去","算是","正式","显示器","。","出来","镜头","框给","是","：","cd","用","的","输入","来","开发板","为","旭日","直观","有","；"," ","调整","app","概率","看到","这个","设备","camera","能","代码","—","效果","要","vedio8","等等","拍","“","之前","更为","$","几个","已经","确认","以上","显示","相机","中","名称","做","cpu","/","把","软硬件"],"title":"目标检测","title_tokens":["检测","目标"]},{"location":"hhp/3.1_%E5%A4%9A%E8%8A%82%E7%82%B9%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/","text":"多节点话题通信 节点实现了机器人各种各样的功能，但这些功能并不是独立的，之间会有千丝万缕的联系，其中最重要的一种联系方式就是话题，它是 节点间传递数据的桥梁 。 通信模型 以两个机器人节点为例。A节点的功能是驱动相机这个硬件设备，获取得到相机拍摄的图像信息，B节点的功能是视频监控，将相机拍摄到的图像实时显示给用户查看。 大家可以想一下，这两个节点是不是必然存在某种关系？没错，节点A要将获取的图像数据传输给节点B，有了数据，节点B才能做这样可视化的渲染。 此时从节点A到节点B传递图像数据的方式，在ROS中，我们就称之为 话题 ，它作为一个桥梁，实现了节点之间某一个方向上的数据传输。 发布/订阅模型 从话题本身的实现角度来看，使用了基于DDS的 发布/订阅模型 ，什么叫发布和订阅呢？ 话题数据传输的特性是从一个节点到另外一个节点，发送数据的对象称之为 发布者 ，接收数据的对象称之为 订阅者 ，每一个话题都需要有一个名字，传输的数据也需要有固定的数据类型。 打一个比方，大家平时应该也会看微信公众号，比如有一个公众号，它的名字叫做“古月居”，这个古月居就是话题名称，公众号的发布者是古月居的小编，他会把组织好的机器人知识排版成要求格式的公众号文章，发布出去，这个文章格式，就是话题的数据类型。如果大家对这个话题感兴趣，就可以订阅“古月居”，成为订阅者之后自然就可以收到古月居的公众号文章，没有订阅的话，也就无法收到。 类似这样的发布/订阅模型在生活中随处可见，比如订阅报纸、订阅杂志等等。 多对多通信 大家再仔细想下这些可以订阅的东西，是不是并不是唯一的，我们每个人可以订阅很多公众号、报纸、杂志，这些公众号、报纸、杂志也可以被很多人订阅，没错，ROS里的话题也是一样，发布者和订阅者的数量并不是唯一的，可以称之为是多对多的通信模型。 因为话题是多对多的模型，发布控制指令的摇杆可以有一个，也可以有2个、3个，订阅控制指令的机器人可以有1个，也可以有2个、3个，大家可以想象一下这个画面，似乎还是挺魔性的，如果存在多个发送指令的节点，建议大家要 注意区分优先级 ，不然机器人可能不知道该听谁的了。 异步通信 话题通信还有一个特性，那就是异步，这个词可能有同学是第一次听说？所谓异步，只要是指发布者发出数据后，并不知道订阅者什么时候可以收到，类似古月居公众号发布一篇文章，你什么时候阅读的，古月居根本不知道，报社发出一份报纸，你什么时候收到，报社也是不知道的。这就叫做异步。 异步的特性也让话题更适合用于一些周期发布的数据，比如传感器的数据，运动控制的指令等等，如果某些逻辑性较强的指令，比如修改某一个参数，用话题传输就不太合适了。 消息接口 最后，既然是数据传输，发布者和订阅者就得统一数据的描述格式，不能一个说英文，一个理解成了中文。在ROS中，话题通信数据的描述格式称之为消息，对应编程语言中数据结构的概念。比如这里的一个图像数据，就会包含图像的长宽像素值、每个像素的RGB等等，在ROS中都有标准定义。 消息是ROS中的一种接口定义方式 ，与编程语言无关，我们也可以通过 .msg 后缀的文件自行定义，有了这样的接口，各种节点就像积木块一样，通过各种各样的接口进行拼接，组成复杂的机器人系统。 编程方法 了解了话题的基本原理，接下来我们就要开始编写代码啦。 创建工作空间 请大家先按照这个流程创建工作空间、下载课程的例程代码，并进行编译。 $ mkdir –p dev_ws/src $ cd /userdata/dev_ws/src $ git clone https://gitee.com/guyuehome/togetherros_tutorials.git $ cd /userdata/dev_ws/ $ colcon build 运行示例程序 编译成功后，我们尝试运行话题通信的Hello World例程，在这个例程中，我们会先创建一个发布者，发布话题“chatter”，周期发送“Hello World”这个字符串，消息类型是ROS中标准定义的String，再创建一个订阅者，订阅“chatter”这个话题，从而接收到“Hello World”这个字符串。 $ source /opt/tros/local_setup.bash $ source install/local_setup.bash $ ros2 run learning_topic_cpp talker $ ros2 run learning_topic_cpp listener 这就是TogetherROS系统中话题通信的方法，依然沿用了ROS2中话题通信的完整流程。 代码解析 发布者的实现方法publisher_member_function.cpp： #include <chrono> #include <functional> #include <memory> #include <string> #include \"rclcpp/rclcpp.hpp\" #include \"std_msgs/msg/string.hpp\" using namespace std :: chrono_literals ; /* This example creates a subclass of Node and uses std::bind() to register a * member function as a callback from the timer. */ class MinimalPublisher : public rclcpp :: Node { public : MinimalPublisher () : Node ( \"minimal_publisher\" ), count_ ( 0 ) { publisher_ = this -> create_publisher < std_msgs :: msg :: String > ( \"topic\" , 10 ); timer_ = this -> create_wall_timer ( 500 ms , std :: bind ( & MinimalPublisher :: timer_callback , this )); } private : void timer_callback () { auto message = std_msgs :: msg :: String (); message . data = \"Hello, world! \" + std :: to_string ( count_ ++ ); RCLCPP_INFO ( this -> get_logger (), \"Publishing: '%s'\" , message . data . c_str ()); publisher_ -> publish ( message ); } rclcpp :: TimerBase :: SharedPtr timer_ ; rclcpp :: Publisher < std_msgs :: msg :: String >:: SharedPtr publisher_ ; size_t count_ ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < MinimalPublisher > ()); rclcpp :: shutdown (); return 0 ; } 订阅者的实现方法subscriber_member_function.cpp： #include <memory> #include \"rclcpp/rclcpp.hpp\" #include \"std_msgs/msg/string.hpp\" using std :: placeholders :: _1 ; class MinimalSubscriber : public rclcpp :: Node { public : MinimalSubscriber () : Node ( \"minimal_subscriber\" ) { subscription_ = this -> create_subscription < std_msgs :: msg :: String > ( \"topic\" , 10 , std :: bind ( & MinimalSubscriber :: topic_callback , this , _1 )); } private : void topic_callback ( const std_msgs :: msg :: String :: SharedPtr msg ) const { RCLCPP_INFO ( this -> get_logger (), \"I heard: '%s'\" , msg -> data . c_str ()); } rclcpp :: Subscription < std_msgs :: msg :: String >:: SharedPtr subscription_ ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < MinimalSubscriber > ()); rclcpp :: shutdown (); return 0 ; }","text_tokens":["说","各样","是不是","据传","500","功能","指令","–","才能","一下","好","定义","订阅","就","%","对应","仔细","根本","learning","发布者","机器","就是","ros","最后","什么","实现","居","10","较强","在生活中","还有","from","每个","类型","使用","成","重要","节点","minimalsubscriber",".","字符串","int","info","感兴","课程","minimal","该","talker","异步","gitee","尝试","组织","namespace","并","另外","依然",";","hello","member","通过","优先级","#","进行","void","就要","从","as","之后","没有","需要","微信","togetherros","之间","很多","各种各样","-","creates","还是","空间","看","监控","会","某种","。","example",")","一次","千丝万缕","opt","to","bash","message","通信模型","叫做","local","b","方法","可视化","sharedptr","代码","chatter","建议","出去","感兴趣","0","通信","include","理解","传输","minimalpublisher","联系方式","count","基本","node","of","消息","&","再","第一","？","都","与","控制指令","logger","source","register","的话","先","语言","没错","像素","基于","之为","这些","以","可见","拼接","不能","'","中文","最","可能","系统","接口","查看","按照","既然","实时","古月","下来","tros","class","工作","成功","叫","程序","值","本原","a","呢","传递数据","摇杆","概念","拍摄","适合","了解","make","用于","杂志","自然","周期","那","格式","userdata","方向","文件","信息","固定","沿用","在","报社","逻辑性","人","名字","硬件","比方","随处","此时","对","接下","_","the","得到","长宽","一个","存在","上","发送","不是","时候","argc","*","是","结构","一种","cd","兴趣","将","称之为","这","shared","编译","修改","这个","对象","知道","init","!","必然","const","运动","注意","一样","包含","桥梁","多个","“","多","=","谁","打","统一","公众","git","名称","所谓","using","/","<","2","太","com","其中","可以","驱动","topic","传感器","timer","]",":","clone","src","\"","setup","rgb","后","tutorials","、","类似","它","收到","发送数据","独立","词","ros2","渲染","东西","不然","组成","function","机器人","应该","文章","，","只要","create","块","里","(","数据传输","小编","啦","str","比如","and","rclcpp","数据类型","chrono","cpp","用户","模型","标准","是从","dev","subscription","functional","成为","魔性","为例","个","shutdown","千丝","运行","间","但","图像","会先","也","run","话题","特性","argv","作为","guyuehome","i","install","英文","msg","唯一","：","排版","的","自行","+","你","和","基本原理",">","有","画面","报纸"," ","wall","3","某","设备","subclass","发出","等等","t","$","各种","”","callback","this","中","hpp","本身","把","如果","string","例程","这样","复杂","数据","似乎","auto","积木","更","ms","编程","1","timerbase","无法","无关","方式","spin","要求","他会","区分","char","指","传感","让","publish","随处可见","uses","literals","++","p","每","控制","得","被","关系","示例","s","我们","size","描述","private","知识","main","视频","这里","一些","请","dds","了","数据结构","编程语言","msgs","从而","接口定义","因为","public","发布","大家","{","阅读","一篇","号","不知","publishing","memory","return","创建","开始","placeholders","colcon","逻辑","两个","像","流程","到","接下来","听说","解析","想象","想下",",","挺","可视","万缕","c","者","给","来看","接收数据","std","字符","}","第一次","并不知道","mkdir","同学","world","传递","优先","想","数量","编写","用","heard","接收","合适","生活","https","一份","不","要","感器","获取","data","某些","下载","完整","subscriber","平时","后缀","角度","build","参数","原理","显示","联系","publisher","ws","相机","bind","做","get","[","listener","听"],"title":"多节点话题通信","title_tokens":["话题","通信","多","节点"]},{"location":"hhp/3.1_%E5%A4%9A%E8%8A%82%E7%82%B9%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/#_1","text":"节点实现了机器人各种各样的功能，但这些功能并不是独立的，之间会有千丝万缕的联系，其中最重要的一种联系方式就是话题，它是 节点间传递数据的桥梁 。","text_tokens":["千丝万缕","是","各样","传递","机器人","其中","一种","功能","的","，","数据","有","重要","千丝","间"," ","但","节点","之间","万缕","方式","各种各样","了","传递数据","桥梁","这些","话题","各种","它","会","机器","并","联系","就是","。","独立","不是","实现","最","联系方式"],"title":"多节点话题通信","title_tokens":["话题","通信","多","节点"]},{"location":"hhp/3.1_%E5%A4%9A%E8%8A%82%E7%82%B9%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/#_2","text":"以两个机器人节点为例。A节点的功能是驱动相机这个硬件设备，获取得到相机拍摄的图像信息，B节点的功能是视频监控，将相机拍摄到的图像实时显示给用户查看。 大家可以想一下，这两个节点是不是必然存在某种关系？没错，节点A要将获取的图像数据传输给节点B，有了数据，节点B才能做这样可视化的渲染。 此时从节点A到节点B传递图像数据的方式，在ROS中，我们就称之为 话题 ，它作为一个桥梁，实现了节点之间某一个方向上的数据传输。","text_tokens":["是不是","据传","这样","可以","功能","驱动","数据","才能","一下","？","方式","就","没错","之为","以","它","机器","ros","实现","关系","查看","渲染","机器人","我们","，","实时","视频","节点","a","了","数据传输","拍摄","大家","用户","两个","方向","到","信息","为例","在","从","硬件","可视","之间","图像","此时","得到","给","话题","一个","存在","监控","上","作为","某种","。","不是","是","传递","想","的","将","称之为","这","有","b"," ","可视化","某","这个","设备","要","必然","获取","桥梁","显示","相机","中","做","传输"],"title":"通信模型","title_tokens":["通信模型","模型","通信"]},{"location":"hhp/3.1_%E5%A4%9A%E8%8A%82%E7%82%B9%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/#_3","text":"从话题本身的实现角度来看，使用了基于DDS的 发布/订阅模型 ，什么叫发布和订阅呢？ 话题数据传输的特性是从一个节点到另外一个节点，发送数据的对象称之为 发布者 ，接收数据的对象称之为 订阅者 ，每一个话题都需要有一个名字，传输的数据也需要有固定的数据类型。 打一个比方，大家平时应该也会看微信公众号，比如有一个公众号，它的名字叫做“古月居”，这个古月居就是话题名称，公众号的发布者是古月居的小编，他会把组织好的机器人知识排版成要求格式的公众号文章，发布出去，这个文章格式，就是话题的数据类型。如果大家对这个话题感兴趣，就可以订阅“古月居”，成为订阅者之后自然就可以收到古月居的公众号文章，没有订阅的话，也就无法收到。 类似这样的发布/订阅模型在生活中随处可见，比如订阅报纸、订阅杂志等等。","text_tokens":["如果","据传","这样","可以","数据","好","？","都","无法","订阅","的话","、","要求","类似","就","他会","基于","之为","它","可见","收到","随处可见","发布者","机器","就是","发送数据","每","什么","实现","居","在生活中","机器人","应该","文章","，","类型","古月","使用","成","知识","叫","节点","dds","呢","了","数据传输","小编","感兴","比如","发布","大家","数据类型","组织","另外","号","模型","杂志","自然","是从","格式","到","成为","固定","从","之后","没有","需要","名字","比方","微信","随处","对","也","者","话题","特性","来看","一个","接收数据","看","会","发送","。","是","排版","的","接收","兴趣","和","称之为","叫做","有","生活","报纸"," ","这个","对象","等等","“","平时","出去","角度","”","感兴趣","打","公众","名称","本身","传输","/","把"],"title":"发布/订阅模型","title_tokens":["订阅","/","发布","模型"]},{"location":"hhp/3.1_%E5%A4%9A%E8%8A%82%E7%82%B9%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/#_4","text":"大家再仔细想下这些可以订阅的东西，是不是并不是唯一的，我们每个人可以订阅很多公众号、报纸、杂志，这些公众号、报纸、杂志也可以被很多人订阅，没错，ROS里的话题也是一样，发布者和订阅者的数量并不是唯一的，可以称之为是多对多的通信模型。 因为话题是多对多的模型，发布控制指令的摇杆可以有一个，也可以有2个、3个，订阅控制指令的机器人可以有1个，也可以有2个、3个，大家可以想象一下这个画面，似乎还是挺魔性的，如果存在多个发送指令的节点，建议大家要 注意区分优先级 ，不然机器人可能不知道该听谁的了。","text_tokens":["如果","是不是","2","可以","指令","似乎","再","一下","1","控制指令","订阅","、","没错","区分","之为","仔细","这些","发布者","机器","ros","控制","可能","被","东西","不然","机器人","我们","每个","，","里","节点","了","摇杆","该","因为","发布","大家","并","号","模型","杂志","魔性","优先级","个","人","想象","想下","挺","很多","对","也","者","还是","话题","一个","存在","发送","。","不是","唯一","是","优先","数量","的","通信模型","和","称之为","有","画面","报纸"," ","3","这个","知道","不","要","注意","一样","多个","建议","多","谁","公众","通信","听"],"title":"多对多通信","title_tokens":["通信","多","对"]},{"location":"hhp/3.1_%E5%A4%9A%E8%8A%82%E7%82%B9%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/#_5","text":"话题通信还有一个特性，那就是异步，这个词可能有同学是第一次听说？所谓异步，只要是指发布者发出数据后，并不知道订阅者什么时候可以收到，类似古月居公众号发布一篇文章，你什么时候阅读的，古月居根本不知道，报社发出一份报纸，你什么时候收到，报社也是不知道的。这就叫做异步。 异步的特性也让话题更适合用于一些周期发布的数据，比如传感器的数据，运动控制的指令等等，如果某些逻辑性较强的指令，比如修改某一个参数，用话题传输就不太合适了。","text_tokens":["如果","太","可以","数据","指令","传感器","更","第一","？","后","订阅","类似","就","指","传感","根本","让","收到","发布者","就是","控制","词","什么","居","可能","较强","还有","文章","，","古月","只要","一些","了","比如","异步","发布","适合","阅读","一篇","号","不知","用于","周期","逻辑","那","听说","报社","逻辑性","也","者","话题","特性","一个","。","第一次","并不知道","时候","同学","一次","是","用","的","合适","你","叫做","这","有","报纸"," ","修改","某","这个","知道","一份","不","发出","感器","运动","等等","某些","参数","公众","通信","所谓","传输"],"title":"异步通信","title_tokens":["异步","通信"]},{"location":"hhp/3.1_%E5%A4%9A%E8%8A%82%E7%82%B9%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/#_6","text":"最后，既然是数据传输，发布者和订阅者就得统一数据的描述格式，不能一个说英文，一个理解成了中文。在ROS中，话题通信数据的描述格式称之为消息，对应编程语言中数据结构的概念。比如这里的一个图像数据，就会包含图像的长宽像素值、每个像素的RGB等等，在ROS中都有标准定义。 消息是ROS中的一种接口定义方式 ，与编程语言无关，我们也可以通过 .msg 后缀的文件自行定义，有了这样的接口，各种节点就像积木块一样，通过各种各样的接口进行拼接，组成复杂的机器人系统。","text_tokens":["说","各样","据传","这样","复杂","可以","数据","消息","积木","编程","都","与","定义","rgb","无关","订阅","方式","、","语言","就","像素","之为","对应","拼接","发布者","不能","机器","中文","ros","最后","得","系统","接口","组成","机器人","我们","既然","每个","，","描述","成","块","这里","值","节点",".","了","数据传输","数据结构","编程语言","概念","比如","接口定义","发布","标准","格式","像","通过","文件","进行","在","图像","各种各样","也","者","长宽","话题","一个","会","。","英文","msg","是","结构","一种","的","自行","和","称之为","有"," ","一样","包含","等等","后缀","各种","统一","通信","中","理解","传输"],"title":"消息接口","title_tokens":["消息","接口"]},{"location":"hhp/3.1_%E5%A4%9A%E8%8A%82%E7%82%B9%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/#_7","text":"了解了话题的基本原理，接下来我们就要开始编写代码啦。","text_tokens":["我们","基本","编写","的","，","接下来","下来","就要","基本原理","本原","代码","了","啦","接下","话题","原理","了解","。","开始"],"title":"编程方法","title_tokens":["编程","方法"]},{"location":"hhp/3.1_%E5%A4%9A%E8%8A%82%E7%82%B9%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/#_8","text":"请大家先按照这个流程创建工作空间、下载课程的例程代码，并进行编译。 $ mkdir –p dev_ws/src $ cd /userdata/dev_ws/src $ git clone https://gitee.com/guyuehome/togetherros_tutorials.git $ cd /userdata/dev_ws/ $ colcon build","text_tokens":["colcon","例程","按照","com","dev","流程","cd","userdata","的","，","–","进行","工作"," ","clone","https",":","src","编译","这个","togetherros","请",".","tutorials","代码","、","先","课程","_","下载","空间","$","gitee","大家","build","并","guyuehome","ws","p","。","git","mkdir","创建","/"],"title":"创建工作空间","title_tokens":["创建","工作","空间"]},{"location":"hhp/3.1_%E5%A4%9A%E8%8A%82%E7%82%B9%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/#_9","text":"编译成功后，我们尝试运行话题通信的Hello World例程，在这个例程中，我们会先创建一个发布者，发布话题“chatter”，周期发送“Hello World”这个字符串，消息类型是ROS中标准定义的String，再创建一个订阅者，订阅“chatter”这个话题，从而接收到“Hello World”这个字符串。 $ source /opt/tros/local_setup.bash $ source install/local_setup.bash $ ros2 run learning_topic_cpp talker $ ros2 run learning_topic_cpp listener 这就是TogetherROS系统中话题通信的方法，依然沿用了ROS2中话题通信的完整流程。","text_tokens":["string","opt","是","周期","标准","例程","我们","bash","流程","，","的","接收","消息","类型","到","topic","tros","沿用","在","成功","这","local","再","运行","方法"," ","编译","setup","这个","定义","source","后","togetherros","字符串","订阅",".","了","会先","chatter","者","“","_","从而","完整","run","talker","话题","$","发布","尝试","一个","”","learning","发送","发布者","字符","就是","ros","。","cpp","依然","通信","中","install","ros2","系统","创建","/","hello","listener","world"],"title":"运行示例程序","title_tokens":["示例","程序","运行"]},{"location":"hhp/3.1_%E5%A4%9A%E8%8A%82%E7%82%B9%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/#_10","text":"发布者的实现方法publisher_member_function.cpp： #include <chrono> #include <functional> #include <memory> #include <string> #include \"rclcpp/rclcpp.hpp\" #include \"std_msgs/msg/string.hpp\" using namespace std :: chrono_literals ; /* This example creates a subclass of Node and uses std::bind() to register a * member function as a callback from the timer. */ class MinimalPublisher : public rclcpp :: Node { public : MinimalPublisher () : Node ( \"minimal_publisher\" ), count_ ( 0 ) { publisher_ = this -> create_publisher < std_msgs :: msg :: String > ( \"topic\" , 10 ); timer_ = this -> create_wall_timer ( 500 ms , std :: bind ( & MinimalPublisher :: timer_callback , this )); } private : void timer_callback () { auto message = std_msgs :: msg :: String (); message . data = \"Hello, world! \" + std :: to_string ( count_ ++ ); RCLCPP_INFO ( this -> get_logger (), \"Publishing: '%s'\" , message . data . c_str ()); publisher_ -> publish ( message ); } rclcpp :: TimerBase :: SharedPtr timer_ ; rclcpp :: Publisher < std_msgs :: msg :: String >:: SharedPtr publisher_ ; size_t count_ ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < MinimalPublisher > ()); rclcpp :: shutdown (); return 0 ; } 订阅者的实现方法subscriber_member_function.cpp： #include <memory> #include \"rclcpp/rclcpp.hpp\" #include \"std_msgs/msg/string.hpp\" using std :: placeholders :: _1 ; class MinimalSubscriber : public rclcpp :: Node { public : MinimalSubscriber () : Node ( \"minimal_subscriber\" ) { subscription_ = this -> create_subscription < std_msgs :: msg :: String > ( \"topic\" , 10 , std :: bind ( & MinimalSubscriber :: topic_callback , this , _1 )); } private : void topic_callback ( const std_msgs :: msg :: String :: SharedPtr msg ) const { RCLCPP_INFO ( this -> get_logger (), \"I heard: '%s'\" , msg -> data . c_str ()); } rclcpp :: Subscription < std_msgs :: msg :: String >:: SharedPtr subscription_ ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < MinimalSubscriber > ()); rclcpp :: shutdown (); return 0 ; }","text_tokens":["string","500","node","of","topic","&","auto","timer","ms","]",":","1","\"","logger","timerbase","register","spin","订阅","%","char","publish","uses","发布者","'","literals","++","10","实现","function","from","s","size","private","class","main","create","a","minimalsubscriber",".","(","using","int","info","minimal","str","msgs","and","public","发布","rclcpp","{","chrono","namespace","cpp",";","make","publishing","memory","return","hello","placeholders","member","subscription","functional","#","void","shutdown","as",",","-","c","creates","_","者","the","argv","std","i","}","example","msg","argc",")","*","world","to","：","message","的","heard","+",">","shared","方法"," ","wall","sharedptr","init","subclass","!","const","data","t","subscriber","=","callback","0","this","publisher","bind","include","hpp","get","minimalpublisher","/","[","<","count"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"hhp/3.2_%E5%A4%9A%E8%8A%82%E7%82%B9%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1/","text":"多节点服务通信 话题通信可以实现多个ROS节点之间数据的单向传输，使用这种异步通信机制，发布者无法准确知道订阅者是否收到消息，本讲我们将一起学习ROS另外一种常用的通信方法—— 服务 ，可以实现类似 你问我答的同步通信 效果。 通信模型 在之前的课程中，我们通过一个节点驱动相机，发布图像话题，另外一个节点订阅图像话题，并实现对其中红色物体的识别，此时我们可以按照图像识别的频率，周期得到物体的位置。 这个位置信息可以继续发给机器人的上层应用使用，比如可以跟随目标运动，或者运动到目标位置附近。此时，我们并不需要这么高的频率一直订阅物体的位置，而是更希望在需要这个数据的时候，发一个查询的请求，然后尽快得到此时目标的最新位置。 这样的通信模型和话题单向传输有所不同，变成了发送一个请求，反馈一个应答的形式，好像是你问我答一样，这种通信机制在ROS中成为 服务，Service 。 客户端/服务器模型 从服务的实现机制上来看，这种你问我答的形式叫做 客户端/服务器模型 ，简称为CS模型，客户端在需要某些数据的时候，针对某个具体的服务，发送请求信息，服务器端收到请求之后，就会进行处理并反馈应答信息。 这种通信机制在生活中也很常见，比如我们经常浏览的各种网页，此时你的电脑浏览器就是客户端，通过域名或者各种操作，向网站服务器发送请求，服务器收到之后返回需要展现的页面数据。 同步通信 这个过程一般要求越快越好，假设服务器半天没有反应，你的浏览器一直转圈圈，那有可能是服务器宕机了，或者是网络不好，所以相比话题通信，在服务通信中，客户端可以通过接收到的应答信息，判断服务器端的状态，我们也称之为同步通信。 一对多通信 比如古月居这个网站，服务器是唯一存在的，并没有多个完全一样的古月居网站，但是可以访问古月居网站的客户端是不唯一的，大家每一个人都可以看到同样的界面。所以服务通信模型中，服务器端唯一，但客户端可以不唯一。 服务接口 和话题通信类似，服务通信的核心还是要传递数据，数据变成了两个部分，一个 请求的数据 ，比如请求苹果位置的命令，还有一个 反馈的数据 ，比如反馈苹果坐标位置的数据，这些数据和话题消息一样，在ROS中也是要标准定义的，话题使用.msg文件定义，服务使用的是.srv文件定义，后续我们会给大家介绍定义的方法。 编程方法 了解了服务通信的原理，接下来我们就要开始编写代码啦，我们尝试通过服务实现一个加法求解器的功能。 运行示例程序 当我们需要计算两个加数的求和结果时，就通过客户端节点，将两个加数封装成请求数据，针对服务“add_two_ints”发送出去，提供这个服务的服务器端节点，收到请求数据后，开始进行加法计算，并将求和结果封装成应答数据，反馈给客户端，之后客户端就可以得到想要的结果啦。 我们一起操作下这个例程。 $ source /opt/tros/local_setup.bash $ source install/local_setup.bash $ ros2 run learning_service_cpp server $ ros2 run learning_service_cpp client 2 3 话题和服务是最为常用的两种数据通信方法，前者适合传感器、控制指令等周期性、单向传输的数据，后者适合一问一答，同步性要求更高的数据，比如获取机器视觉识别到的目标位置。 代码解析 服务器端add_two_ints_server.cpp： #include \"rclcpp/rclcpp.hpp\" #include \"learning_service_cpp/srv/add_two_ints.hpp\" #include <memory> void add ( const std::shared_ptr<learning_service_cpp::srv::AddTwoInts::Request> request, std::shared_ptr<learning_service_cpp::srv::AddTwoInts::Response> response ) { response->sum = request->a + request->b ; RCLCPP_INFO ( rclcpp::get_logger ( \"rclcpp\" ) , \"Incoming request\\na: %ld\" \" b: %ld\" , request->a, request->b ) ; RCLCPP_INFO ( rclcpp::get_logger ( \"rclcpp\" ) , \"sending back response: [%ld]\" , ( long int ) response->sum ) ; } int main ( int argc, char **argv ) { rclcpp::init ( argc, argv ) ; std::shared_ptr<rclcpp::Node> node = rclcpp::Node::make_shared ( \"add_two_ints_server\" ) ; rclcpp::Service<learning_service_cpp::srv::AddTwoInts>::SharedPtr service = node->create_service<learning_service_cpp::srv::AddTwoInts> ( \"add_two_ints\" , & add ) ; RCLCPP_INFO ( rclcpp::get_logger ( \"rclcpp\" ) , \"Ready to add two ints.\" ) ; rclcpp::spin ( node ) ; rclcpp::shutdown () ; } 客户端add_two_ints_client.cpp： #include \"rclcpp/rclcpp.hpp\" #include \"learning_service_cpp/srv/add_two_ints.hpp\" #include <chrono> #include <cstdlib> #include <memory> using namespace std :: chrono_literals ; int main ( int argc , char ** argv ) { rclcpp :: init ( argc , argv ); if ( argc != 3 ) { RCLCPP_INFO ( rclcpp :: get_logger ( \"rclcpp\" ), \"usage: add_two_ints_client X Y\" ); return 1 ; } std :: shared_ptr < rclcpp :: Node > node = rclcpp :: Node :: make_shared ( \"add_two_ints_client\" ); rclcpp :: Client < learning_service_cpp :: srv :: AddTwoInts >:: SharedPtr client = node -> create_client < learning_service_cpp :: srv :: AddTwoInts > ( \"add_two_ints\" ); auto request = std :: make_shared < learning_service_cpp :: srv :: AddTwoInts :: Request > (); request -> a = atoll ( argv [ 1 ]); request -> b = atoll ( argv [ 2 ]); while ( ! client -> wait_for_service ( 1 s )) { if ( ! rclcpp :: ok ()) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"rclcpp\" ), \"Interrupted while waiting for the service. Exiting.\" ); return 0 ; } RCLCPP_INFO ( rclcpp :: get_logger ( \"rclcpp\" ), \"service not available, waiting again...\" ); } auto result = client -> async_send_request ( request ); // Wait for the result. if ( rclcpp :: spin_until_future_complete ( node , result ) == rclcpp :: FutureReturnCode :: SUCCESS ) { RCLCPP_INFO ( rclcpp :: get_logger ( \"rclcpp\" ), \"Sum: %ld\" , result . get () -> sum ); } else { RCLCPP_ERROR ( rclcpp :: get_logger ( \"rclcpp\" ), \"Failed to call service add_two_ints\" ); } rclcpp :: shutdown (); return 0 ; }","text_tokens":["x","务器","周期性","功能","指令","failed","定义","应用","订阅","就","想要","%","高","learning","发布者","机器","就是","ros","反馈","实现","居","在生活中","应答","async","还有","sending","使用","成","那有","client","位置","节点",".","相比","info","课程","int","ok","发","service","异步","尝试","浏览","最为","并","另外","namespace","加法",";","圈圈","命令","客户端","展现","通过","#","很","数据通","进行","void","就要","从","之后","没有","需要","下","之间","-","还是","会","目标","希望","if","。",")","单向","opt","to","求解","bash","exiting","处理","通信模型","叫做","local","b","方法","器","sharedptr","代码","—","转圈","two","cstdlib","success","之前","出去","我","0","通信","而是","include","atoll","继续","传输","服务器发送","interrupted","node","消息","&","not","有所","都","控制指令","经常","logger","source","add","y","之为","这些","可能","接口","数据通信","但是","按照","古月","下来","网络","tros","程序","物体","sum","a","当","宕机","传递数据","again","查询","简称","适合","了解","完全","make","error","周期","文件","信息","在","形式","人","...","图像识别","back","此时","对","接下","_","na","the","得到","一个","上","存在","发送","同样","result","计算","问","ready","时候","argc","*","是","一种","两种","将","频率","或者","称之为","\\","shared","提供","srv","知道","这个","init","!","const","运动","ld","一样","多个","“","后者","多","=","常见","跟随","浏览器","核心","本","加数","假设","using","/","<","wait","2","可以","其中","驱动","苹果","传感器","]",":","一直","\"","同步","setup","后","、","addtwoints","类似","long","状态","收到","越好","介绍","ros2","request","页面","机器人","，","server","然后","具体","判断","create","学习","视觉","until","变成","incoming","(","啦","操作","complete","比如","rclcpp","等","chrono","cpp","讲","模型","所以","标准","部分","红色","成为","识别","shutdown","运行","但","图像","这种","尽快","访问","也","run","话题","argv","install","一般","msg","ints","唯一","附近","：","某个","的","客户","+","求和","你","为","常用","和",">"," ","3","同步性","域名","$","反应","各种","”","中","发给","一对","hpp","半天","例程","这样","数据","cs","auto","更","答","编程","网站","1","无法","spin","要求","char","传感","literals","每","控制","服务器","过程","示例","s","我们","不好","越快越好","坐标","上层","main","有所不同","后续","call","了","针对","网页","返回","for","发布","越快","大家","是否","{","memory","return","开始","电脑","两个","usage","到","这么","接下来","解析","向",",","future","一问一答","并不需要","waiting","while","者","封装","给","来看","std","send","ptr","机制","最新","请求","}","一起","available","else","结果","传递","好像","编写","futurereturncode","接收","不同","界面","生活","服务","准确","看到","不","效果","要","服务器端","感器","获取","某些","时","原理","前者","相机","response","get","转圈圈","["],"title":"多节点服务通信","title_tokens":["服务","通信","多","节点"]},{"location":"hhp/3.2_%E5%A4%9A%E8%8A%82%E7%82%B9%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1/#_1","text":"话题通信可以实现多个ROS节点之间数据的单向传输，使用这种异步通信机制，发布者无法准确知道订阅者是否收到消息，本讲我们将一起学习ROS另外一种常用的通信方法—— 服务 ，可以实现类似 你问我答的同步通信 效果。","text_tokens":["我们","可以","一种","的","数据","，","消息","使用","你","将","常用","答","方法","学习"," ","准确","服务","同步","知道","节点","之间","无法","订阅","—","效果","这种","类似","多个","者","话题","异步","发布","我","是否","收到","机制","发布者","另外","ros","问","讲","。","通信","一起","实现","本","传输","单向"],"title":"多节点服务通信","title_tokens":["服务","通信","多","节点"]},{"location":"hhp/3.2_%E5%A4%9A%E8%8A%82%E7%82%B9%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1/#_2","text":"在之前的课程中，我们通过一个节点驱动相机，发布图像话题，另外一个节点订阅图像话题，并实现对其中红色物体的识别，此时我们可以按照图像识别的频率，周期得到物体的位置。 这个位置信息可以继续发给机器人的上层应用使用，比如可以跟随目标运动，或者运动到目标位置附近。此时，我们并不需要这么高的频率一直订阅物体的位置，而是更希望在需要这个数据的时候，发一个查询的请求，然后尽快得到此时目标的最新位置。 这样的通信模型和话题单向传输有所不同，变成了发送一个请求，反馈一个应答的形式，好像是你问我答一样，这种通信机制在ROS中成为 服务，Service 。","text_tokens":["这样","其中","可以","驱动","数据","更","答","有所","一直","应用","订阅","高","机器","ros","反馈","实现","应答","机器人","我们","按照","，","使用","然后","上层","有所不同","位置","物体","节点","变成","了","课程","查询","比如","发","service","发布","并","另外","模型","周期","红色","到","这么","通过","成为","识别","信息","在","形式","需要","图像识别","图像","这种","并不需要","此时","对","尽快","得到","话题","一个","目标","希望","最新","发送","机制","请求","。","问","时候","单向","是","好像","附近","的","不同","通信模型","你","频率","或者","和"," ","服务","这个","运动","一样","之前","我","跟随","相机","通信","中","发给","而是","继续","传输"],"title":"通信模型","title_tokens":["通信模型","模型","通信"]},{"location":"hhp/3.2_%E5%A4%9A%E8%8A%82%E7%82%B9%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1/#_3","text":"从服务的实现机制上来看，这种你问我答的形式叫做 客户端/服务器模型 ，简称为CS模型，客户端在需要某些数据的时候，针对某个具体的服务，发送请求信息，服务器端收到请求之后，就会进行处理并反馈应答信息。 这种通信机制在生活中也很常见，比如我们经常浏览的各种网页，此时你的电脑浏览器就是客户端，通过域名或者各种操作，向网站服务器发送请求，服务器收到之后返回需要展现的页面数据。","text_tokens":["务器","电脑","页面","我们","某个","处理","服务器发送","客户端","的","，","数据","cs","很","客户","通过","进行","信息","展现","你","为","形式","在","从","答","叫做","具体","生活","或者","之后","向"," ","需要","服务","网站","经常","这种","服务器端","就","针对","此时","操作","简称","某些","也","网页","模型","域名","返回","比如","来看","各种","我","上","收到","会","常见","机制","发送","并","浏览","就是","请求","应答","问","。","浏览器","服务器","反馈","通信","实现","在生活中","时候","/"],"title":"客户端/服务器模型","title_tokens":["务器","服务器","模型","服务","客户端","客户","/"]},{"location":"hhp/3.2_%E5%A4%9A%E8%8A%82%E7%82%B9%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1/#_4","text":"这个过程一般要求越快越好，假设服务器半天没有反应，你的浏览器一直转圈圈，那有可能是服务器宕机了，或者是网络不好，所以相比话题通信，在服务通信中，客户端可以通过接收到的应答信息，判断服务器端的状态，我们也称之为同步通信。","text_tokens":["务器","半天","是","不好","我们","所以","可以","越快越好","客户端","，","的","通过","接收","到","客户","网络","信息","你","在","那有","或者","称之为","判断","没有","一直","服务","同步","这个","宕机","要求","了","转圈","相比","服务器端","也","之为","话题","状态","反应","越快","越好","浏览","浏览器","应答","。","服务器","通信","中","可能","过程","一般","假设","转圈圈","圈圈"],"title":"同步通信","title_tokens":["同步","通信"]},{"location":"hhp/3.2_%E5%A4%9A%E8%8A%82%E7%82%B9%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1/#_5","text":"比如古月居这个网站，服务器是唯一存在的，并没有多个完全一样的古月居网站，但是可以访问古月居网站的客户端是不唯一的，大家每一个人都可以看到同样的界面。所以服务通信模型中，服务器端唯一，但客户端可以不唯一。","text_tokens":["唯一","务器","是","但是","可以","客户端","，","的","古月","客户","通信模型","界面","人","没有","网站","服务","都","但","看到","这个","不","服务器端","一样","访问","多个","模型","比如","一个","存在","大家","同样","并","完全","每","。","服务器","通信","中","居","所以"],"title":"一对多通信","title_tokens":["一对","通信","多"]},{"location":"hhp/3.2_%E5%A4%9A%E8%8A%82%E7%82%B9%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1/#_6","text":"和话题通信类似，服务通信的核心还是要传递数据，数据变成了两个部分，一个 请求的数据 ，比如请求苹果位置的命令，还有一个 反馈的数据 ，比如反馈苹果坐标位置的数据，这些数据和话题消息一样，在ROS中也是要标准定义的，话题使用.msg文件定义，服务使用的是.srv文件定义，后续我们会给大家介绍定义的方法。","text_tokens":["还有","是","传递","部分","标准","我们","两个","命令","坐标","，","的","数据","消息","文件","苹果","使用","在","和","方法","位置"," ","服务","srv","定义","后续","变成",".","要","了","类似","传递数据","一样","也","这些","比如","还是","话题","给","一个","大家","介绍","会","请求","ros","。","核心","反馈","通信","中","msg"],"title":"服务接口","title_tokens":["服务","接口"]},{"location":"hhp/3.2_%E5%A4%9A%E8%8A%82%E7%82%B9%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1/#_7","text":"了解了服务通信的原理，接下来我们就要开始编写代码啦，我们尝试通过服务实现一个加法求解器的功能。","text_tokens":["求解","我们","编写","功能","的","，","接下来","通过","下来","就要","器","服务","代码","了","啦","接下","尝试","一个","原理","了解","加法","。","通信","实现","开始"],"title":"编程方法","title_tokens":["编程","方法"]},{"location":"hhp/3.2_%E5%A4%9A%E8%8A%82%E7%82%B9%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1/#_8","text":"当我们需要计算两个加数的求和结果时，就通过客户端节点，将两个加数封装成请求数据，针对服务“add_two_ints”发送出去，提供这个服务的服务器端节点，收到请求数据后，开始进行加法计算，并将求和结果封装成应答数据，反馈给客户端，之后客户端就可以得到想要的结果啦。 我们一起操作下这个例程。 $ source /opt/tros/local_setup.bash $ source install/local_setup.bash $ ros2 run learning_service_cpp server $ ros2 run learning_service_cpp client 2 3 话题和服务是最为常用的两种数据通信方法，前者适合传感器、控制指令等周期性、单向传输的数据，后者适合一问一答，同步性要求更高的数据，比如获取机器视觉识别到的目标位置。","text_tokens":["务器","例程","2","周期性","可以","数据","指令","传感器","更","控制指令","setup","同步","source","后","add","、","要求","就","想要","传感","高","收到","learning","机器","控制","服务器","反馈","ros2","应答","数据通信","我们","，","server","tros","成","client","视觉","位置","节点","当",".","针对","啦","操作","比如","service","等","适合","最为","并","加法","cpp","开始","周期","两个","客户端","到","通过","识别","数据通","进行","之后","需要","下","一问一答","_","封装","得到","给","run","话题","目标","发送","请求","计算","。","一起","install","单向","ints","opt","结果","是","bash","的","两种","客户","求和","将","和","常用","local","提供","方法"," ","服务","3","这个","服务器端","感器","获取","two","同步性","时","“","后者","$","出去","”","前者","通信","加数","传输","/"],"title":"运行示例程序","title_tokens":["示例","程序","运行"]},{"location":"hhp/3.2_%E5%A4%9A%E8%8A%82%E7%82%B9%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1/#_9","text":"服务器端add_two_ints_server.cpp： #include \"rclcpp/rclcpp.hpp\" #include \"learning_service_cpp/srv/add_two_ints.hpp\" #include <memory> void add ( const std::shared_ptr<learning_service_cpp::srv::AddTwoInts::Request> request, std::shared_ptr<learning_service_cpp::srv::AddTwoInts::Response> response ) { response->sum = request->a + request->b ; RCLCPP_INFO ( rclcpp::get_logger ( \"rclcpp\" ) , \"Incoming request\\na: %ld\" \" b: %ld\" , request->a, request->b ) ; RCLCPP_INFO ( rclcpp::get_logger ( \"rclcpp\" ) , \"sending back response: [%ld]\" , ( long int ) response->sum ) ; } int main ( int argc, char **argv ) { rclcpp::init ( argc, argv ) ; std::shared_ptr<rclcpp::Node> node = rclcpp::Node::make_shared ( \"add_two_ints_server\" ) ; rclcpp::Service<learning_service_cpp::srv::AddTwoInts>::SharedPtr service = node->create_service<learning_service_cpp::srv::AddTwoInts> ( \"add_two_ints\" , & add ) ; RCLCPP_INFO ( rclcpp::get_logger ( \"rclcpp\" ) , \"Ready to add two ints.\" ) ; rclcpp::spin ( node ) ; rclcpp::shutdown () ; } 客户端add_two_ints_client.cpp： #include \"rclcpp/rclcpp.hpp\" #include \"learning_service_cpp/srv/add_two_ints.hpp\" #include <chrono> #include <cstdlib> #include <memory> using namespace std :: chrono_literals ; int main ( int argc , char ** argv ) { rclcpp :: init ( argc , argv ); if ( argc != 3 ) { RCLCPP_INFO ( rclcpp :: get_logger ( \"rclcpp\" ), \"usage: add_two_ints_client X Y\" ); return 1 ; } std :: shared_ptr < rclcpp :: Node > node = rclcpp :: Node :: make_shared ( \"add_two_ints_client\" ); rclcpp :: Client < learning_service_cpp :: srv :: AddTwoInts >:: SharedPtr client = node -> create_client < learning_service_cpp :: srv :: AddTwoInts > ( \"add_two_ints\" ); auto request = std :: make_shared < learning_service_cpp :: srv :: AddTwoInts :: Request > (); request -> a = atoll ( argv [ 1 ]); request -> b = atoll ( argv [ 2 ]); while ( ! client -> wait_for_service ( 1 s )) { if ( ! rclcpp :: ok ()) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"rclcpp\" ), \"Interrupted while waiting for the service. Exiting.\" ); return 0 ; } RCLCPP_INFO ( rclcpp :: get_logger ( \"rclcpp\" ), \"service not available, waiting again...\" ); } auto result = client -> async_send_request ( request ); // Wait for the result. if ( rclcpp :: spin_until_future_complete ( node , result ) == rclcpp :: FutureReturnCode :: SUCCESS ) { RCLCPP_INFO ( rclcpp :: get_logger ( \"rclcpp\" ), \"Sum: %ld\" , result . get () -> sum ); } else { RCLCPP_ERROR ( rclcpp :: get_logger ( \"rclcpp\" ), \"Failed to call service add_two_ints\" ); } rclcpp :: shutdown (); return 0 ; }","text_tokens":["x","务器","wait","2","interrupted","node","&","auto","]","not",":","failed","1","\"","logger","spin","add","addtwoints","y","%","char","long","learning","literals","服务器","request","async","sending","s","server","main","client","create","until","sum","a","incoming",".","(","call","int","info","ok","again","complete","service","for","rclcpp","{","chrono","namespace","cpp",";","make","memory","return","error","usage","客户端","#","void","shutdown",",","...","back","-","future","waiting","while","_","na","the","argv","std","send","ptr","result","if","}","ready","argc","available",")","*","else","ints","to","：","exiting","futurereturncode","客户","+","\\",">","shared","b"," ","服务","sharedptr","3","srv","init","!","服务器端","const","ld","two","cstdlib","success","=","0","response","include","atoll","hpp","get","using","/","[","<"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"hhp/3.3_%E5%A4%9A%E8%8A%82%E7%82%B9%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1/","text":"多节点动作通信 机器人是一个复杂的智能系统，并不仅仅是键盘遥控运动、识别某个目标这么简单，我们需要实现的是送餐、送货、分拣等满足具体场景需求的机器人。 在这些应用功能的实现中，另外一种ROS通信机制也会被常常用到——那就是 动作 。从这个名字上就可以很好理解这个概念的含义，这种通信机制的目的就是便于 对机器人某一完整行为的流程进行管理 。 通信模型 举个例子，比如我们想让机器人转个圈，这肯定不是一下就可以完成的，机器人得一点一点旋转，直到360度才能结束，假设机器人并不在我们眼前，发出指令后，我们根本不知道机器人到底有没有开始转圈，转到哪里了？ OK，现在我们需要的是一个反馈，比如每隔1s，告诉我们当前转到多少度了，10度、20度、30度，一段时间之后，到了360度，再发送一个信息，表示动作执行完成。 这样一个需要执行一段时间的行为，使用动作的通信机制就更为合适，就像装了一个进度条，我们可以随时把控进度，如果运动过程当中，我们还可以随时发送一个取消运动的命令。 客户端/服务器模型 动作和服务类似，使用的也是客户端和服务器模型，客户端发送动作的目标，想让机器人干什么，服务器端执行动作过程， 控制机器人达到运动的目标，同时周期反馈动作执行过程中的状态。 客户端发送一个运动的目标，想让机器人动起来，服务器端收到之后，就开始控制机器人运动，一边运动，一边反馈当前的状态，如果是一个导航动作，这个反馈可能是当前所处的坐标，如果是机械臂抓取，这个反馈可能又是机械臂的实时姿态。当运动执行结束后，服务器再反馈一个动作结束的信息。整个通信过程就此结束。 一对多通信 和服务一样，动作通信中的客户端可以有多个，大家都可以发送运动命令，但是服务器端只能有一个，毕竟只有一个机器人，先执行完成一个动作，才能执行下一个动作。 同步通信 既然有反馈，那动作也是一种同步通信机制，之前我们也介绍过，动作过程中的数据通信接口，使用.action文件进行定义。 由服务和话题合成 大家再仔细看下上边的动图，是不是还会发现一个隐藏的秘密。 动作的三个通信模块，竟然有两个是服务，一个是话题，当客户端发送运动目标时，使用的是服务的请求调用，服务器端也会反馈一个应带，表示收到命令。动作的反馈过程，其实就是一个话题的周期发布，服务器端是发布者，客户端是订阅者。 没错，动作是一种应用层的通信机制，其底层就是基于话题和服务来实现的。 编程方法 相比之前话题和服务的程序，动作通信的例程相对较长，我们一起来运行并分析一下。 运行示例程序 $ source /opt/tros/local_setup.bash $ source install/local_setup.bash $ ros2 run learning_action_cpp server $ ros2 run learning_action_cpp client 代码解析 动作的服务器fibonacci_action_server.cpp： #include <inttypes.h> #include <memory> #include \"learning_action_cpp/action/fibonacci.hpp\" #include \"rclcpp/rclcpp.hpp\" // TODO(jacobperron): Remove this once it is included as part of 'rclcpp.hpp' #include \"rclcpp_action/rclcpp_action.hpp\" class MinimalActionServer : public rclcpp :: Node { public : using Fibonacci = learning_action_cpp :: action :: Fibonacci ; using GoalHandleFibonacci = rclcpp_action :: ServerGoalHandle < Fibonacci > ; explicit MinimalActionServer ( const rclcpp :: NodeOptions & options = rclcpp :: NodeOptions ()) : Node ( \"minimal_action_server\" , options ) { using namespace std :: placeholders ; this -> action_server_ = rclcpp_action :: create_server < Fibonacci > ( this -> get_node_base_interface (), this -> get_node_clock_interface (), this -> get_node_logging_interface (), this -> get_node_waitables_interface (), \"fibonacci\" , std :: bind ( & MinimalActionServer :: handle_goal , this , _1 , _2 ), std :: bind ( & MinimalActionServer :: handle_cancel , this , _1 ), std :: bind ( & MinimalActionServer :: handle_accepted , this , _1 )); } private : rclcpp_action :: Server < Fibonacci >:: SharedPtr action_server_ ; rclcpp_action :: GoalResponse handle_goal ( const rclcpp_action :: GoalUUID & uuid , std :: shared_ptr < const Fibonacci :: Goal > goal ) { RCLCPP_INFO ( this -> get_logger (), \"Received goal request with order %d\" , goal -> order ); ( void ) uuid ; // Let's reject sequences that are over 9000 if ( goal -> order > 9000 ) { return rclcpp_action :: GoalResponse :: REJECT ; } return rclcpp_action :: GoalResponse :: ACCEPT_AND_EXECUTE ; } rclcpp_action :: CancelResponse handle_cancel ( const std :: shared_ptr < GoalHandleFibonacci > goal_handle ) { RCLCPP_INFO ( this -> get_logger (), \"Received request to cancel goal\" ); ( void ) goal_handle ; return rclcpp_action :: CancelResponse :: ACCEPT ; } void execute ( const std :: shared_ptr < GoalHandleFibonacci > goal_handle ) { RCLCPP_INFO ( this -> get_logger (), \"Executing goal\" ); rclcpp :: Rate loop_rate ( 1 ); const auto goal = goal_handle -> get_goal (); auto feedback = std :: make_shared < Fibonacci :: Feedback > (); auto & sequence = feedback -> sequence ; sequence . push_back ( 0 ); sequence . push_back ( 1 ); auto result = std :: make_shared < Fibonacci :: Result > (); for ( int i = 1 ; ( i < goal -> order ) && rclcpp :: ok (); ++ i ) { // Check if there is a cancel request if ( goal_handle -> is_canceling ()) { result -> sequence = sequence ; goal_handle -> canceled ( result ); RCLCPP_INFO ( this -> get_logger (), \"Goal Canceled\" ); return ; } // Update sequence sequence . push_back ( sequence [ i ] + sequence [ i - 1 ]); // Publish feedback goal_handle -> publish_feedback ( feedback ); RCLCPP_INFO ( this -> get_logger (), \"Publish Feedback\" ); loop_rate . sleep (); } // Check if goal is done if ( rclcpp :: ok ()) { result -> sequence = sequence ; goal_handle -> succeed ( result ); RCLCPP_INFO ( this -> get_logger (), \"Goal Succeeded\" ); } } void handle_accepted ( const std :: shared_ptr < GoalHandleFibonacci > goal_handle ) { using namespace std :: placeholders ; // this needs to return quickly to avoid blocking the executor, so spin up a new thread std :: thread { std :: bind ( & MinimalActionServer :: execute , this , _1 ), goal_handle }. detach (); } }; // class MinimalActionServer int main ( int argc , char ** argv ) { rclcpp :: init ( argc , argv ); auto action_server = std :: make_shared < MinimalActionServer > (); rclcpp :: spin ( action_server ); rclcpp :: shutdown (); return 0 ; } 动作的客户端fibonacci_action_client.cpp： #include <inttypes.h> #include <memory> #include <string> #include <iostream> #include \"learning_action_cpp/action/fibonacci.hpp\" #include \"rclcpp/rclcpp.hpp\" // TODO ( jacobperron ) : Remove this once it is included as part of 'rclcpp.hpp' #include \"rclcpp_action/rclcpp_action.hpp\" class MinimalActionClient : public rclcpp::Node { public: using Fibonacci = learning_action_cpp::action::Fibonacci ; using GoalHandleFibonacci = rclcpp_action::ClientGoalHandle<Fibonacci> ; explicit MinimalActionClient ( const rclcpp::NodeOptions & node_options = rclcpp::NodeOptions ()) : Node ( \"minimal_action_client\" , node_options ) , goal_done_ ( false ) { this->client_ptr_ = rclcpp_action::create_client<Fibonacci> ( this->get_node_base_interface () , this->get_node_graph_interface () , this->get_node_logging_interface () , this->get_node_waitables_interface () , \"fibonacci\" ) ; this->timer_ = this->create_wall_timer ( std::chrono::milliseconds ( 500 ) , std::bind ( & MinimalActionClient::send_goal, this )) ; } bool is_goal_done () const { return this->goal_done_ ; } void send_goal () { using namespace std::placeholders ; this->timer_->cancel () ; this->goal_done_ = false ; if ( !this->client_ptr_ ) { RCLCPP_ERROR ( this->get_logger () , \"Action client not initialized\" ) ; } if ( !this->client_ptr_->wait_for_action_server ( std::chrono::seconds ( 10 ))) { RCLCPP_ERROR ( this->get_logger () , \"Action server not available after waiting\" ) ; this->goal_done_ = true ; return ; } auto goal_msg = Fibonacci::Goal () ; goal_msg.order = 10 ; RCLCPP_INFO ( this->get_logger () , \"Sending goal\" ) ; auto send_goal_options = rclcpp_action::Client<Fibonacci>::SendGoalOptions () ; send_goal_options.goal_response_callback = std::bind ( & MinimalActionClient::goal_response_callback, this, _1 ) ; send_goal_options.feedback_callback = std::bind ( & MinimalActionClient::feedback_callback, this, _1, _2 ) ; send_goal_options.result_callback = std::bind ( & MinimalActionClient::result_callback, this, _1 ) ; auto goal_handle_future = this->client_ptr_->async_send_goal ( goal_msg, send_goal_options ) ; } private: rclcpp_action::Client<Fibonacci>::SharedPtr client_ptr_ ; rclcpp::TimerBase::SharedPtr timer_ ; bool goal_done_ ; void goal_response_callback ( std::shared_future<GoalHandleFibonacci::SharedPtr> future ) { auto goal_handle = future.get () ; if ( !goal_handle ) { RCLCPP_ERROR ( this->get_logger () , \"Goal was rejected by server\" ) ; } else { RCLCPP_INFO ( this->get_logger () , \"Goal accepted by server, waiting for result\" ) ; } } void feedback_callback ( GoalHandleFibonacci::SharedPtr, const std::shared_ptr<const Fibonacci::Feedback> feedback ) { RCLCPP_INFO ( this->get_logger () , \"Next number in sequence received: %\" PRId32, feedback->sequence.back ()) ; } void result_callback ( const GoalHandleFibonacci::WrappedResult & result ) { this->goal_done_ = true ; switch ( result.code ) { case rclcpp_action::ResultCode::SUCCEEDED: break ; case rclcpp_action::ResultCode::ABORTED: RCLCPP_ERROR ( this->get_logger () , \"Goal was aborted\" ) ; return ; case rclcpp_action::ResultCode::CANCELED: RCLCPP_ERROR ( this->get_logger () , \"Goal was canceled\" ) ; return ; default: RCLCPP_ERROR ( this->get_logger () , \"Unknown result code\" ) ; return ; } RCLCPP_INFO ( this->get_logger () , \"Result received\" ) ; for ( auto number : result.result->sequence ) { RCLCPP_INFO ( this->get_logger () , \"%\" PRId32, number ) ; } } } ; // class MinimalActionClient int main ( int argc, char ** argv ) { rclcpp::init ( argc, argv ) ; auto action_client = std::make_shared<MinimalActionClient> () ; while ( !action_client->is_goal_done ()) { rclcpp::spin_some ( action_client ) ; } rclcpp::shutdown () ; return 0 ; }","text_tokens":["wrappedresult","务器","是不是","after","500","功能","动","指令","options","才能","一下","好","定义","应用","订阅","臂","就","%","仔细","便于","根本","it","例子","learning","发布者","机器","就是","一点一点","场景","ros","反馈","10","实现","什么","一边","async","sending","execute","使用","client","nodeoptions","1s","通信接口","节点",".","ok","相比","minimal","info","int","cancel","graph","namespace","并","另外",";","常常","命令","简单","客户端","很","#","interface","进行","发现","分拣","应带","void","从","as","之后","没有","需要","下","同时","三个","-","update","seconds","看","会","不仅仅","目标","loop","if","。",")","就此结束","opt","to","number","bash","隐藏","code","uuid","通信模型","执行","local","方法","resultcode","直到","sharedptr","某一","还会","h","代码","—","转圈","let","到底","之前","milliseconds","更为","inttypes","aborted","0","通信","include","理解","眼前","取消","应用层","node","of","base","&","用到","not","再","？","都","logger","source","先","没错","基于","这些","explicit","控","next","'","遥控","sequences","true","可能","系统","接口","20","起来","但是","既然","实时","tros","class","todo","程序","a","当","一","度","概念","d","so","调用","告诉","that","case","make","合成","多少度","goaluuid","error","break","周期","那","由","文件","accepted","信息","在","进度条","9000","名字","waitables","done","back","动作","对","较长","_","the","succeeded","order","rate","一个","上","圈","发送","result","不是","detach","argc","*","sequence","旋转","是","fibonacci","干什么","一种","succeed","clientgoalhandle","part","这","shared","这个","知道","init","!","const","运动","一样","姿态","多个","default","多","=","false","switch","送货","iostream","360","假设","using","竟然","/","<","up","wait","2","可以","goalresponse","timer","相对","&&","抓取","]",":","\"","同步","setup","executing","后","was","、","动图","类似","included","feedback","所处","avoid","管理","状态","收到","介绍","导航","30","ros2","request","there","servergoalhandle","机器人","完成","remove","push","，","server","minimalactionserver","含义","具体","jacobperron","create","sleep","(","minimalactionclient","肯定","随时","比如","and","表示","rclcpp","等","chrono","目的","are","cpp","canceling","段时间","送餐","行为","in","模型","每隔","结束","识别","其实","needs","shutdown","sendgoaloptions","运行","这种","只有","by","也","run","话题","argv","当前","i","install","仅仅","msg","需求","满足","：","某个","goal","的","_-","客户","+","和",">","有"," ","整个","wall","一点","发出","多少","$","callback","prid32","this","装","中","一对","hpp","bool","initialized","把","如果","string","例程","复杂","这样","只能","数据","auto","编程","1","handle","timerbase","其","spin","达到","模块","char","new","分析","reject","logging","让","publish","some","++","控制","服务器","thread","得","被","过程","还","上边","示例","s","我们","blocking","坐标","is","private","一段时间","main","进度","cancelresponse","转","一段","unknown","了","有没有","for","public","发布","大家","{","当中","memory","return","rejected","开始","placeholders","两个","举个","像","流程","到","这么","over","解析","check",",","现在","future","waiting","canceled","者","while","std","不仅","send","ptr","机制","quickly","请求","}","available","else","键盘","accept","想","毕竟","with","action","来","又","合适","秘密","executor","received","转个","过","goalhandlefibonacci","服务","once","智能","不","服务器端","机械","clock","时","完整","哪里","就此","底层","时间","bind","response","get","["],"title":"多节点动作通信","title_tokens":["动作","通信","多","节点"]},{"location":"hhp/3.3_%E5%A4%9A%E8%8A%82%E7%82%B9%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1/#_1","text":"机器人是一个复杂的智能系统，并不仅仅是键盘遥控运动、识别某个目标这么简单，我们需要实现的是送餐、送货、分拣等满足具体场景需求的机器人。 在这些应用功能的实现中，另外一种ROS通信机制也会被常常用到——那就是 动作 。从这个名字上就可以很好理解这个概念的含义，这种通信机制的目的就是便于 对机器人某一完整行为的流程进行管理 。","text_tokens":["是","键盘","需求","机器人","我们","复杂","满足","常常","某个","简单","一种","功能","那","的","，","这么","可以","很","识别","流程","进行","分拣","在","从","含义","用到","具体","需要"," ","名字","好","这个","某一","应用","智能","、","—","这种","就","行为","运动","动作","对","也","这些","概念","完整","便于","管理","一个","不仅","等","上","会","不仅仅","目标","机制","目的","机器","并","另外","就是","场景","遥控","。","ros","通信","中","实现","送货","理解","仅仅","送餐","系统","被"],"title":"多节点动作通信","title_tokens":["动作","通信","多","节点"]},{"location":"hhp/3.3_%E5%A4%9A%E8%8A%82%E7%82%B9%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1/#_2","text":"举个例子，比如我们想让机器人转个圈，这肯定不是一下就可以完成的，机器人得一点一点旋转，直到360度才能结束，假设机器人并不在我们眼前，发出指令后，我们根本不知道机器人到底有没有开始转圈，转到哪里了？ OK，现在我们需要的是一个反馈，比如每隔1s，告诉我们当前转到多少度了，10度、20度、30度，一段时间之后，到了360度，再发送一个信息，表示动作执行完成。 这样一个需要执行一段时间的行为，使用动作的通信机制就更为合适，就像装了一个进度条，我们可以随时把控进度，如果运动过程当中，我们还可以随时发送一个取消运动的命令。","text_tokens":["如果","这样","可以","指令","再","才能","一下","？","后","、","就","让","根本","例子","控","机器","一点一点","反馈","30","10","得","过程","还","20","机器人","我们","完成","，","使用","一段时间","进度","转","1s","一段","了","肯定","ok","随时","度","比如","有没有","表示","当中","并","告诉","多少度","段时间","行为","开始","每隔","举个","像","命令","结束","到","信息","在","进度条","之后","没有","需要","现在","动作","一个","当前","圈","发送","机制","。","不是","旋转","是","想","的","合适","执行","转个","这"," ","直到","一点","知道","不","发出","转圈","运动","到底","多少","哪里","更为","时间","装","通信","眼前","360","取消","假设","把"],"title":"通信模型","title_tokens":["通信模型","模型","通信"]},{"location":"hhp/3.3_%E5%A4%9A%E8%8A%82%E7%82%B9%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1/#_3","text":"动作和服务类似，使用的也是客户端和服务器模型，客户端发送动作的目标，想让机器人干什么，服务器端执行动作过程， 控制机器人达到运动的目标，同时周期反馈动作执行过程中的状态。 客户端发送一个运动的目标，想让机器人动起来，服务器端收到之后，就开始控制机器人运动，一边运动，一边反馈当前的状态，如果是一个导航动作，这个反馈可能是当前所处的坐标，如果是机械臂抓取，这个反馈可能又是机械臂的实时姿态。当运动执行结束后，服务器再反馈一个动作结束的信息。整个通信过程就此结束。","text_tokens":["如果","就此结束","是","务器","周期","起来","机器人","想","干什么","坐标","客户端","，","的","动","实时","又","客户","结束","使用","信息","和","执行","抓取","再","之后"," ","整个","服务","同时","这个","后","当","达到","臂","类似","服务器端","就","机械","动作","运动","所处","姿态","也","状态","让","一个","就此","收到","当前","目标","发送","机器","导航","控制","。","服务器","反馈","通信","中","什么","可能","一边","过程","模型","开始"],"title":"客户端/服务器模型","title_tokens":["务器","服务器","模型","服务","客户端","客户","/"]},{"location":"hhp/3.3_%E5%A4%9A%E8%8A%82%E7%82%B9%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1/#_4","text":"和服务一样，动作通信中的客户端可以有多个，大家都可以发送运动命令，但是服务器端只能有一个，毕竟只有一个机器人，先执行完成一个动作，才能执行下一个动作。","text_tokens":["务器","但是","机器人","命令","可以","只能","毕竟","完成","客户端","，","的","客户","和","执行","有","才能","下","服务","都","先","服务器端","只有","动作","运动","一样","多个","一个","大家","发送","机器","。","服务器","通信","中"],"title":"一对多通信","title_tokens":["一对","通信","多"]},{"location":"hhp/3.3_%E5%A4%9A%E8%8A%82%E7%82%B9%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1/#_5","text":"既然有反馈，那动作也是一种同步通信机制，之前我们也介绍过，动作过程中的数据通信接口，使用.action文件进行定义。","text_tokens":["是","那","我们","既然","一种","，","的","数据","action","文件","进行","使用","过","有","同步","通信接口","定义",".","动作","也","之前","介绍","机制","。","反馈","通信","中","过程","接口"],"title":"同步通信","title_tokens":["同步","通信"]},{"location":"hhp/3.3_%E5%A4%9A%E8%8A%82%E7%82%B9%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1/#_6","text":"大家再仔细看下上边的动图，是不是还会发现一个隐藏的秘密。 动作的三个通信模块，竟然有两个是服务，一个是话题，当客户端发送运动目标时，使用的是服务的请求调用，服务器端也会反馈一个应带，表示收到命令。动作的反馈过程，其实就是一个话题的周期发布，服务器端是发布者，客户端是订阅者。 没错，动作是一种应用层的通信机制，其底层就是基于话题和服务来实现的。","text_tokens":["是","务器","周期","应用层","是不是","两个","命令","隐藏","一种","客户端","的","，","来","客户","使用","发现","秘密","应带","其实","和","有","再","下"," ","服务","三个","应用","还会","当","订阅","其","动图","服务器端","动作","模块","运动","没错","时","也","者","基于","仔细","话题","表示","一个","看","大家","收到","会","发布","底层","目标","发送","发布者","机制","调用","就是","请求","。","服务器","反馈","通信","不是","实现","过程","上边","竟然"],"title":"由服务和话题合成","title_tokens":["和","服务","合成","话题","由"]},{"location":"hhp/3.3_%E5%A4%9A%E8%8A%82%E7%82%B9%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1/#_7","text":"相比之前话题和服务的程序，动作通信的例程相对较长，我们一起来运行并分析一下。","text_tokens":["起来","例程","我们","的","，","相对","和","运行","一下","服务","程序","一","相比","动作","较长","之前","分析","话题","并","。","通信"],"title":"编程方法","title_tokens":["编程","方法"]},{"location":"hhp/3.3_%E5%A4%9A%E8%8A%82%E7%82%B9%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1/#_8","text":"$ source /opt/tros/local_setup.bash $ source install/local_setup.bash $ ros2 run learning_action_cpp server $ ros2 run learning_action_cpp client","text_tokens":["opt","bash","action","server","tros","local","client"," ","setup","source",".","_","run","$","learning","cpp","install","ros2","/"],"title":"运行示例程序","title_tokens":["示例","程序","运行"]},{"location":"hhp/3.3_%E5%A4%9A%E8%8A%82%E7%82%B9%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1/#_9","text":"动作的服务器fibonacci_action_server.cpp： #include <inttypes.h> #include <memory> #include \"learning_action_cpp/action/fibonacci.hpp\" #include \"rclcpp/rclcpp.hpp\" // TODO(jacobperron): Remove this once it is included as part of 'rclcpp.hpp' #include \"rclcpp_action/rclcpp_action.hpp\" class MinimalActionServer : public rclcpp :: Node { public : using Fibonacci = learning_action_cpp :: action :: Fibonacci ; using GoalHandleFibonacci = rclcpp_action :: ServerGoalHandle < Fibonacci > ; explicit MinimalActionServer ( const rclcpp :: NodeOptions & options = rclcpp :: NodeOptions ()) : Node ( \"minimal_action_server\" , options ) { using namespace std :: placeholders ; this -> action_server_ = rclcpp_action :: create_server < Fibonacci > ( this -> get_node_base_interface (), this -> get_node_clock_interface (), this -> get_node_logging_interface (), this -> get_node_waitables_interface (), \"fibonacci\" , std :: bind ( & MinimalActionServer :: handle_goal , this , _1 , _2 ), std :: bind ( & MinimalActionServer :: handle_cancel , this , _1 ), std :: bind ( & MinimalActionServer :: handle_accepted , this , _1 )); } private : rclcpp_action :: Server < Fibonacci >:: SharedPtr action_server_ ; rclcpp_action :: GoalResponse handle_goal ( const rclcpp_action :: GoalUUID & uuid , std :: shared_ptr < const Fibonacci :: Goal > goal ) { RCLCPP_INFO ( this -> get_logger (), \"Received goal request with order %d\" , goal -> order ); ( void ) uuid ; // Let's reject sequences that are over 9000 if ( goal -> order > 9000 ) { return rclcpp_action :: GoalResponse :: REJECT ; } return rclcpp_action :: GoalResponse :: ACCEPT_AND_EXECUTE ; } rclcpp_action :: CancelResponse handle_cancel ( const std :: shared_ptr < GoalHandleFibonacci > goal_handle ) { RCLCPP_INFO ( this -> get_logger (), \"Received request to cancel goal\" ); ( void ) goal_handle ; return rclcpp_action :: CancelResponse :: ACCEPT ; } void execute ( const std :: shared_ptr < GoalHandleFibonacci > goal_handle ) { RCLCPP_INFO ( this -> get_logger (), \"Executing goal\" ); rclcpp :: Rate loop_rate ( 1 ); const auto goal = goal_handle -> get_goal (); auto feedback = std :: make_shared < Fibonacci :: Feedback > (); auto & sequence = feedback -> sequence ; sequence . push_back ( 0 ); sequence . push_back ( 1 ); auto result = std :: make_shared < Fibonacci :: Result > (); for ( int i = 1 ; ( i < goal -> order ) && rclcpp :: ok (); ++ i ) { // Check if there is a cancel request if ( goal_handle -> is_canceling ()) { result -> sequence = sequence ; goal_handle -> canceled ( result ); RCLCPP_INFO ( this -> get_logger (), \"Goal Canceled\" ); return ; } // Update sequence sequence . push_back ( sequence [ i ] + sequence [ i - 1 ]); // Publish feedback goal_handle -> publish_feedback ( feedback ); RCLCPP_INFO ( this -> get_logger (), \"Publish Feedback\" ); loop_rate . sleep (); } // Check if goal is done if ( rclcpp :: ok ()) { result -> sequence = sequence ; goal_handle -> succeed ( result ); RCLCPP_INFO ( this -> get_logger (), \"Goal Succeeded\" ); } } void handle_accepted ( const std :: shared_ptr < GoalHandleFibonacci > goal_handle ) { using namespace std :: placeholders ; // this needs to return quickly to avoid blocking the executor, so spin up a new thread std :: thread { std :: bind ( & MinimalActionServer :: execute , this , _1 ), goal_handle }. detach (); } }; // class MinimalActionServer int main ( int argc , char ** argv ) { rclcpp :: init ( argc , argv ); auto action_server = std :: make_shared < MinimalActionServer > (); rclcpp :: spin ( action_server ); rclcpp :: shutdown (); return 0 ; } 动作的客户端fibonacci_action_client.cpp： #include <inttypes.h> #include <memory> #include <string> #include <iostream> #include \"learning_action_cpp/action/fibonacci.hpp\" #include \"rclcpp/rclcpp.hpp\" // TODO ( jacobperron ) : Remove this once it is included as part of 'rclcpp.hpp' #include \"rclcpp_action/rclcpp_action.hpp\" class MinimalActionClient : public rclcpp::Node { public: using Fibonacci = learning_action_cpp::action::Fibonacci ; using GoalHandleFibonacci = rclcpp_action::ClientGoalHandle<Fibonacci> ; explicit MinimalActionClient ( const rclcpp::NodeOptions & node_options = rclcpp::NodeOptions ()) : Node ( \"minimal_action_client\" , node_options ) , goal_done_ ( false ) { this->client_ptr_ = rclcpp_action::create_client<Fibonacci> ( this->get_node_base_interface () , this->get_node_graph_interface () , this->get_node_logging_interface () , this->get_node_waitables_interface () , \"fibonacci\" ) ; this->timer_ = this->create_wall_timer ( std::chrono::milliseconds ( 500 ) , std::bind ( & MinimalActionClient::send_goal, this )) ; } bool is_goal_done () const { return this->goal_done_ ; } void send_goal () { using namespace std::placeholders ; this->timer_->cancel () ; this->goal_done_ = false ; if ( !this->client_ptr_ ) { RCLCPP_ERROR ( this->get_logger () , \"Action client not initialized\" ) ; } if ( !this->client_ptr_->wait_for_action_server ( std::chrono::seconds ( 10 ))) { RCLCPP_ERROR ( this->get_logger () , \"Action server not available after waiting\" ) ; this->goal_done_ = true ; return ; } auto goal_msg = Fibonacci::Goal () ; goal_msg.order = 10 ; RCLCPP_INFO ( this->get_logger () , \"Sending goal\" ) ; auto send_goal_options = rclcpp_action::Client<Fibonacci>::SendGoalOptions () ; send_goal_options.goal_response_callback = std::bind ( & MinimalActionClient::goal_response_callback, this, _1 ) ; send_goal_options.feedback_callback = std::bind ( & MinimalActionClient::feedback_callback, this, _1, _2 ) ; send_goal_options.result_callback = std::bind ( & MinimalActionClient::result_callback, this, _1 ) ; auto goal_handle_future = this->client_ptr_->async_send_goal ( goal_msg, send_goal_options ) ; } private: rclcpp_action::Client<Fibonacci>::SharedPtr client_ptr_ ; rclcpp::TimerBase::SharedPtr timer_ ; bool goal_done_ ; void goal_response_callback ( std::shared_future<GoalHandleFibonacci::SharedPtr> future ) { auto goal_handle = future.get () ; if ( !goal_handle ) { RCLCPP_ERROR ( this->get_logger () , \"Goal was rejected by server\" ) ; } else { RCLCPP_INFO ( this->get_logger () , \"Goal accepted by server, waiting for result\" ) ; } } void feedback_callback ( GoalHandleFibonacci::SharedPtr, const std::shared_ptr<const Fibonacci::Feedback> feedback ) { RCLCPP_INFO ( this->get_logger () , \"Next number in sequence received: %\" PRId32, feedback->sequence.back ()) ; } void result_callback ( const GoalHandleFibonacci::WrappedResult & result ) { this->goal_done_ = true ; switch ( result.code ) { case rclcpp_action::ResultCode::SUCCEEDED: break ; case rclcpp_action::ResultCode::ABORTED: RCLCPP_ERROR ( this->get_logger () , \"Goal was aborted\" ) ; return ; case rclcpp_action::ResultCode::CANCELED: RCLCPP_ERROR ( this->get_logger () , \"Goal was canceled\" ) ; return ; default: RCLCPP_ERROR ( this->get_logger () , \"Unknown result code\" ) ; return ; } RCLCPP_INFO ( this->get_logger () , \"Result received\" ) ; for ( auto number : result.result->sequence ) { RCLCPP_INFO ( this->get_logger () , \"%\" PRId32, number ) ; } } } ; // class MinimalActionClient int main ( int argc, char ** argv ) { rclcpp::init ( argc, argv ) ; auto action_client = std::make_shared<MinimalActionClient> () ; while ( !action_client->is_goal_done ()) { rclcpp::spin_some ( action_client ) ; } rclcpp::shutdown () ; return 0 ; }","text_tokens":["string","up","务器","wait","wrappedresult","2","after","500","node","initialized","of","options","&","base","goalresponse","auto","timer","&&","]","not",":","1","handle","\"","logger","executing","timerbase","spin","was","included","feedback","%","avoid","char","new","reject","logging","it","publish","explicit","next","some","learning","'","++","服务器","sequences","thread","10","true","request","async","there","servergoalhandle","sending","s","execute","blocking","remove","push","is","server","minimalactionserver","private","class","main","todo","client","jacobperron","nodeoptions","create","cancelresponse","unknown","sleep","a",".","(","minimalactionclient","int","info","minimal","ok","cancel","d","and","for","public","so","rclcpp","{","graph","chrono","namespace","are","cpp","that",";","make","case","memory","canceling","return","in","goaluuid","rejected","error","break","placeholders","客户端","interface","#","accepted","over","void","check","needs","shutdown","as","sendgoaloptions",",","9000","waitables","done","back","-","future","动作","update","by","waiting","seconds","canceled","_","while","the","succeeded","order","rate","argv","std","send","ptr","quickly","loop","result","i","if","}","detach","argc","available","msg",")","*","sequence","else","to","number","accept","fibonacci","：","goal","with","code","的","action","succeed","uuid","_-","客户","clientgoalhandle","+","executor","received",">","part","shared","goalhandlefibonacci","resultcode"," ","wall","服务","sharedptr","init","!","h","once","const","clock","let","milliseconds","default","=","inttypes","false","aborted","callback","0","prid32","this","switch","bind","response","include","iostream","hpp","get","bool","using","/","[","<"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"hhp/3.4_%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/","text":"零拷贝数据传输 在传统操作系统的数据传输过程中，系统内部会在磁盘、内存、缓存中多次进行数据拷贝，每次都会占用CPU的资源，数据量小的时候还好，随着数据量的增加，CPU的开销也会持续增加，尤其是在机器人图像数据的应用中 ，经常会发生这种问题，导致CPU都在做数据拷贝，没有时间处理其他的应用功能了，直接的感觉就是处理卡顿。 零拷贝技术 针对这种问题，零拷贝技术应运而生。 零拷贝主要的任务就是避免CPU将数据从一块存储拷贝到另外一块存储，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效。 TogetherROS中就提供了灵活、高效的零拷贝功能，可以显著降低大尺寸数据的通信延时和CPU占用，具体有多显著呢，我们不妨进行一个测试。 TogetherROS零拷贝性能测试 我们使用TogetherROS系统内部集成的性能测试工具——performance_test，来评估下开启零拷贝前后的性能差异，这里我们传输的样本数据量是4M。 未开启零拷贝进行数据传输 $ ros2 run performance_test perf_test --reliable --keep-last --history-depth 10 -s 1 -m Array4m -r 100 --max-runtime 30 #未开启 开启零拷贝数据传输： $ ros2 run performance_test perf_test --zero-copy --reliable --keep-last --history-depth 10 -s 1 -m Array4m -r 100 --max-runtime 30 #开启 好的，测试已经跑完了，我们把结果放到这里，来分析一下。 在这个测试中，关键有四个指标： 时延，也就是消息从发布者到订阅者的传输时间。不开启零拷贝的情况下，平均为0.004912s，开启零拷贝之后，速度快了差不多40倍，平均为0.000180s。 CPU使用率，表示通信活动所占用的CPU时间，大家可以看这个utime指标，开启零拷贝之后时间有显著的提升，消耗CPU的资源少了。 驻留内存，包括通信过程中分配的内存和共享内存，是这个maxrss中的数据，开启零拷贝之后，占用的内存也更少。 样本统计，包括测试中发送、接收以及丢失的消息数量，是这组数据，依然是开启零拷贝之后性能更好。 通过测试，对于大数据通信来讲，零拷贝在CPU消耗、内存占用以及通信延迟抖动方面的性能都会更好。 这里只是便于大家感受零拷贝技术的效果，具体编程中如何使用零拷贝机制呢？ 编程开发 为了方便大家使用，TogetherROS针对零拷贝功能进行了封装，风格类似ROS2中话题通信的接口，还是话题通信一样的流程，我们只需要修改几个函数就可以实现啦。 运行例程 $ source /opt/tros/local_setup.bash $ source install/local_setup.bash $ ros2 run hbmem_pubsub talker $ ros2 run hbmem_pubsub listener 代码解析 发布者publisher_hbmem.cpp： #include <chrono> #include <functional> #include <memory> #include <string> #include \"rclcpp/rclcpp.hpp\" #include \"hbmem_pubsub/msg/sample_message.hpp\" using namespace std :: chrono_literals ; class MinimalHbmemPublisher : public rclcpp :: Node { public : MinimalHbmemPublisher () : Node ( \"minimal_hbmem_publisher\" ), count_ ( 0 ) { // 创建publisher_hbmem，topic为\"topic\"，QOS为KEEPLAST(10)，以及默认的可靠传输 publisher_ = this -> create_publisher_hbmem < hbmem_pubsub :: msg :: SampleMessage > ( \"topic\" , 10 ); // 定时器，每隔40毫秒调用一次timer_callback进行消息发送 timer_ = this -> create_wall_timer ( 40 ms , std :: bind ( & MinimalHbmemPublisher :: timer_callback , this )); } private : // 定时器回调函数 void timer_callback () { // 获取要发送的消息 auto loanedMsg = publisher_ -> borrow_loaned_message (); // 判断消息是否可用，可能出现获取消息失败导致消息不可用的情况 if ( loanedMsg . is_valid ()) { // 引用方式获取实际的消息 auto & msg = loanedMsg . get (); // 获取当前时间，单位为us auto time_now = std :: chrono :: duration_cast < std :: chrono :: microseconds > ( std :: chrono :: steady_clock :: now (). time_since_epoch ()). count (); // 对消息的index和time_stamp进行赋值 msg . index = count_ ; msg . time_stamp = time_now ; // 打印发送消息 RCLCPP_INFO ( this -> get_logger (), \"message: %d\" , msg . index ); publisher_ -> publish ( std :: move ( loanedMsg )); // 注意，发送后，loanedMsg已不可用 // 计数器加一 count_ ++ ; } else { // 获取消息失败，丢弃该消息 RCLCPP_INFO ( this -> get_logger (), \"Failed to get LoanMessage!\" ); } } // 定时器 rclcpp :: TimerBase :: SharedPtr timer_ ; // hbmem publisher rclcpp :: PublisherHbmem < hbmem_pubsub :: msg :: SampleMessage >:: SharedPtr publisher_ ; // 计数器 size_t count_ ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < MinimalHbmemPublisher > ()); rclcpp :: shutdown (); return 0 ; } 订阅者subscriber_hbmem.cpp： #include <memory> #include \"rclcpp/rclcpp.hpp\" #include \"hbmem_pubsub/msg/sample_message.hpp\" class MinimalHbmemSubscriber : public rclcpp :: Node { public : MinimalHbmemSubscriber () : Node ( \"minimal_hbmem_subscriber\" ) { // 创建subscription_hbmem，topic为\"sample\"，QOS为KEEPLAST(10)，以及默认的可靠传输 // 消息回调函数为topic_callback subscription_ = this -> create_subscription_hbmem < hbmem_pubsub :: msg :: SampleMessage > ( \"topic\" , 10 , std :: bind ( & MinimalHbmemSubscriber :: topic_callback , this , std :: placeholders :: _1 )); } private : // 消息回调函数 void topic_callback ( const hbmem_pubsub :: msg :: SampleMessage :: SharedPtr msg ) const { // 注意，msg只能在回调函数中使用，回调函数返回后，该消息就会被释放 // 获取当前时间 auto time_now = std :: chrono :: duration_cast < std :: chrono :: microseconds > ( std :: chrono :: steady_clock :: now (). time_since_epoch ()) . count (); // 计算延时并打印出来 RCLCPP_INFO ( this -> get_logger (), \"msg %d, time cost %dus\" , msg -> index , time_now - msg -> time_stamp ); } // hbmem subscription rclcpp :: SubscriptionHbmem < hbmem_pubsub :: msg :: SampleMessage >:: SharedPtr subscription_ ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < MinimalHbmemSubscriber > ()); rclcpp :: shutdown (); return 0 ; } 接口汇总 我们整理一下，与ROS2中的话题通信相比，TogetherROS带有零拷贝机制的话题通信接口是这样的。 在发布者中，我们可以使用PublisherHbmem来创建一个发布者对象，然后通过create_publisher_hbmem发布数据，而在订阅者中，SubscriptionHbmem用来创建一个订阅者对象，通过 create_subscription_hbmem订阅需要的数据，至于底层如何完成零拷贝的过程，都交给TogetherROS即可。","text_tokens":["评估","应运而生","utime","qos","据传","主要","功能","关键","其他","failed","一下","好","一类","minimalhbmemsubscriber","应用","订阅","就","100","%","便于","显著","发布者","机器","就是","方便","10","实现","publisherhbmem","回调","丢弃","传统","使用","通信接口","任务",".","int","info","minimal","相比","该","风格","4m","talker","cost","完","驻留","零","reliable","namespace","另外","依然","用率",";","time","引用","简单","通过","#","数据通","进行","void","从","占用","之后","没有","下","需要","拷贝到","感觉","togetherros","-","专注","还是","minimalhbmempublisher","速度","看","会","if","。","出来","利用","loaned","0.004912",")","一次","opt","为了","to","bash","处理","message","四个","local","sharedptr","如何","赋值","有效","—","代码","steady","perf","max","keeplast","不必要","zero","加一","0","方面","提升","时延","通信","include","hbmem","更加","传输","count","并打印","对于","差异","node","消息","&","us","工具","都","？","与","经常","logger","since","source","一块","开启","延迟","灵活","降低","可能","系统","开发","接口","持续","数据通信","出现","tros","class","不妨","stamp","呢","d","数据量","调用","make","默认","试工","操作系统","--","在","计数","0.000180","前后","loanmessage","对","_","汇总","延时","loanedmsg","用来","一个","测试","发送","计算","时候","argc","runtime","*","是","将","或者","共享","这","缓存","提供","未","shared","修改","这个","init","对象","!","const","注意","一样","减少","多","=","已经","可用","index","测试工具","array4m","using","/","<","只","可以","整理","topic","timer","差不多","subscriptionhbmem","以及","]","少","分配",":","\"","setup","后","、","类似","40","存储","随着","定时","放到","避免","30","ros2","统计","机器人","完成","，","depth","然后","直接","具体","性能","这组","只是","函数","create","pubsub","判断","内部","(","now","cast","数据传输","啦","操作","带有","组件","表示","rclcpp","history","感受","别的","chrono","cpp","平均","test","问题","每隔","指标","subscription","可靠","functional","r","shutdown","运行","已","样本","图像","这种","也","run","话题","last","丢失","argv","当前","快","copy","install","不必","msg","必要","于","：","的","为","和",">","有","每次"," ","wall","keep","抖动","磁盘","t","$","move","毫秒","释放","解脱","callback","集成","this","多次","不可","中","内存","hpp","cpu","borrow","开销","把","string","例程","这样","只能","尤其","数据","技术","performance","auto","大量","ms","编程","1","timerbase","spin","方式","跑","小","char","分析","让","publish","打印","高效","交给","literals","++","拷贝","epoch","至于","所","过程","被","s","我们","size","倍","is","private","失败","main","情况","这里","应运","更好","系统资源","导致","了","针对","返回","发生","使用率","public","发布","大家","{","是否","memory","return","创建","placeholders","卡顿","流程","sample","计数器","到","valid","解析","包括","实际",",","者","封装","std","单位","机制","而","}","更少","else","结果","定时器","即可","数量","用","接收","来","大","共享内存","消耗","maxrss","microseconds","samplemessage","dus","duration","尺寸","还好","不","效果","要","资源","clock","不多","获取","活动","subscriber","几个","底层","增加","来讲","时间","publisher","bind","做","get","[","listener","m"],"title":"零拷贝数据传输","title_tokens":["数据传输","据传","拷贝","数据","传输","零"]},{"location":"hhp/3.4_%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/#_1","text":"在传统操作系统的数据传输过程中，系统内部会在磁盘、内存、缓存中多次进行数据拷贝，每次都会占用CPU的资源，数据量小的时候还好，随着数据量的增加，CPU的开销也会持续增加，尤其是在机器人图像数据的应用中 ，经常会发生这种问题，导致CPU都在做数据拷贝，没有时间处理其他的应用功能了，直接的感觉就是处理卡顿。","text_tokens":["是","持续","机器人","据传","开销","卡顿","问题","处理","操作系统","功能","的","数据","，","尤其","传统","进行","直接","在","其他","占用","缓存","每次","没有"," ","内部","都","经常","感觉","磁盘","还好","应用","图像","、","导致","这种","了","数据传输","资源","操作","小","也","数据量","发生","随着","会","增加","时间","机器","就是","多次","。","拷贝","中","内存","做","cpu","过程","系统","时候","传输"],"title":"零拷贝数据传输","title_tokens":["数据传输","据传","拷贝","数据","传输","零"]},{"location":"hhp/3.4_%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/#_2","text":"针对这种问题，零拷贝技术应运而生。 零拷贝主要的任务就是避免CPU将数据从一块存储拷贝到另外一块存储，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效。 TogetherROS中就提供了灵活、高效的零拷贝功能，可以显著降低大尺寸数据的通信延时和CPU占用，具体有多显著呢，我们不妨进行一个测试。","text_tokens":["应运而生","据传","主要","这样","可以","功能","数据","技术","大量","一类","一块","、","就","存储","让","灵活","显著","高效","就是","避免","降低","拷贝","系统","我们","，","具体","不妨","应运","任务","系统资源","呢","了","针对","数据传输","组件","零","别的","另外","问题","简单","进行","从","占用","拷贝到","togetherros","这种","专注","延时","一个","测试","。","出来","利用","不必","必要","于","的","来","大","将","或者","和","这","有","提供"," ","尺寸","有效","资源","减少","不必要","多","解脱","通信","中","做","cpu","更加","传输"],"title":"零拷贝技术","title_tokens":["技术","拷贝","零"]},{"location":"hhp/3.4_%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/#togetherros","text":"我们使用TogetherROS系统内部集成的性能测试工具——performance_test，来评估下开启零拷贝前后的性能差异，这里我们传输的样本数据量是4M。 未开启零拷贝进行数据传输 $ ros2 run performance_test perf_test --reliable --keep-last --history-depth 10 -s 1 -m Array4m -r 100 --max-runtime 30 #未开启 开启零拷贝数据传输： $ ros2 run performance_test perf_test --zero-copy --reliable --keep-last --history-depth 10 -s 1 -m Array4m -r 100 --max-runtime 30 #开启 好的，测试已经跑完了，我们把结果放到这里，来分析一下。 在这个测试中，关键有四个指标： 时延，也就是消息从发布者到订阅者的传输时间。不开启零拷贝的情况下，平均为0.004912s，开启零拷贝之后，速度快了差不多40倍，平均为0.000180s。 CPU使用率，表示通信活动所占用的CPU时间，大家可以看这个utime指标，开启零拷贝之后时间有显著的提升，消耗CPU的资源少了。 驻留内存，包括通信过程中分配的内存和共享内存，是这个maxrss中的数据，开启零拷贝之后，占用的内存也更少。 样本统计，包括测试中发送、接收以及丢失的消息数量，是这组数据，依然是开启零拷贝之后性能更好。 通过测试，对于大数据通信来讲，零拷贝在CPU消耗、内存占用以及通信延迟抖动方面的性能都会更好。 这里只是便于大家感受零拷贝技术的效果，具体编程中如何使用零拷贝机制呢？","text_tokens":["评估","utime","据传","对于","可以","差异","数据","技术","performance","关键","消息","差不多","以及","少","分配","一下","好","工具","1","都","编程","？","订阅","开启","跑","、","延迟","100","40","分析","便于","显著","放到","发布者","就是","拷贝","30","ros2","10","所","统计","过程","系统","数据通信","s","我们","倍","，","depth","使用","这组","性能","具体","情况","只是","内部","这里","更好","呢","了","数据传输","4m","数据量","完","使用率","发布","表示","驻留","history","大家","零","reliable","感受","依然","用率","平均","test","试工","指标","到","r","通过","--","#","数据通","进行","在","从","占用","包括","之后","下","0.000180","togetherros","样本","前后","-","也","_","者","run","last","速度","丢失","看","测试","会","发送","机制","快","。","copy","更少","0.004912","runtime","是","结果","：","数量","的","接收","来","四个","共享内存","大","为","消耗","maxrss","共享","和","有","未"," ","keep","抖动","这个","如何","不","—","效果","资源","不多","perf","max","活动","$","已经","zero","集成","来讲","时间","方面","提升","时延","通信","中","测试工具","内存","array4m","cpu","传输","把","m"],"title":"TogetherROS零拷贝性能测试","title_tokens":["性能","拷贝","togetherros","测试","零"]},{"location":"hhp/3.4_%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/#_3","text":"为了方便大家使用，TogetherROS针对零拷贝功能进行了封装，风格类似ROS2中话题通信的接口，还是话题通信一样的流程，我们只需要修改几个函数就可以实现啦。","text_tokens":["为了","我们","只","可以","流程","功能","，","的","进行","使用","函数","需要","修改","togetherros","类似","了","就","针对","啦","一样","风格","封装","还是","话题","几个","大家","零","。","方便","拷贝","通信","中","ros2","实现","接口"],"title":"编程开发","title_tokens":["编程","开发"]},{"location":"hhp/3.4_%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/#_4","text":"$ source /opt/tros/local_setup.bash $ source install/local_setup.bash $ ros2 run hbmem_pubsub talker $ ros2 run hbmem_pubsub listener","text_tokens":["opt","local"," ","_","bash","pubsub","install","ros2","$","setup","run","hbmem","talker","source",".","tros","/","listener"],"title":"运行例程","title_tokens":["例程","运行"]},{"location":"hhp/3.4_%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/#_5","text":"发布者publisher_hbmem.cpp： #include <chrono> #include <functional> #include <memory> #include <string> #include \"rclcpp/rclcpp.hpp\" #include \"hbmem_pubsub/msg/sample_message.hpp\" using namespace std :: chrono_literals ; class MinimalHbmemPublisher : public rclcpp :: Node { public : MinimalHbmemPublisher () : Node ( \"minimal_hbmem_publisher\" ), count_ ( 0 ) { // 创建publisher_hbmem，topic为\"topic\"，QOS为KEEPLAST(10)，以及默认的可靠传输 publisher_ = this -> create_publisher_hbmem < hbmem_pubsub :: msg :: SampleMessage > ( \"topic\" , 10 ); // 定时器，每隔40毫秒调用一次timer_callback进行消息发送 timer_ = this -> create_wall_timer ( 40 ms , std :: bind ( & MinimalHbmemPublisher :: timer_callback , this )); } private : // 定时器回调函数 void timer_callback () { // 获取要发送的消息 auto loanedMsg = publisher_ -> borrow_loaned_message (); // 判断消息是否可用，可能出现获取消息失败导致消息不可用的情况 if ( loanedMsg . is_valid ()) { // 引用方式获取实际的消息 auto & msg = loanedMsg . get (); // 获取当前时间，单位为us auto time_now = std :: chrono :: duration_cast < std :: chrono :: microseconds > ( std :: chrono :: steady_clock :: now (). time_since_epoch ()). count (); // 对消息的index和time_stamp进行赋值 msg . index = count_ ; msg . time_stamp = time_now ; // 打印发送消息 RCLCPP_INFO ( this -> get_logger (), \"message: %d\" , msg . index ); publisher_ -> publish ( std :: move ( loanedMsg )); // 注意，发送后，loanedMsg已不可用 // 计数器加一 count_ ++ ; } else { // 获取消息失败，丢弃该消息 RCLCPP_INFO ( this -> get_logger (), \"Failed to get LoanMessage!\" ); } } // 定时器 rclcpp :: TimerBase :: SharedPtr timer_ ; // hbmem publisher rclcpp :: PublisherHbmem < hbmem_pubsub :: msg :: SampleMessage >:: SharedPtr publisher_ ; // 计数器 size_t count_ ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < MinimalHbmemPublisher > ()); rclcpp :: shutdown (); return 0 ; } 订阅者subscriber_hbmem.cpp： #include <memory> #include \"rclcpp/rclcpp.hpp\" #include \"hbmem_pubsub/msg/sample_message.hpp\" class MinimalHbmemSubscriber : public rclcpp :: Node { public : MinimalHbmemSubscriber () : Node ( \"minimal_hbmem_subscriber\" ) { // 创建subscription_hbmem，topic为\"sample\"，QOS为KEEPLAST(10)，以及默认的可靠传输 // 消息回调函数为topic_callback subscription_ = this -> create_subscription_hbmem < hbmem_pubsub :: msg :: SampleMessage > ( \"topic\" , 10 , std :: bind ( & MinimalHbmemSubscriber :: topic_callback , this , std :: placeholders :: _1 )); } private : // 消息回调函数 void topic_callback ( const hbmem_pubsub :: msg :: SampleMessage :: SharedPtr msg ) const { // 注意，msg只能在回调函数中使用，回调函数返回后，该消息就会被释放 // 获取当前时间 auto time_now = std :: chrono :: duration_cast < std :: chrono :: microseconds > ( std :: chrono :: steady_clock :: now (). time_since_epoch ()) . count (); // 计算延时并打印出来 RCLCPP_INFO ( this -> get_logger (), \"msg %d, time cost %dus\" , msg -> index , time_now - msg -> time_stamp ); } // hbmem subscription rclcpp :: SubscriptionHbmem < hbmem_pubsub :: msg :: SampleMessage >:: SharedPtr subscription_ ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < MinimalHbmemSubscriber > ()); rclcpp :: shutdown (); return 0 ; }","text_tokens":["string","qos","只能","node","topic","消息","&","auto","timer","subscriptionhbmem","以及","ms","]","us",":","failed","1","\"","logger","minimalhbmemsubscriber","since","timerbase","后","spin","订阅","方式","就","40","%","char","定时","publish","打印","发布者","literals","++","epoch","10","可能","被","publisherhbmem","size","回调","，","is","丢弃","出现","private","使用","class","失败","判断","函数","main","create","情况","pubsub","stamp",".","(","导致","using","now","cast","info","minimal","int","该","返回","并打印","d","cost","public","发布","rclcpp","{","是否","chrono","namespace","调用","cpp",";","make","memory","默认","time","return","创建","引用","placeholders","每隔","subscription","sample","可靠","计数器","functional","#","valid","进行","void","在","shutdown","实际",",","计数","已","-","loanmessage","对","_","者","minimalhbmempublisher","延时","loanedmsg","argv","std","会","当前","单位","发送","if","计算","出来","}","loaned","msg","argc",")","一次","else","*","to","定时器","：","message","用","的","为","和",">","microseconds","samplemessage","shared","dus"," ","wall","sharedptr","duration","init","赋值","!","要","const","clock","获取","steady","注意","keeplast","t","subscriber","move","毫秒","=","释放","callback","加一","0","时间","this","publisher","可用","bind","不可","中","include","index","hbmem","hpp","borrow","get","传输","/","[","<","count"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"hhp/3.4_%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/#_6","text":"我们整理一下，与ROS2中的话题通信相比，TogetherROS带有零拷贝机制的话题通信接口是这样的。 在发布者中，我们可以使用PublisherHbmem来创建一个发布者对象，然后通过create_publisher_hbmem发布数据，而在订阅者中，SubscriptionHbmem用来创建一个订阅者对象，通过 create_subscription_hbmem订阅需要的数据，至于底层如何完成零拷贝的过程，都交给TogetherROS即可。","text_tokens":["publisherhbmem","是","我们","这样","即可","整理","可以","subscription","完成","，","的","通过","来","数据","使用","然后","在","subscriptionhbmem","create"," ","一下","需要","与","都","通信接口","如何","togetherros","对象","订阅","相比","带有","_","者","话题","用来","发布","一个","底层","零","机制","发布者","publisher","交给","。","而","拷贝","通信","中","ros2","至于","hbmem","过程","创建","接口"],"title":"接口汇总","title_tokens":["汇总","接口"]},{"location":"hhp/3.5_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1%E9%85%8D%E7%BD%AE/","text":"分布式通信配置 智能机器人的功能繁多，全都放在一个计算机里，经常会遇到计算能力不够、处理出现卡顿等情况，如果可以将这些任务拆解，分配到多个计算机中运行岂不是可以减轻压力？ 这就是分布式系统， 可以实现多计算平台上的任务分配。 分布式通信 什么叫分布式？ 机器人功能是由各种节点组成的，这些节点可能位于不同的计算机中，这种结构可以将原本资源消耗较多的任务，分配到不同的平台上，减轻计算压力，这就是分布式通信框架的典型应用之一。 比如在这款机器人系统中，就有两个计算平台。 机器人体积比较小，不适合放一个笔记本电脑在上边，于是采用旭日派作为控制器，主要实现传感器驱动、电机控制、AI应用等功能，此外我们还需要在电脑上监控机器人的传感器信息，并且远程控制机器人运动。 两个计算平台之间的通信，看上去还有点复杂，毕竟相互传输的数据还挺多的，不过TogehterROS都已经为我们准备好了，我们只需要在每一个计算上配置好TogehterROS或者ROS2的环境，功能开发上完全不需要做任何变化，实现非常方便。 接下来，我们就带领大家一起来感受下分布式系统的魅力。 分布式网络搭建 旭日派配置完成后，确保已经和你所使用的电脑连接到了同一个局域网络中。接下来我们打通两个计算平台的通信能力。具体需要做什么呢？ 简而言之，什么都不需要做。我们直接用命令行测试一下话题通信的效果。 $ ros2 run examples_rclcpp_minimal_publisher publisher_member_function # 旭日派端 $ ros2 run examples_rclcpp_minimal_subscriber subscriber_member_function # PC端 神奇的事情就这样发生了，旭日X3派上安装的是TogetherROS，我的电脑上安装的是ROS2，他们只要处于同一网络中，就可以实现通信了，感觉就像在一个电脑里一样。 Attention 如使用虚拟机，请将虚拟机网络修改为 桥接模式 不过这也会带来一个问题，如果一个网络中有很多个计算机，我们并不希望他们都可以互通互联，而是可以分组通信，小组之间是无法实现通信的。 分布式网络分组 没问题，ROS2提供了一个DOMAIN的机制，就类似分组一样，处于同一个DOMAIN中的计算机才能通信，我们可以在电脑和旭日X3派端中加入这样一句配置，即可将两者分配到一个小组中： $ export ROS_DOMAIN_ID = <your_domain_id> 如果分配的ID不同，则两者无法实现通信。 话题分布式通信 之前编写的例程是否可以在不修改任何代码的情况下，直接使用呢？ 以话题通信为例，旭日派作为发布者，发布Hello World字符串，电脑作为订阅者，订阅Hello World字符串，我们看下效果如何。 $ ros2 run learning_topic_cpp talker # 旭日派端 $ ros2 run learning_topic_cpp listener # PC端 好啦，我们在分布式网络中测试了ROS一系列例程，都没有任何问题，在实际的机器人开发中，类似的方法会频繁用到，我们几乎不需要任何配置，代码也不需要做任何修改，一切都会变得如此轻松。","text_tokens":["如果","例程","主要","复杂","只","这样","可以","模式","此外","功能","驱动","数据","没有","topic","传感器","如","环境","不够","有点","用到","分配","平台","处于","才能","一下","计算机","？","都","好","经常","派","并且","应用","后","无法","订阅","、","类似","就","繁多","带来","压力","id","小","分组","这些","笔记本电脑","位于","频繁","your","而言","传感","以","learning","发布者","机器","就是","则","ros","控制","每","算机","方便","什么","实现","ros2","所","可能","系统","还","上边","开发","准备","function","组成","起来","机器人","桥接","我们","分布式系统","分布","完成","没","，","计算能力","下来","分布式","遇到","出现","网络","使用","直接","几乎","不过","具体","只要","情况","相互","局域网络","叫","domain","岂","任务","里","节点","虚拟机","请","字符串","一","呢","了","minimal","看上去","x3","啦","examples","比如","发生","talker","之一","发布","rclcpp","等","适合","大家","是否","感受","较","并","确保","完全","cpp","比较","打通","互通","布式","神奇","减轻","hello","他们","任务分配","电脑","member","卡顿","问题","两个","命令","像","到","接下来","由","原本","框架","#","信息","为例","在","个","实际","运行","控制器","典型","需要","下","全都","安装","互联","系列","ai","挺","感觉","togetherros","之间","很多","变化","局域","命令行","这种","局域网","配置","中有","电机","小组","两者","接下","也","_","者","连接","run","话题","export","笔记本","一个","上","监控","测试","会","虚拟","看","如此","希望","机制","轻松","字符","作为","放","计算","。","不是","能力","变得","world","attention","事情","是","结构","采用","远程","同一个","即可","：","毕竟","处理","简而言之","编写","用","的","端","不同","看上","消耗","将","笔记","为","或者","旭日","和","这","有","你","提供","加入",">"," ","方法","上去","这款","体积","任何","修改","如何","搭建","智能","不","效果","代码","一系","pc","感器","资源","运动","一样","放在","多个","同一","之前","一切","subscriber","$","多","各种","派端","我","togehterros","已经","魅力","=","一系列","publisher","于是","通信","中","而是","拆解","做","一句","带领","传输","非常","<","listener"],"title":"分布式通信配置","title_tokens":["通信","分布","布式","分布式","配置"]},{"location":"hhp/3.5_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1%E9%85%8D%E7%BD%AE/#_1","text":"智能机器人的功能繁多，全都放在一个计算机里，经常会遇到计算能力不够、处理出现卡顿等情况，如果可以将这些任务拆解，分配到多个计算机中运行岂不是可以减轻压力？ 这就是分布式系统， 可以实现多计算平台上的任务分配。","text_tokens":["如果","任务分配","机器人","卡顿","分布式系统","可以","处理","分布","功能","的","，","计算能力","到","分布式","遇到","出现","将","不够","这","情况","分配","运行"," ","平台","全都","计算机","岂","？","经常","任务","里","智能","、","繁多","压力","放在","多个","这些","多","一个","等","上","会","机器","就是","计算","。","算机","中","不是","实现","拆解","布式","系统","减轻","能力"],"title":"分布式通信配置","title_tokens":["通信","分布","布式","分布式","配置"]},{"location":"hhp/3.5_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1%E9%85%8D%E7%BD%AE/#_2","text":"什么叫分布式？ 机器人功能是由各种节点组成的，这些节点可能位于不同的计算机中，这种结构可以将原本资源消耗较多的任务，分配到不同的平台上，减轻计算压力，这就是分布式通信框架的典型应用之一。 比如在这款机器人系统中，就有两个计算平台。 机器人体积比较小，不适合放一个笔记本电脑在上边，于是采用旭日派作为控制器，主要实现传感器驱动、电机控制、AI应用等功能，此外我们还需要在电脑上监控机器人的传感器信息，并且远程控制机器人运动。 两个计算平台之间的通信，看上去还有点复杂，毕竟相互传输的数据还挺多的，不过TogehterROS都已经为我们准备好了，我们只需要在每一个计算上配置好TogehterROS或者ROS2的环境，功能开发上完全不需要做任何变化，实现非常方便。 接下来，我们就带领大家一起来感受下分布式系统的魅力。","text_tokens":["主要","复杂","只","可以","此外","功能","驱动","数据","传感器","环境","有点","分配","平台","计算机","？","都","好","派","并且","应用","、","就","压力","小","这些","笔记本电脑","位于","传感","机器","就是","控制","每","算机","方便","什么","实现","ros2","可能","系统","还","上边","开发","准备","组成","起来","机器人","我们","分布式系统","分布","，","下来","分布式","不过","相互","叫","任务","节点","一","了","看上去","比如","之一","等","适合","大家","感受","较","完全","比较","布式","减轻","电脑","两个","到","接下来","由","原本","框架","信息","在","控制器","典型","需要","下","ai","挺","之间","变化","这种","配置","电机","接下","笔记本","一个","上","监控","作为","放","计算","。","是","结构","采用","远程","毕竟","的","不同","看上","消耗","将","笔记","为","或者","旭日","这","有"," ","上去","这款","体积","任何","不","感器","资源","运动","多","各种","togehterros","已经","魅力","于是","通信","中","做","带领","传输","非常"],"title":"分布式通信","title_tokens":["通信","分布","布式","分布式"]},{"location":"hhp/3.5_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1%E9%85%8D%E7%BD%AE/#_3","text":"旭日派配置完成后，确保已经和你所使用的电脑连接到了同一个局域网络中。接下来我们打通两个计算平台的通信能力。具体需要做什么呢？ 简而言之，什么都不需要做。我们直接用命令行测试一下话题通信的效果。 $ ros2 run examples_rclcpp_minimal_publisher publisher_member_function # 旭日派端 $ ros2 run examples_rclcpp_minimal_subscriber subscriber_member_function # PC端 神奇的事情就这样发生了，旭日X3派上安装的是TogetherROS，我的电脑上安装的是ROS2，他们只要处于同一网络中，就可以实现通信了，感觉就像在一个电脑里一样。 Attention 如使用虚拟机，请将虚拟机网络修改为 桥接模式 不过这也会带来一个问题，如果一个网络中有很多个计算机，我们并不希望他们都可以互通互联，而是可以分组通信，小组之间是无法实现通信的。","text_tokens":["如果","这样","模式","可以","如","平台","处于","一下","计算机","？","都","派","后","无法","就","带来","分组","而言","算机","什么","ros2","实现","所","function","桥接","我们","完成","，","下来","使用","网络","直接","不过","具体","只要","局域网络","里","虚拟机","请","呢","了","minimal","x3","examples","发生","rclcpp","并","确保","打通","互通","神奇","他们","电脑","member","问题","两个","命令","像","到","接下来","#","在","个","需要","安装","互联","感觉","togetherros","很多","之间","命令行","中有","局域网","配置","小组","接下","也","_","连接","run","话题","一个","上","测试","虚拟","会","希望","计算","。","能力","attention","事情","是","同一个","简而言之","用","的","端","你","将","为","和","旭日","这"," ","修改","不","效果","pc","一样","同一","subscriber","$","派端","我","已经","publisher","通信","中","而是","做","局域"],"title":"分布式网络搭建","title_tokens":["分布","布式","分布式","搭建","网络"]},{"location":"hhp/3.5_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1%E9%85%8D%E7%BD%AE/#_4","text":"没问题，ROS2提供了一个DOMAIN的机制，就类似分组一样，处于同一个DOMAIN中的计算机才能通信，我们可以在电脑和旭日X3派端中加入这样一句配置，即可将两者分配到一个小组中： $ export ROS_DOMAIN_ID = <your_domain_id> 如果分配的ID不同，则两者无法实现通信。","text_tokens":["如果","电脑","同一个","我们","这样","问题","即可","可以","：","没","，","的","到","不同","在","将","和","旭日",">","提供","加入","domain","处于","才能","计算机","分配"," ","无法","类似","了","就","配置","小组","x3","一样","两者","id","分组","_","同一","export","$","your","一个","派端","=","机制","则","计算","ros","。","算机","通信","中","ros2","实现","一句","<"],"title":"分布式网络分组","title_tokens":["分组","分布","布式","分布式","网络"]},{"location":"hhp/3.5_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1%E9%85%8D%E7%BD%AE/#_5","text":"之前编写的例程是否可以在不修改任何代码的情况下，直接使用呢？ 以话题通信为例，旭日派作为发布者，发布Hello World字符串，电脑作为订阅者，订阅Hello World字符串，我们看下效果如何。 $ ros2 run learning_topic_cpp talker # 旭日派端 $ ros2 run learning_topic_cpp listener # PC端 好啦，我们在分布式网络中测试了ROS一系列例程，都没有任何问题，在实际的机器人开发中，类似的方法会频繁用到，我们几乎不需要任何配置，代码也不需要做任何修改，一切都会变得如此轻松。","text_tokens":["例程","可以","topic","用到","好","？","都","派","订阅","类似","频繁","以","learning","发布者","机器","ros","ros2","开发","机器人","我们","分布","，","分布式","使用","网络","直接","几乎","情况","字符串","呢","了","啦","talker","发布","是否","cpp","布式","hello","电脑","问题","#","为例","在","实际","没有","下","需要","系列","配置","也","者","_","run","话题","看","测试","如此","会","轻松","字符","作为","。","变得","world","编写","的","端","旭日","方法"," ","任何","修改","如何","不","代码","效果","一系","pc","之前","一切","$","派端","一系列","通信","中","做","listener"],"title":"话题分布式通信","title_tokens":["通信","分布","话题","布式","分布式"]},{"location":"hhp/4.1_%E6%95%B0%E5%AD%97%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/","text":"数字输入与输出 数字输入与输出是最常用的一种外设通信方式，虽然每一个端口只有0和1两种状态，但却可以组合出各种各样的变化。 数字输入与输出原理 数字输入与输出，也称为通用输入输出，全称是General-purpose input/output，大部分情况下，我们都会用简称GPIO GPIO的功能，主要是指这个管脚可以作为数字信号的输入或者输出使用，到底是输入还是输出呢，这需要我们使用系统寄存器来进行配置。 当GPIO被设置为输入模式时，就可以读取这个管脚上的电平高低，从而实现读取外部信号的功能，比如外部按键的信号，就是这样读取的。 当GPIO被设置为输出模式时，我们就可以主动改变管脚的电平高低了，这样就能通过电平的变化，控制外部的设备，比如点亮或者熄灭一个LED灯。 除此之外，一些IO口还可以配置成其他功能，比如PWM输出，串口通信等等。 关于旭日X3派的管脚定义，大家可以参考这张图，他会显示每个管脚具体可以实现什么功能。 这里需要说明一点，旭日X3派的管脚序号定义有三种编码方式： 第一种就是Board编码，这种就是按照主板上管脚排针编号，分别对应1~40号排针。 第二种就是BCM编码，这种方式是参考 Broadcom SOC 的通道编号，侧重CPU寄存器，在使用BCM库或者使用python编程时，常采用的一种编码方式。 第三种就是X3编码，可以理解为是旭日X3派自己的编码方式，在使用旭日派自己的驱动库编程时，会使用到这种编码。 大家在后续编程开发中，需要结合函数接口的说明，使用对应的引脚编号，不然可能会出现意料之外的问题。 引脚复用配置工具 虽然从硬件上看，扩展出来的引脚只有40个，不过大部分引脚还可以配置成多种功能，这样延伸出来变化可就多了，那如何配置引脚的不同功能呢？ 我们可以使用旭日X3派中提供的srpi-config工具进行配置。 直接在终端中输入这个指令，就可以看到这样的窗口，okay配置对应管脚为专用功能，disabled配置对应管脚为GPIO模式，按照自己的需要进行配置即可，配置完成后重启才会生效。 了解了GPIO的概念，接下来我们就要开始编程啦。 数字输入编程 首先我们来看下最基本的数字输入测试，读取一个按键的状态。 硬件接线 我们将按键的一边连接到旭日X3派的38号引脚上，这是一个GPIO的接口，另一边连接到39号引脚，也就是GND。 原理很简单，按键没按下时，导线是断开的，GPIO是默认的状态，按键按下后，导线就会导通，GPIO的状态变成了GND。 这样，我们就可以通过电平的变化，知道按键的状态啦。 运行例程 我们不妨来运行一下，看下实际效果是不是这样。 $ sudo python3 simple_input.py 我们将一个按键开关接到对应的管脚上， 然后连接到旭日X3PI当中，运行刚才的程序。之后我们按下或是松开按键时，他都会打印出对应的电平变化。 按下显示的就是LOW，也就是低电平，松开就是HIGH，也就是高电平。 代码解析 数字输入的功能实现啦，我们来看下代码是如何实现的。 simple_input.py： #!/usr/bin/env python3 import Hobot.GPIO as GPIO import time # 定义使用的GPIO通道为38 input_pin = 38 # BOARD 编码 38 def main (): prev_value = None # 设置管脚编码模式为硬件编号 BOARD GPIO . setmode ( GPIO . BOARD ) # 设置为输入模式 GPIO . setup ( input_pin , GPIO . IN ) print ( \"Starting demo now! Press CTRL+C to exit\" ) try : while True : # 读取管脚电平 value = GPIO . input ( input_pin ) if value != prev_value : if value == GPIO . HIGH : value_str = \"HIGH\" else : value_str = \"LOW\" print ( \"Value read from pin {} : {} \" . format ( input_pin , value_str )) prev_value = value time . sleep ( 1 ) finally : GPIO . cleanup () if __name__ == '__main__' : main () 我们在Python中需要引入X3Pi的GPIO库，从而使用对应的GPIO功能。 主函数里首先需要定义了一个变量来存储这个管脚的电平信号。 进行初始化，设置管脚的编码模式为BOARD模式，之后定义输入用的管脚，这里使用的是BOARD编码，因为他是第38个管脚，所以为38号。 之后的话就会进入到循环当中，这样的一个函数就可以读出当前的电平值。 没有按下按键的时候，38管脚和GND是断开的，他就是高电平，按下按键时，就和GND导通了，这个管脚就会编程低电平。 如果电平值和上一次存储的不一致，后面的判断就会判断出是升高还是降低，最后会把结果打印出来。 松开按键时同理。 数字输出编程 GPIO不止有输入功能，还有输出功能，大家应该经常看到电子设别上的LED灯吧，这就是典型的IO输出控制的设备，我们也来试一试。 硬件接线 我们将一个LED灯的正极连接到了2号引脚，这是5V电源，用来给LED供电的，不过LED电阻小，为了不至于烧坏，我们最好还是在电路中串联一个电阻来限制电流大小。 接下来，当LED的负极接到GND，也就是电源的0V上时，LED两边会因为有电势差而被点亮；当LED的负极也连接到高电平，也就是5V的时候，会因为两边没有电势差，也就不会被点亮。 这个负极的电平信号我们就用GPIO来输出，所以我们把LED的负极连接到任意的GPIO引脚上，比如38号，将这个引脚设置为输出模式，当输出高电平时，灯就会熄灭，输出低电平，灯就会被点亮。 把这两个动作放到一个循环中，就可以实现闪烁的功能啦。 运行示例程序 快来运行例程试一试吧，按照刚才的设置，将实物连接完成，然后连接到X3Pi，运行程序，就可以看到这个LED就会开始闪烁了。 $ sudo python3 simple_input.py 代码解析 simple_out.py： #!/usr/bin/env python3 import Hobot.GPIO as GPIO import time # 定义使用的GPIO通道为38 output_pin = 38 # BOARD 编码 38 def main (): # 设置管脚编码模式为硬件编号 BOARD GPIO . setmode ( GPIO . BOARD ) # 设置为输出模式，并且初始化为高电平 GPIO . setup ( output_pin , GPIO . OUT , initial = GPIO . HIGH ) # 记录当前管脚状态 curr_value = GPIO . HIGH print ( \"Starting demo now! Press CTRL+C to exit\" ) try : # 间隔1秒时间，循环控制LED灯亮灭 while True : time . sleep ( 1 ) GPIO . output ( output_pin , curr_value ) curr_value ^= GPIO . HIGH finally : GPIO . cleanup () if __name__ == '__main__' : main () 数字输入与输出集成 学习了GPIO的输入与输出功能后，我们就可以做一些自动化的功能了。 硬件接线 比如我们同时连接一个按键和LED灯，尝试实现按键被按下，灯被点亮，松开，灯熄灭，这样的功能。 运行示例程序 我们通过这个例程来试一试效果如何？ $ sudo python3 button_led.py 我们来看一下具体的操作，同样的，按照刚才的设置，将实物连接完成，然后连接到X3Pi，运行刚才的程序。按下按键后，就可以看到LED被点亮了，松开之后，LED就熄灭了。 代码解析 button_led.py #!/usr/bin/env python3 import Hobot.GPIO as GPIO import time # 定义使用的GPIO通道： # 36号作为输出，可以点亮一个LED # 38号作为输入，可以接一个按钮 led_pin = 36 # BOARD 编码 36 but_pin = 38 # BOARD 编码 38 # 禁用警告信息 GPIO . setwarnings ( False ) def main (): prev_value = None # Pin Setup: GPIO . setmode ( GPIO . BOARD ) # BOARD pin-numbering scheme GPIO . setup ( led_pin , GPIO . OUT ) # LED pin set as output GPIO . setup ( but_pin , GPIO . IN ) # Button pin set as input # Initial state for LEDs: GPIO . output ( led_pin , GPIO . LOW ) print ( \"Starting demo now! Press CTRL+C to exit\" ) try : while True : curr_value = GPIO . input ( but_pin ) if curr_value != prev_value : GPIO . output ( led_pin , curr_value ) prev_value = curr_value print ( \"Outputting {} to Pin {} \" . format ( curr_value , led_pin )) time . sleep ( 1 ) finally : GPIO . cleanup () # cleanup all GPIO if __name__ == '__main__' : main () 基本的配置还是一样的，引入基本的库，然后设置为BOARD模式，然后初始化两个管脚，一个用来读取按键的通断，一个用来控制LED的亮灭，之后只需要判断按键的状态来做出对应的控制LED的动作就可以了。","text_tokens":["各样","是不是","主要","py","功能","可","指令","okay","其他","output","一下","starting","io","定义","派","并且","端口","就","第一种","对应","srpi","不止","通用","电源","gpio","就是","最后","除此","实现","什么","一边","env","还有","from","out","每个","数字","使用","成","不过","读出","多种","引脚","寄存","第三",".","高低","soc","参考","尝试","config","broadcom","初始","time","简单","警告","通过","很","#","首先","进行","initial","就要","从","试一试","as","之后","没有","下","需要","同时","供电","各种各样","-","high","还是","看","会","led","电势","if","。","出来","后面","不至于","setmode",")","一次","为了","to","排针","导通","自动","pwm","如何","能","value","代码","hobot","到底","接线","0","通断","python","通信","理解","ctrl","all","基本","之外","exit","input","禁用","第一","主板","工具","与","都","？","经常","的话","除此之外","大部分","第二种","leds","'","降低","关于","true","最","可能","系统","开发","任意","全称","称为","刚才","接口","自己","按照","编码方式","说明","38","下来","出现","开关","升高","做出","电流","第三种","松开","第","同理","程序","这是","不妨","值","数字信号","当","呢","断开","x3","简称","两边","正极","概念","口","board","了解","36","默认","最好","python3","那","主","信息","熄灭","在","间隔","典型","硬件","try","bin","烧坏","输出","电平","扩展","配置","动作","接下","_","循环","连接","用来","一个","上","测试","同样","或是","张图","记录","不是","按钮","read","时候","电子","是","一种","串联","两种","press","改变","组合","一致","将","或者","旭日","电阻","这","提供","这个","知道","!","一样","序号","点亮","numbering","demo","多","=","电势差","false","purpose","sudo","/","常","延伸","name","2","编号","只","可以","他","接","二种","驱动","进入","终端",":","\"","setup","后","39","意料之外","40","结合","存储","按键","状态","三种","low","编码","放到","不然","应该","curr","完成","，","大小","实际效果","然后","直接","__","具体","函数","判断","学习","读取","里","sleep","变成","复用","(","general","now","啦","str","操作","比如","初始化","窗口","自动化","in","所以","部分","问题","pin","会导通","个","运行","但","出是","设置","串口","只有","这种","专用","才","也","当前","format","外设","作为","快","灯亮","灭","导线","simple","另一边","：","输入","的","不会","+","scheme","为","常用","和","上时","有"," ","none","一点","设备","生效","等等","gnd","$","各种","state","集成","重启","bcm","中","cpu","^","cleanup","把","如果","例程","模式","这样","import","实物","编程","1","0v","电路","方式","他会","小","指","setwarnings","打印","button","每","控制","outputting","至于","被","还","按","示例","我们","没","通道","秒","main","情况","输入输出","这里","引入","后续","设别","大部","一些","信号","了","按下","灯","外部","从而","but","因为","for","prev","大家","{","管脚","当中","限制","却","号","高电平","出","开始","x3pi","两个","到","接下来","usr","分别","解析","5v","实际","吧","寄存器",",","第二","变化","虽然","c","set","while","闪烁","亮","给","来看","而","}","侧重","else","finally","采用","结果","print","即可","用","来","不同","负极","意料","；","看到","不","效果","主动","变量","低电平","库","disabled","时","~","接到","原理","时间","显示","做","def"],"title":"数字输入与输出","title_tokens":["数字","输入","输出","与"]},{"location":"hhp/4.1_%E6%95%B0%E5%AD%97%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/#_1","text":"数字输入与输出是最常用的一种外设通信方式，虽然每一个端口只有0和1两种状态，但却可以组合出各种各样的变化。","text_tokens":["是","各样","一种","可以","输入","的","，","两种","组合","数字","常用","和","与","1","但","变化","方式","输出","虽然","端口","只有","各种各样","状态","各种","一个","0","外设","每","。","却","通信","最","出"],"title":"数字输入与输出","title_tokens":["数字","输入","输出","与"]},{"location":"hhp/4.1_%E6%95%B0%E5%AD%97%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/#_2","text":"数字输入与输出，也称为通用输入输出，全称是General-purpose input/output，大部分情况下，我们都会用简称GPIO GPIO的功能，主要是指这个管脚可以作为数字信号的输入或者输出使用，到底是输入还是输出呢，这需要我们使用系统寄存器来进行配置。 当GPIO被设置为输入模式时，就可以读取这个管脚上的电平高低，从而实现读取外部信号的功能，比如外部按键的信号，就是这样读取的。 当GPIO被设置为输出模式时，我们就可以主动改变管脚的电平高低了，这样就能通过电平的变化，控制外部的设备，比如点亮或者熄灭一个LED灯。 除此之外，一些IO口还可以配置成其他功能，比如PWM输出，串口通信等等。 关于旭日X3派的管脚定义，大家可以参考这张图，他会显示每个管脚具体可以实现什么功能。 这里需要说明一点，旭日X3派的管脚序号定义有三种编码方式： 第一种就是Board编码，这种就是按照主板上管脚排针编号，分别对应1~40号排针。 第二种就是BCM编码，这种方式是参考 Broadcom SOC 的通道编号，侧重CPU寄存器，在使用BCM库或者使用python编程时，常采用的一种编码方式。 第三种就是X3编码，可以理解为是旭日X3派自己的编码方式，在使用旭日派自己的驱动库编程时，会使用到这种编码。 大家在后续编程开发中，需要结合函数接口的说明，使用对应的引脚编号，不然可能会出现意料之外的问题。","text_tokens":["编号","主要","模式","这样","可以","之外","input","功能","二种","驱动","其他","第一","主板","output","编程","与","都","1","io","定义","派","方式","就","除此之外","40","意料之外","他会","第一种","结合","指","按键","对应","大部分","第二种","三种","编码","通用","gpio","就是","控制","除此","实现","关于","什么","可能","被","系统","还","开发","全称","称为","接口","不然","自己","我们","按照","编码方式","说明","每个","，","通道","数字","使用","成","出现","第三种","具体","函数","情况","引脚","输入输出","读取","这里","寄存","第三","后续","大部","一些","信号","数字信号","general","当","呢","高低","了","x3","简称","灯","外部","从而","比如","soc","口","参考","大家","管脚","board","broadcom","号","部分","问题","到","通过","分别","进行","熄灭","在","下","需要","寄存器","第二","设置","变化","串口","输出","电平","-","这种","配置","也","还是","一个","上","会","led","作为","张图","。","侧重","是","采用","：","一种","排针","用","输入","的","来","改变","意料","为","或者","旭日","这","有"," ","pwm","这个","设备","一点","能","主动","序号","点亮","时","等等","到底","库","~","显示","purpose","python","bcm","通信","中","理解","cpu","/","常"],"title":"数字输入与输出原理","title_tokens":["与","输入","数字","输出","原理"]},{"location":"hhp/4.1_%E6%95%B0%E5%AD%97%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/#_3","text":"虽然从硬件上看，扩展出来的引脚只有40个，不过大部分引脚还可以配置成多种功能，这样延伸出来变化可就多了，那如何配置引脚的不同功能呢？ 我们可以使用旭日X3派中提供的srpi-config工具进行配置。 直接在终端中输入这个指令，就可以看到这样的窗口，okay配置对应管脚为专用功能，disabled配置对应管脚为GPIO模式，按照自己的需要进行配置即可，配置完成后重启才会生效。 了解了GPIO的概念，接下来我们就要开始编程啦。","text_tokens":["这样","模式","可以","功能","可","指令","okay","终端","编程","？","工具","派","后","就","40","对应","大部分","srpi","gpio","还","自己","我们","按照","完成","，","下来","使用","成","直接","不过","多种","引脚","大部","呢","了","x3","啦","概念","config","窗口","管脚","了解","开始","部分","那","接下来","进行","个","在","就要","从","需要","硬件","变化","虽然","扩展","-","只有","配置","专用","才","接下","上","看","会","。","出来","即可","的","输入","不同","为","旭日","提供"," ","如何","看到","这个","生效","disabled","多","重启","中","延伸"],"title":"引脚复用配置工具","title_tokens":["引脚","工具","复用","配置"]},{"location":"hhp/4.1_%E6%95%B0%E5%AD%97%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/#_4","text":"首先我们来看下最基本的数字输入测试，读取一个按键的状态。","text_tokens":["按键","我们","下","。","基本","读取","最","的","输入","测试","来看","，","首先","数字","一个","状态"],"title":"数字输入编程","title_tokens":["数字","输入","编程"]},{"location":"hhp/4.1_%E6%95%B0%E5%AD%97%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/#_5","text":"我们将按键的一边连接到旭日X3派的38号引脚上，这是一个GPIO的接口，另一边连接到39号引脚，也就是GND。 原理很简单，按键没按下时，导线是断开的，GPIO是默认的状态，按键按下后，导线就会导通，GPIO的状态变成了GND。 这样，我们就可以通过电平的变化，知道按键的状态啦。","text_tokens":["是","我们","这样","简单","可以","没","的","到","，","很","38","会导通","通过","将","按","旭日"," ","引脚","下","这是","知道","派","变成","39","后","变化","电平","断开","了","就","按下","x3","啦","按键","也","gnd","时","连接","状态","一个","上","原理","gpio","就是","。","号","导线","默认","一边","另一边","接口"],"title":"硬件接线","title_tokens":["接线","硬件"]},{"location":"hhp/4.1_%E6%95%B0%E5%AD%97%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/#_6","text":"我们不妨来运行一下，看下实际效果是不是这样。 $ sudo python3 simple_input.py 我们将一个按键开关接到对应的管脚上， 然后连接到旭日X3PI当中，运行刚才的程序。之后我们按下或是松开按键时，他都会打印出对应的电平变化。 按下显示的就是LOW，也就是低电平，松开就是HIGH，也就是高电平。","text_tokens":["是不是","x3pi","我们","这样","py","他","input","，","的","到","来","实际效果","开关","然后","将","旭日","实际","运行","之后","松开","下","一下"," ","程序","不妨","都",".","变化","效果","电平","按下","high","低电平","按键","时","_","对应","接到","也","连接","$","一个","看","上","管脚","会","打印","当中","low","显示","或是","就是","。","不是","sudo","高电平","python3","出","simple","刚才"],"title":"运行例程","title_tokens":["例程","运行"]},{"location":"hhp/4.1_%E6%95%B0%E5%AD%97%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/#_7","text":"数字输入的功能实现啦，我们来看下代码是如何实现的。 simple_input.py： #!/usr/bin/env python3 import Hobot.GPIO as GPIO import time # 定义使用的GPIO通道为38 input_pin = 38 # BOARD 编码 38 def main (): prev_value = None # 设置管脚编码模式为硬件编号 BOARD GPIO . setmode ( GPIO . BOARD ) # 设置为输入模式 GPIO . setup ( input_pin , GPIO . IN ) print ( \"Starting demo now! Press CTRL+C to exit\" ) try : while True : # 读取管脚电平 value = GPIO . input ( input_pin ) if value != prev_value : if value == GPIO . HIGH : value_str = \"HIGH\" else : value_str = \"LOW\" print ( \"Value read from pin {} : {} \" . format ( input_pin , value_str )) prev_value = value time . sleep ( 1 ) finally : GPIO . cleanup () if __name__ == '__main__' : main () 我们在Python中需要引入X3Pi的GPIO库，从而使用对应的GPIO功能。 主函数里首先需要定义了一个变量来存储这个管脚的电平信号。 进行初始化，设置管脚的编码模式为BOARD模式，之后定义输入用的管脚，这里使用的是BOARD编码，因为他是第38个管脚，所以为38号。 之后的话就会进入到循环当中，这样的一个函数就可以读出当前的电平值。 没有按下按键的时候，38管脚和GND是断开的，他就是高电平，按下按键时，就和GND导通了，这个管脚就会编程低电平。 如果电平值和上一次存储的不一致，后面的判断就会判断出是升高还是降低，最后会把结果打印出来。 松开按键时同理。","text_tokens":["如果","ctrl","编号","py","模式","这样","他","可以","exit","功能","input","import","进入",":","编程","starting","1","\"","setup","定义","的话","就","存储","按键","对应","low","打印","编码","gpio","'","就是","降低","最后","实现","true","env","from","我们","，","通道","38","数字","使用","升高","__","main","函数","第","读出","判断","松开","同理","读取","这里","引入","值","里","sleep",".","(","信号","now","了","断开","按下","啦","str","从而","初始化","因为","prev","{","管脚","当中","board","号","初始","高电平","time","in","python3","所以","x3pi","主","pin","usr","到","#","首先","进行","在","个","as","之后","没有","下",",","需要","硬件","try","出是","bin","设置","电平","c","high","while","_","循环","还是","来看","一个","上","会","当前","format","if","。","出来","}","后面","read","时候","setmode","simple",")","else","finally","一次","是","to","结果","print","：","用","输入","的","来","press","+","一致","为","导通","和"," ","如何","none","这个","value","!","不","代码","hobot","变量","低电平","库","时","gnd","demo","=","python","中","cleanup","/","把","def","name"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"hhp/4.1_%E6%95%B0%E5%AD%97%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/#_8","text":"GPIO不止有输入功能，还有输出功能，大家应该经常看到电子设别上的LED灯吧，这就是典型的IO输出控制的设备，我们也来试一试。","text_tokens":["还有","应该","我们","功能","输入","，","的","来","试一试","这","有","吧","典型","经常","io","看到","设别","设备","输出","灯","也","上","大家","led","不止","gpio","就是","控制","。","电子"],"title":"数字输出编程","title_tokens":["数字","输出","编程"]},{"location":"hhp/4.1_%E6%95%B0%E5%AD%97%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/#_9","text":"我们将一个LED灯的正极连接到了2号引脚，这是5V电源，用来给LED供电的，不过LED电阻小，为了不至于烧坏，我们最好还是在电路中串联一个电阻来限制电流大小。 接下来，当LED的负极接到GND，也就是电源的0V上时，LED两边会因为有电势差而被点亮；当LED的负极也连接到高电平，也就是5V的时候，会因为两边没有电势差，也就不会被点亮。 这个负极的电平信号我们就用GPIO来输出，所以我们把LED的负极连接到任意的GPIO引脚上，比如38号，将这个引脚设置为输出模式，当输出高电平时，灯就会熄灭，输出低电平，灯就会被点亮。 把这两个动作放到一个循环中，就可以实现闪烁的功能啦。","text_tokens":["2","模式","可以","功能","0v","电路","就","小","电源","放到","就是","gpio","至于","实现","被","任意","我们","，","大小","38","下来","电流","不过","引脚","这是","当","信号","了","啦","灯","两边","正极","比如","因为","限制","号","高电平","最好","所以","两个","到","接下来","5v","在","熄灭","没有","供电","设置","烧坏","输出","电平","动作","接下","也","循环","闪烁","连接","给","还是","用来","一个","上","会","led","电势","。","而","不至于","时候","为了","串联","的","用","来","不会","负极","为","将","电阻","上时","这","有","；"," ","这个","低电平","点亮","时","gnd","接到","电势差","中","把"],"title":"硬件接线","title_tokens":["接线","硬件"]},{"location":"hhp/4.1_%E6%95%B0%E5%AD%97%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/#_10","text":"快来运行例程试一试吧，按照刚才的设置，将实物连接完成，然后连接到X3Pi，运行程序，就可以看到这个LED就会开始闪烁了。 $ sudo python3 simple_input.py","text_tokens":["例程","x3pi","按照","py","完成","可以","input","，","的","到","来","然后","将","试一试","运行","吧","实物"," ","程序","看到","这个","设置",".","了","就","闪烁","_","连接","$","会","led","快","。","开始","sudo","python3","simple","刚才"],"title":"运行示例程序","title_tokens":["示例","程序","运行"]},{"location":"hhp/4.1_%E6%95%B0%E5%AD%97%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/#_11","text":"simple_out.py： #!/usr/bin/env python3 import Hobot.GPIO as GPIO import time # 定义使用的GPIO通道为38 output_pin = 38 # BOARD 编码 38 def main (): # 设置管脚编码模式为硬件编号 BOARD GPIO . setmode ( GPIO . BOARD ) # 设置为输出模式，并且初始化为高电平 GPIO . setup ( output_pin , GPIO . OUT , initial = GPIO . HIGH ) # 记录当前管脚状态 curr_value = GPIO . HIGH print ( \"Starting demo now! Press CTRL+C to exit\" ) try : # 间隔1秒时间，循环控制LED灯亮灭 while True : time . sleep ( 1 ) GPIO . output ( output_pin , curr_value ) curr_value ^= GPIO . HIGH finally : GPIO . cleanup () if __name__ == '__main__' : main ()","text_tokens":["ctrl","编号","py","模式","exit","import","output",":","starting","1","\"","setup","定义","并且","状态","编码","gpio","'","控制","true","env","curr","out","，","通道","38","使用","__","秒","main","sleep",".","(","now","初始化","管脚","board","初始","高电平","time","python3","pin","usr","#","initial","间隔","as",",","硬件","try","bin","设置","输出","电平","c","high","while","_","循环","led","当前","灯亮","if","记录","灭","setmode","simple",")","finally","to","print","：","的","press","+","为"," ","value","!","hobot","demo","=","时间","^","cleanup","/","def","name"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"hhp/4.1_%E6%95%B0%E5%AD%97%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/#_12","text":"学习了GPIO的输入与输出功能后，我们就可以做一些自动化的功能了。","text_tokens":["gpio","学习","我们","。","可以","与","自动","功能","自动化","的","输入","，","做","后","一些","输出","了","就"],"title":"数字输入与输出集成","title_tokens":["与","输入","数字","输出","集成"]},{"location":"hhp/4.1_%E6%95%B0%E5%AD%97%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/#_13","text":"比如我们同时连接一个按键和LED灯，尝试实现按键被按下，灯被点亮，松开，灯熄灭，这样的功能。","text_tokens":["我们","这样","功能","，","的","熄灭","和","松开","下","同时","点亮","按键","灯","连接","比如","一个","尝试","led","。","实现","被","按"],"title":"硬件接线","title_tokens":["接线","硬件"]},{"location":"hhp/4.1_%E6%95%B0%E5%AD%97%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/#_14","text":"我们通过这个例程来试一试效果如何？ $ sudo python3 button_led.py 我们来看一下具体的操作，同样的，按照刚才的设置，将实物连接完成，然后连接到X3Pi，运行刚才的程序。按下按键后，就可以看到LED被点亮了，松开之后，LED就熄灭了。","text_tokens":["例程","x3pi","我们","py","按照","完成","可以","的","，","通过","来","到","然后","熄灭","将","试一试","具体","松开","运行","之后"," ","一下","实物","？","程序","如何","看到","这个","设置","后",".","效果","了","就","按下","操作","点亮","按键","_","连接","$","来看","led","同样","button","。","sudo","被","python3","刚才"],"title":"运行示例程序","title_tokens":["示例","程序","运行"]},{"location":"hhp/4.1_%E6%95%B0%E5%AD%97%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/#_15","text":"button_led.py #!/usr/bin/env python3 import Hobot.GPIO as GPIO import time # 定义使用的GPIO通道： # 36号作为输出，可以点亮一个LED # 38号作为输入，可以接一个按钮 led_pin = 36 # BOARD 编码 36 but_pin = 38 # BOARD 编码 38 # 禁用警告信息 GPIO . setwarnings ( False ) def main (): prev_value = None # Pin Setup: GPIO . setmode ( GPIO . BOARD ) # BOARD pin-numbering scheme GPIO . setup ( led_pin , GPIO . OUT ) # LED pin set as output GPIO . setup ( but_pin , GPIO . IN ) # Button pin set as input # Initial state for LEDs: GPIO . output ( led_pin , GPIO . LOW ) print ( \"Starting demo now! Press CTRL+C to exit\" ) try : while True : curr_value = GPIO . input ( but_pin ) if curr_value != prev_value : GPIO . output ( led_pin , curr_value ) prev_value = curr_value print ( \"Outputting {} to Pin {} \" . format ( curr_value , led_pin )) time . sleep ( 1 ) finally : GPIO . cleanup () # cleanup all GPIO if __name__ == '__main__' : main () 基本的配置还是一样的，引入基本的库，然后设置为BOARD模式，然后初始化两个管脚，一个用来读取按键的通断，一个用来控制LED的亮灭，之后只需要判断按键的状态来做出对应的控制LED的动作就可以了。","text_tokens":["ctrl","all","py","模式","基本","可以","接","exit","input","只","禁用","import",":","output","starting","1","\"","setup","定义","就","按键","对应","状态","leds","setwarnings","low","编码","button","gpio","'","控制","outputting","true","env","curr","out","，","通道","38","使用","然后","做出","__","main","判断","读取","引入","sleep",".","(","now","了","but","初始化","for","prev","{","管脚","board","36","号","初始","time","in","python3","两个","pin","usr","警告","#","initial","信息","as","之后",",","需要","try","bin","设置","输出","-","c","配置","动作","set","while","_","亮","还是","用来","一个","led","format","作为","if","。","}","灭","按钮","setmode",")","finally","to","print","：","的","输入","来","press","+","scheme","为"," ","none","value","!","hobot","一样","库","点亮","numbering","demo","state","=","false","通断","cleanup","/","def","name"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"hhp/4.2_PWM%E8%84%89%E5%86%B2%E5%AE%BD%E5%BA%A6%E8%B0%83%E5%88%B6/","text":"PWM脉冲宽度调制 我们已经可以用GPIO控制LED灯一闪一闪亮晶晶了，这样只有亮和灭的状态似乎还是太简单了，能不能对LED的亮度进行调整呢？ 当然没问题，这就要用到接下来学习的PWM脉冲宽度调制了。 PWM脉冲宽度调制原理 在GPIO的数字输入和输出模式中，只有高低电平，高电平一般是3.3V或者5V，低电平就是0V，如果我想要一个折中一点的电压怎么办呢？PWM大家了解一下。 PWM，全称是脉冲宽度调制 ， 是一种对模拟信号电平进行数字编码的方法，通过高分辨率计数器，调制出一定占空比的方波，通过这种方式对模拟信号的电平进行编码。 通俗点来说，如果我们有一个10W的灯泡，在一个小时中亮了半个小时，那我们宏观来看，它在这一个小时中的功率就是5W，这样就相当于是它的电压被降低了。而我们还可以通过改变这一个小时中，灯泡被点亮的时长，来等效出不同的电压。 然后，我们把一个小时缩短为很小的一个时间，到达一定的微分程度，表现出来的就是电压的变化，而这个很小的时间，就是PWM频率的倒数，被点亮的时间在这个很小的时间中所占的百分比就叫做占空比。 这里大家也要注意，虽然PWM在尽力呈现出模拟信号的样子，但本质还是数字信号，因为在给定的某一任何时刻，引脚只能高电平或者低电平。 通过PWM技术，可以让数字电路产生类似模拟信号的效果，从而实现类似的无级控制，比如风扇的转速，或者屏幕的亮度，很多都是通过PWM技术实现的调节。 PWM编程 接下来我们就来试一试，通过PWM让一个LED实现不同亮度的变化，也就是我们常见的呼吸灯了。 硬件接线 还是用这个LED灯，一端连接电阻，再到5V高电平的引脚，另外一端，接到33号引脚的PWM接口。 运行示例程序 大家先来运行例程，看看效果如何。 $ sudo python3 simple_pwm.py 我们来看一下实物的操作，按照刚才的设置，将实物连接完成，然后连接到X3Pi，运行刚才的程序。就可以看到这样的一个呼吸灯的效果了。 代码解析 simple_pwm.py： #!/usr/bin/env python3 import Hobot.GPIO as GPIO import time # 支持PWM的管脚: 32 and 33, 在使用PWM时，必须确保该管脚没有被其他功能占用 output_pin = 33 def main (): # Pin Setup: # Board pin-numbering scheme GPIO . setmode ( GPIO . BOARD ) # 支持的频率范围： 48KHz ~ 192MHz p = GPIO . PWM ( output_pin , 48000 ) # 初始占空比 25%， 先每0.25秒增加5%占空比，达到100%之后再每0.25秒减少5%占空比 val = 25 incr = 5 p . ChangeDutyCycle ( val ) p . start ( val ) print ( \"PWM running. Press CTRL+C to exit.\" ) try : while True : time . sleep ( 0.25 ) if val >= 100 : incr = - incr if val <= 0 : incr = - incr val += incr p . ChangeDutyCycle ( val ) finally : p . stop () GPIO . cleanup () if __name__ == '__main__' : main () 一样的引入GPIO的库，然后设置管脚编码模式为BOARD，然后创建一个PWM的实例化对象p，同时设置他的频率，之后就可以通过ChangeDutyCycle来改变他的占空比，在循环当中，占空比大于等于100时，就会以5%的梯度减小；当小于等于0时，就会以5%的梯度增大。","text_tokens":["py","功能","其他","方波","output","一下","当于","想要","就","100","高","0.25","晶晶","gpio","就是","实现","屏幕","env","数字","使用","引脚","5%","通俗",".","v","该","另外","初始","time","一闪","看看","简单","通过","#","进行","就要","试一试","as","占用","当然","之后","没有","等效","同时","很多","梯度","-","还是","化","怎么","led","会","脉冲","if","。","出来","怎么办",")","setmode","产生","to","宽度","叫做","方法","changedutycycle","pwm","如何","能","代码","hobot","接线","占","百分","我","0","ctrl","本质","exit","小时","用到","再","？","3.3","都","减小","先","以","不能","'","降低","中亮","33","一端","true","支持","全称","刚才","接口","按照","实例","下来","running","5w","百分比","程序","32","到达","数字信号","一","当","呢","模拟","大于","程度","board","了解","调节","确保","等于","python3","那","倒数","在","灯一闪","无级","硬件","数字电路","try","计数","bin","输出","电平","start","相当","对","接下","5","_","循环","连接","一个","转速","微分","192mhz","是","一种","模拟信号","press","改变","频率","将","或者","电阻","这","分辨","这个","对象","!","注意","一样","点亮","numbering","减少","=","常见","已经","sudo","折中","/","<","name","表现","太","可以","他",":","\"","setup","电压","类似","现出","48000","状态","它","高分","编码","25","完成","，","然后","__","缩短","学习","sleep","(","操作","比如","and","亮晶晶","呈现","半个","给定","问题","pin","中所","呼吸","分辨率","运行","占空比","但","设置","只有","这种","也","灭","一般","simple","48khz","来说","：","的","输入","+","灯泡","scheme","为","和",">","有"," ","任何","某","一点","数字编码","$","中","时长","点","cleanup","把","如果","例程","这样","模式","只能","技术","似乎","import","实物","编程","0v","电路","方式","达到","数字电","样子","相当于","val","一定","让","10w","p","控制","每","亮度","被","还","示例","我们","没","秒","宏观","main","incr","这里","引入","功率","何时","信号","了","辨率","灯","从而","呈现出","因为","大家","管脚","当中","号","高电平","创建","出","100%","x3pi","计数器","必须","到","接下来","usr","解析","5v","调制",",","风扇","stop","很小","变化","增大","虽然","c","while","亮","时刻","25%","任何时刻","来看","范围","而","小于","finally","print","用","来","不同","调整","；","看到","高分辨率","要","效果","低电平","库","时","接到","~","增加","原理","时间","尽力","def"],"title":"PWM脉冲宽度调制","title_tokens":["pwm","宽度","脉冲","调制"]},{"location":"hhp/4.2_PWM%E8%84%89%E5%86%B2%E5%AE%BD%E5%BA%A6%E8%B0%83%E5%88%B6/#pwm","text":"我们已经可以用GPIO控制LED灯一闪一闪亮晶晶了，这样只有亮和灭的状态似乎还是太简单了，能不能对LED的亮度进行调整呢？ 当然没问题，这就要用到接下来学习的PWM脉冲宽度调制了。","text_tokens":["太","我们","这样","问题","宽度","可以","简单","用","，","的","没","接下来","似乎","下来","进行","就要","调制","和","灯一闪","这","用到","当然","学习","调整"," ","？","pwm","能","呢","了","只有","对","接下","亮","还是","状态","晶晶","已经","亮晶晶","led","脉冲","不能","gpio","控制","。","灭","亮度","一闪"],"title":"PWM脉冲宽度调制","title_tokens":["pwm","宽度","脉冲","调制"]},{"location":"hhp/4.2_PWM%E8%84%89%E5%86%B2%E5%AE%BD%E5%BA%A6%E8%B0%83%E5%88%B6/#pwm_1","text":"在GPIO的数字输入和输出模式中，只有高低电平，高电平一般是3.3V或者5V，低电平就是0V，如果我想要一个折中一点的电压怎么办呢？PWM大家了解一下。 PWM，全称是脉冲宽度调制 ， 是一种对模拟信号电平进行数字编码的方法，通过高分辨率计数器，调制出一定占空比的方波，通过这种方式对模拟信号的电平进行编码。 通俗点来说，如果我们有一个10W的灯泡，在一个小时中亮了半个小时，那我们宏观来看，它在这一个小时中的功率就是5W，这样就相当于是它的电压被降低了。而我们还可以通过改变这一个小时中，灯泡被点亮的时长，来等效出不同的电压。 然后，我们把一个小时缩短为很小的一个时间，到达一定的微分程度，表现出来的就是电压的变化，而这个很小的时间，就是PWM频率的倒数，被点亮的时间在这个很小的时间中所占的百分比就叫做占空比。 这里大家也要注意，虽然PWM在尽力呈现出模拟信号的样子，但本质还是数字信号，因为在给定的某一任何时刻，引脚只能高电平或者低电平。 通过PWM技术，可以让数字电路产生类似模拟信号的效果，从而实现类似的无级控制，比如风扇的转速，或者屏幕的亮度，很多都是通过PWM技术实现的调节。","text_tokens":["如果","表现","模式","这样","可以","本质","只能","小时","技术","方波","一下","3.3","？","都","0v","当于","电路","电压","方式","数字电","样子","类似","想要","就","现出","相当于","一定","高","它","让","高分","10w","编码","gpio","就是","控制","降低","中亮","实现","亮度","被","屏幕","还","全称","我们","，","数字","然后","宏观","缩短","5w","引脚","百分比","这里","通俗","功率","到达","何时","信号","数字信号","一","v","呢","模拟","了","辨率","从而","比如","呈现出","因为","大家","程度","了解","调节","高电平","出","呈现","半个","那","给定","计数器","倒数","通过","进行","5v","中所","在","调制","分辨率","占空比","等效","无级","数字电路","计数","但","风扇","很多","很小","变化","输出","电平","虽然","只有","这种","相当","对","也","时刻","还是","任何时刻","来看","一个","转速","怎么","脉冲","微分","。","出来","而","一般","怎么办","产生","是","来说","宽度","一种","模拟信号","的","输入","来","不同","改变","灯泡","为","频率","或者","和","叫做","这","有","方法"," ","任何","分辨","pwm","某","一点","这个","高分辨率","要","效果","注意","低电平","点亮","数字编码","占","百分","我","时间","中","折中","时长","点","尽力","把"],"title":"PWM脉冲宽度调制原理","title_tokens":["宽度","pwm","原理","脉冲","调制"]},{"location":"hhp/4.2_PWM%E8%84%89%E5%86%B2%E5%AE%BD%E5%BA%A6%E8%B0%83%E5%88%B6/#pwm_2","text":"接下来我们就来试一试，通过PWM让一个LED实现不同亮度的变化，也就是我们常见的呼吸灯了。","text_tokens":["我们","，","接下来","通过","来","不同","下来","的","呼吸","试一试","pwm","变化","了","就","接下","也","灯","让","一个","常见","led","就是","。","实现","亮度"],"title":"PWM编程","title_tokens":["pwm","编程"]},{"location":"hhp/4.2_PWM%E8%84%89%E5%86%B2%E5%AE%BD%E5%BA%A6%E8%B0%83%E5%88%B6/#_1","text":"还是用这个LED灯，一端连接电阻，再到5V高电平的引脚，另外一端，接到33号引脚的PWM接口。","text_tokens":["用","，","到","的","5v","电阻","再","引脚","pwm","这个","电平","灯","接到","连接","还是","led","另外","。","33","号","一端","高电平","接口"],"title":"硬件接线","title_tokens":["接线","硬件"]},{"location":"hhp/4.2_PWM%E8%84%89%E5%86%B2%E5%AE%BD%E5%BA%A6%E8%B0%83%E5%88%B6/#_2","text":"大家先来运行例程，看看效果如何。 $ sudo python3 simple_pwm.py 我们来看一下实物的操作，按照刚才的设置，将实物连接完成，然后连接到X3Pi，运行刚才的程序。就可以看到这样的一个呼吸灯的效果了。","text_tokens":["看看","例程","x3pi","我们","py","按照","这样","完成","可以","，","的","到","来","然后","呼吸","将","运行"," ","一下","实物","程序","pwm","如何","看到","设置",".","效果","先","了","就","操作","灯","_","连接","$","来看","一个","大家","。","sudo","python3","simple","刚才"],"title":"运行示例程序","title_tokens":["示例","程序","运行"]},{"location":"hhp/4.2_PWM%E8%84%89%E5%86%B2%E5%AE%BD%E5%BA%A6%E8%B0%83%E5%88%B6/#_3","text":"simple_pwm.py： #!/usr/bin/env python3 import Hobot.GPIO as GPIO import time # 支持PWM的管脚: 32 and 33, 在使用PWM时，必须确保该管脚没有被其他功能占用 output_pin = 33 def main (): # Pin Setup: # Board pin-numbering scheme GPIO . setmode ( GPIO . BOARD ) # 支持的频率范围： 48KHz ~ 192MHz p = GPIO . PWM ( output_pin , 48000 ) # 初始占空比 25%， 先每0.25秒增加5%占空比，达到100%之后再每0.25秒减少5%占空比 val = 25 incr = 5 p . ChangeDutyCycle ( val ) p . start ( val ) print ( \"PWM running. Press CTRL+C to exit.\" ) try : while True : time . sleep ( 0.25 ) if val >= 100 : incr = - incr if val <= 0 : incr = - incr val += incr p . ChangeDutyCycle ( val ) finally : p . stop () GPIO . cleanup () if __name__ == '__main__' : main () 一样的引入GPIO的库，然后设置管脚编码模式为BOARD，然后创建一个PWM的实例化对象p，同时设置他的频率，之后就可以通过ChangeDutyCycle来改变他的占空比，在循环当中，占空比大于等于100时，就会以5%的梯度减小；当小于等于0时，就会以5%的梯度增大。","text_tokens":["ctrl","py","模式","他","可以","exit","功能","import","其他","再",":","output","\"","setup","减小","达到","先","就","100","48000","val","<","以","0.25","编码","gpio","'","p","每","33","true","被","支持","25","env","实例","，","使用","然后","__","秒","running","main","incr","5%","32","引入","sleep",".","(","当","该","and","大于","管脚","当中","board","确保","等于","初始","time","python3","创建","100%","必须","pin","usr","通过","#","在","as","占用","之后","没有",",","占空比","同时","try","bin","stop","设置","梯度","增大","start","-","c","5","_","while","循环","25%","一个","化","范围","会","if","。","192mhz","小于","setmode","simple",")","finally","48khz","to","print","：","的","来","press","改变","+","scheme","为","频率",">","；"," ","changedutycycle","pwm","对象","!","hobot","一样","库","时","numbering","~","减少","=","增加","0","cleanup","/","def","name"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"hhp/4.3_UART%E5%BC%82%E6%AD%A5%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/","text":"UART串口通信 现在的传感器和执行器种类越来越多，需要和控制器传输的数据也是多种多样，只用GPIO来控制和读取的话，只有0和1的状态，未免还是有点麻烦，各种各样的通信方法也层出不穷，UART串口通信绝对是最为常用的一种。 串口通信原理 串行通信是一种通讯协议，也可以简称为串口，可以理解为数据是串成一串的，所以也就只能一位一位的发送，这样传输的速度虽然受到了限制，但是对硬件线路的要求小，只需要一对传输线，一个发送，一个接收，就可以实现双向通信了。 一般情况下，串口模块发送数据的管脚叫做TX，接收数据的管脚叫做RX。发送端发过去的数据，需要对方串口模块的接收端来接收，所以一侧发送端的TX需要连接到另外一侧的接收端RX，接收和发送在两方看来是相对的，所以我们接线的时候，要记住永远是TX引脚连接到RX引脚，接反了数据就传输不了了。 硬件连接 接下来，我们就尝试通过一个串口模块来实现电脑和旭日X3Pi的串口通信。 在接线方面，我们先交叉连接串口模块和旭日X3Pi的RX、TX，同时为了让两边具有相同的参考电平，还要将两者的GND连接到一起，然后再把串口模块连接到电脑就可以了。 运行示例程序 接下来就可以运行串口通信的例程了。 $ sudo python3 test_serial.py 实物接线完成后，在旭日X3派的终端中输入指令启动例程，很快就可以在终端中看到串口向外发送的数据了。 在串口连接的电脑中打开一个串口软件，用来接收和发送数据，设置好端口和波特率，就能看到旭日X3派发过来的数据了。我们再使用电脑的串口软件尝试下发送数据给旭日X3派，输入1234，点击发送，可以看到，X3Pi的终端这边也成功的接收到了数据并且打印出来了。 代码解析 test_serial.py： #!/usr/bin/env python3 import sys import os import time # 导入python串口库 import serial import serial.tools.list_ports def serialTest (): print ( \"List of enabled UART:\" ) os . system ( 'ls /dev/tty[a-zA-Z]*' ) uart_dev = input ( \"请输入需要测试的串口设备名:\" ) baudrate = input ( \"请输入波特率(9600,19200,38400,57600,115200,921600):\" ) try : ser = serial . Serial ( uart_dev , int ( baudrate ), timeout = 1 ) # 1s timeout except Exception as e : print ( \"open serial failed! \\n \" ) print ( ser ) print ( \"Starting demo now! Press CTRL+C to exit\" ) while True : test_data = \"AA55\" write_num = ser . write ( test_data . encode ( 'UTF-8' )) print ( \"Send: \" , test_data ) received_data = ser . read ( write_num ) . decode ( 'UTF-8' ) if received_data : print ( \"Recv: \" , received_data ) time . sleep ( 1 ) ser . close () return 0 if __name__ == '__main__' : if serialTest () != 0 : print ( \"Serial test failed!\" ) else : print ( \"Serial test success!\" ) X3Pi这边如果要使用串口，直接使用serial库就可以了，这里我们先调用系统的库，打印出当前有哪些串口，然后手动输入选择串口的设备名，再输入串口的波特率，就可以进项串口的初始化了，初始化成功之后就会进入循环。 循环中，X3Pi会每隔一秒发送一次AA55，同时还会判断是否接收到了数据，如果接收到了数据也会打印出来。","text_tokens":["双向通信","各样","py","种类","timeout","指令","打开","有点","failed","好","starting","双向","派","并且","端口","就","gpio","记住","实现","进项","env","名","使用","选择","多种","引脚","1s",".","麻烦","int","参考","尝试","最为","另外","open","具有","初始","time","导入","1234","串行","越来越","115200","通过","#","波特率","close","交叉","向外","as","之后","需要","下","这边","同时","很快","38400","各种各样","-","一侧","还是","速度","会","波特","8","if","。","出来",")","一次","为了","to","执行","叫做","方法","tools","过去","能","还会","代码","接线","success","端发","0","方面","python","通信","enabled","理解","传输","n","ctrl","exit","input","of","越来","再","两方","的话","先","过来","'","不了","true","系统","但是","端的","下来","recv","成功","程序","a","x3","简称","两边","调用","serial","一位","exception","python3","921600","utf","对方","在","sys","ls","硬件","try","bin","执行器","电平","对","接下","_","循环","连接","用来","一个","测试","发送","read","时候","aa55","*","线路","是","一种","encode","press","将","\\","旭日","!","启动","demo","多","=","一秒","sudo","/","name","只","可以","哪些","传感器","相对","进入","]","终端",":","\"","后","、","状态","19200","接反","发送数据","write","完成","tx","，","然后","直接","decode","__","判断","手动","za","读取","绝对","sleep","(","now","tty","初始化","相同","所以","接收端","test","每隔","dev","运行","层出不穷","设置","串口","只有","也","uart","当前","一般","ser","点击","：","的","输入","只用","+","为","和","常用","有"," ","设备","57600","gnd","$","各种","中","list","一对","把","如果","例程","这样","只能","os","数据","import","多样","实物","1","要求","serialtest","模块","小","受到","传感","让","打印","baudrate","控制","def","软件","示例","我们","main","情况","e","这里","ports","请","了","是否","管脚","限制","永远","rx","return","出","协议","电脑","x3pi","到","接下来","usr","num","解析","传输线","一串","通讯","控制器",",","except","虽然","现在","c","两者","while","给","接收数据","send","未免","一起","看来","串成","派发","else","print","接收","来","system","received","看到","要","感器","库","data","z","多种多样","原理","还要","[","9600"],"title":"UART异步串口通信","title_tokens":["串口","uart","通信","异步"]},{"location":"hhp/4.3_UART%E5%BC%82%E6%AD%A5%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/#uart","text":"现在的传感器和执行器种类越来越多，需要和控制器传输的数据也是多种多样，只用GPIO来控制和读取的话，只有0和1的状态，未免还是有点麻烦，各种各样的通信方法也层出不穷，UART串口通信绝对是最为常用的一种。","text_tokens":["是","各样","一种","种类","越来越","的","，","数据","来","只用","传感器","越来","和","执行","多样","有点","常用","方法","控制器","需要","多种","读取","1","层出不穷","绝对","串口","的话","执行器","现在","各种各样","只有","麻烦","感器","也","多种多样","还是","状态","传感","多","各种","uart","0","最为","gpio","控制","。","通信","未免","传输"],"title":"UART串口通信","title_tokens":["串口","uart","通信"]},{"location":"hhp/4.3_UART%E5%BC%82%E6%AD%A5%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/#_1","text":"串行通信是一种通讯协议，也可以简称为串口，可以理解为数据是串成一串的，所以也就只能一位一位的发送，这样传输的速度虽然受到了限制，但是对硬件线路的要求小，只需要一对传输线，一个发送，一个接收，就可以实现双向通信了。 一般情况下，串口模块发送数据的管脚叫做TX，接收数据的管脚叫做RX。发送端发过去的数据，需要对方串口模块的接收端来接收，所以一侧发送端的TX需要连接到另外一侧的接收端RX，接收和发送在两方看来是相对的，所以我们接线的时候，要记住永远是TX引脚连接到RX引脚，接反了数据就传输不了了。","text_tokens":["双向通信","这样","只","可以","只能","数据","相对","两方","双向","要求","就","模块","小","受到","接反","发送数据","不了","记住","实现","但是","我们","tx","，","端的","情况","引脚","了","简称","管脚","限制","另外","永远","一位","rx","接收端","所以","协议","串行","对方","到","在","传输线","一串","通讯","需要","下","硬件","串口","虽然","对","也","一侧","连接","速度","一个","接收数据","发送","。","看来","一般","时候","串成","线路","是","一种","的","接收","来","为","和","叫做"," ","过去","要","接线","端发","通信","理解","一对","传输"],"title":"串口通信原理","title_tokens":["串口","原理","通信"]},{"location":"hhp/4.3_UART%E5%BC%82%E6%AD%A5%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/#_2","text":"接下来，我们就尝试通过一个串口模块来实现电脑和旭日X3Pi的串口通信。 在接线方面，我们先交叉连接串口模块和旭日X3Pi的RX、TX，同时为了让两边具有相同的参考电平，还要将两者的GND连接到一起，然后再把串口模块连接到电脑就可以了。","text_tokens":["为了","电脑","x3pi","我们","可以","tx","，","接下来","通过","来","的","下来","到","然后","交叉","在","将","和","旭日","再"," ","同时","串口","先","、","电平","了","就","模块","两者","接下","两边","gnd","接线","连接","参考","让","尝试","一个","还要","方面","相同","。","rx","具有","通信","一起","实现","把"],"title":"硬件连接","title_tokens":["连接","硬件"]},{"location":"hhp/4.3_UART%E5%BC%82%E6%AD%A5%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/#_3","text":"接下来就可以运行串口通信的例程了。 $ sudo python3 test_serial.py 实物接线完成后，在旭日X3派的终端中输入指令启动例程，很快就可以在终端中看到串口向外发送的数据了。 在串口连接的电脑中打开一个串口软件，用来接收和发送数据，设置好端口和波特率，就能看到旭日X3派发过来的数据了。我们再使用电脑的串口软件尝试下发送数据给旭日X3派，输入1234，点击发送，可以看到，X3Pi的终端这边也成功的接收到了数据并且打印出来了。","text_tokens":["电脑","软件","例程","点击","x3pi","test","py","我们","可以","完成","的","接下来","，","输入","指令","下来","数据","打开","接收","波特率","使用","在","向外","成功","和","旭日","终端","运行","再"," ","实物","好","下","这边","看到","派","设置","后","很快","串口",".","启动","能","端口","了","就","x3","并且","接下","也","_","接线","连接","给","$","到","过来","用来","一个","尝试","打印","波特","发送","发送数据","serial","。","出来","通信","中","sudo","python3","派发","1234"],"title":"运行示例程序","title_tokens":["示例","程序","运行"]},{"location":"hhp/4.3_UART%E5%BC%82%E6%AD%A5%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/#_4","text":"test_serial.py： #!/usr/bin/env python3 import sys import os import time # 导入python串口库 import serial import serial.tools.list_ports def serialTest (): print ( \"List of enabled UART:\" ) os . system ( 'ls /dev/tty[a-zA-Z]*' ) uart_dev = input ( \"请输入需要测试的串口设备名:\" ) baudrate = input ( \"请输入波特率(9600,19200,38400,57600,115200,921600):\" ) try : ser = serial . Serial ( uart_dev , int ( baudrate ), timeout = 1 ) # 1s timeout except Exception as e : print ( \"open serial failed! \\n \" ) print ( ser ) print ( \"Starting demo now! Press CTRL+C to exit\" ) while True : test_data = \"AA55\" write_num = ser . write ( test_data . encode ( 'UTF-8' )) print ( \"Send: \" , test_data ) received_data = ser . read ( write_num ) . decode ( 'UTF-8' ) if received_data : print ( \"Recv: \" , received_data ) time . sleep ( 1 ) ser . close () return 0 if __name__ == '__main__' : if serialTest () != 0 : print ( \"Serial test failed!\" ) else : print ( \"Serial test success!\" ) X3Pi这边如果要使用串口，直接使用serial库就可以了，这里我们先调用系统的库，打印出当前有哪些串口，然后手动输入选择串口的设备名，再输入串口的波特率，就可以进项串口的初始化了，初始化成功之后就会进入循环。 循环中，X3Pi会每隔一秒发送一次AA55，同时还会判断是否接收到了数据，如果接收到了数据也会打印出来。","text_tokens":["如果","ctrl","py","可以","exit","os","input","timeout","数据","of","哪些","import","进入","]","再",":","failed","starting","1","\"","先","就","serialtest","19200","打印","baudrate","'","true","进项","def","系统","env","名","write","我们","，","使用","recv","直接","然后","decode","选择","__","成功","main","判断","1s","手动","za","e","这里","ports","sleep","a","请",".","(","now","了","int","tty","初始化","name","是否","open","调用","serial","exception","初始","time","导入","return","python3","出","x3pi","test","921600","每隔","dev","115200","utf","usr","到","#","num","波特率","close","as","之后",",","sys","ls","需要","这边","同时","try","bin","38400","串口","except","-","c","while","_","循环","也","send","测试","会","uart","当前","波特","8","发送","if","。","出来","read","aa55",")","*","ser","else","一次","to","print","：","输入","的","encode","接收","press","+","system","\\","received","有"," ","tools","设备","还会","!","57600","要","库","data","z","success","demo","=","0","一秒","python","enabled","中","list","/","[","9600","n"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"hhp/4.4_SPI%E5%90%8C%E6%AD%A5%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1/","text":"SPI同步串行通信 UART串口通信中的数据只能一位一位的传输，如果数据量比较大的时候，传输速率会受到很大影响，此时我们就可以考虑使用同步串行通信了，比如SPI。 SPI通信原理 SPI，全称是Serial Peripheral Interface，也就是串行外设接口，同样是一种通信协议，在很多芯片中都有集成。 相比之前学习的UART串口通信，他多了两根线，其中一个是时钟信号，另一个是设备使能信号，用来控制设备是否启用，所以也产生了主从设备的概念。 MISO ：Master Input Slave Output，主设备数据输入，从设备数据输出； MOSI ：Master Output Slave Input，主设备数据输出，从设备数据输入； SCLK ：Serial Clock，时钟信号，由主设备产生； CS ：Chip Select，从设备使能信号，由主设备控制。 这样，在一组SPI通信的系统中，可以连接多个设备，想要和哪个设备通信时，就使能这个设备，除能其他设备。 我们在开发中常见的SPI设备会有一些传感器，还有电阻屏之类的。 硬件连线 在SPI的通信中，有一个管脚负责发送，另外一个管脚负责接收，如果我们把同一组SPI的发送和接收接到一起，岂不是能接收到自己发送的数据吗？ 我们不妨来试一试，这里使用一个跳线帽直接把19，21两个SPI的通信管脚短接。 运行示例程序 大家来运行例程，看看会发生什么？ $ sudo python3 test_spi.py 在旭日X3派的终端中，输入运行例程的指令，接下来我们就可以看到通过SPI传输并收到的数据啦，相当于是左手传递给右手，自己给自己循环传输数据了。 代码解析 test_spi.py： #!/usr/bin/env python3 import sys import os import time # 导入spidev模块 import spidev def BytesToHex ( Bytes ): return '' . join ([ \"0x %02X \" % x for x in Bytes ]) . strip () def spidevTest (): # 设置spi的bus号（0, 1, 2）和片选(0, 1) spi_bus = input ( \"Please input SPI bus num:\" ) spi_device = input ( \"Please input SPI cs num:\" ) # 创建spidev类的对象以访问基于spidev的Python函数。 spi = spidev . SpiDev () # 打开spi总线句柄 spi . open ( int ( spi_bus ), int ( spi_device )) # 设置 spi 频率为 12MHz spi . max_speed_hz = 12000000 print ( \"Starting demo now! Press CTRL+C to exit\" ) # 发送 [0x55, 0xAA], 接收的数据应该也是 [0x55, 0xAA] try : while True : resp = spi . xfer2 ([ 0x55 , 0xAA ]) print ( BytesToHex ( resp )) time . sleep ( 1 ) except KeyboardInterrupt : spi . close () if __name__ == '__main__' : print ( \"List of enabled spi controllers:\" ) os . system ( 'ls /dev/spidev*' ) spidevTest () 在python中使用spidev这个库，初始化X3Pi的SPI，之后使用xerf2发送数据，同时接收数据，并打印出来，会发现打印出来的就是我们发送的。","text_tokens":["如果","x","keyboardinterrupt","ctrl","例程","2","句柄","这样","py","只能","可以","他","其中","input","select","数据","指令","cs","os","打开","exit","传感器","of","除能","import","21","其他","]","同","终端","output","屏",":","？","都","1","\"","starting","同步","派","当于","启用","使","就","想要","模块","%","02x","基于","受到","负责","相当于","以","传感","收到","打印","xerf2","就是","chip","'","发送数据","控制","dev","什么","true","spidevtest","0xaa","系统","开发","全称","env","线","19","接口","还有","连线","由主","自己","示例","我们","应该","，","下来","使用","直接","片选","__","main","函数","学习","帽","岂","不妨","这里","程序","sleep","device","一些","信号",".","(","了","now","相比","int","x3","啦","跳线","概念","数据量","比如","发生","时钟","for","初始化","传输速率","0x","大家","是否","管脚","strip","很大","并","另外","open","serial","一位","peripheral","传输数据","吗","比较","please","号","初始","time","导入","return","python3","in","所以","创建","协议","串行","另","看看","x3pi","芯片","test","两个","spidev","主","之类","resp","到","接下来","interface","通过","#","usr","num","解析","close","发现","在","总线","从","试一试","运行","之后",",","sys","ls","硬件","同时","xfer2","try","bin","很多","设置","串口","speed","考虑","输出","except","c","相当","spi","此时","哪个","访问","接下","也","_","循环","while","hz","controllers","连接","给","类","用来","一个","接收数据","会","uart","外设","同样","发送","12mhz","if","。","短接","出来","不是","一起","通信协议","0x55","时候",")","*","产生","是","传递","master","miso","print","to","：","一种","影响","的","输入","接收","来","（","press","大","速率","+","为","频率","system","和","电阻","旭日","有","；"," ","sclk","[","join","bytestohex","看到","这个","设备","bus","能","）","slave","!","代码","对象","感器","clock","主从","bytes","库","时","多个","左手","max","接到","之前","$","demo","多","=","常见","右手","原理","集成","0","两根","一组","python","通信","中","使能","sudo","12000000","list","enabled","mosi","传输","/","把","def","name","并打印"],"title":"SPI同步串行通信","title_tokens":["同步","通信","串行","spi"]},{"location":"hhp/4.4_SPI%E5%90%8C%E6%AD%A5%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1/#spi","text":"UART串口通信中的数据只能一位一位的传输，如果数据量比较大的时候，传输速率会受到很大影响，此时我们就可以考虑使用同步串行通信了，比如SPI。","text_tokens":["如果","串行","我们","只能","影响","可以","的","数据","，","速率","大","使用","同步","串口","考虑","了","就","spi","此时","受到","数据量","比如","传输速率","会","uart","很大","一位","。","比较","通信","中","时候","传输"],"title":"SPI同步串行通信","title_tokens":["同步","通信","串行","spi"]},{"location":"hhp/4.4_SPI%E5%90%8C%E6%AD%A5%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1/#spi_1","text":"SPI，全称是Serial Peripheral Interface，也就是串行外设接口，同样是一种通信协议，在很多芯片中都有集成。 相比之前学习的UART串口通信，他多了两根线，其中一个是时钟信号，另一个是设备使能信号，用来控制设备是否启用，所以也产生了主从设备的概念。 MISO ：Master Input Slave Output，主设备数据输入，从设备数据输出； MOSI ：Master Output Slave Input，主设备数据输出，从设备数据输入； SCLK ：Serial Clock，时钟信号，由主设备产生； CS ：Chip Select，从设备使能信号，由主设备控制。 这样，在一组SPI通信的系统中，可以连接多个设备，想要和哪个设备通信时，就使能这个设备，除能其他设备。 我们在开发中常见的SPI设备会有一些传感器，还有电阻屏之类的。","text_tokens":["这样","他","其中","可以","input","select","数据","cs","传感器","除能","其他","output","屏","都","启用","使","想要","就","传感","就是","chip","控制","系统","开发","全称","线","接口","还有","由主","我们","，","学习","一些","信号","了","相比","概念","时钟","是否","serial","peripheral","所以","协议","串行","另","芯片","主","之类","interface","在","从","很多","串口","输出","spi","哪个","也","连接","用来","一个","会","uart","外设","同样","。","通信协议","产生","是","master","miso","：","一种","的","输入","和","电阻","有","；"," ","sclk","这个","设备","能","slave","感器","clock","主从","时","多个","之前","多","常见","集成","两根","一组","通信","中","使能","mosi"],"title":"SPI通信原理","title_tokens":["原理","通信","spi"]},{"location":"hhp/4.4_SPI%E5%90%8C%E6%AD%A5%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1/#_1","text":"在SPI的通信中，有一个管脚负责发送，另外一个管脚负责接收，如果我们把同一组SPI的发送和接收接到一起，岂不是能接收到自己发送的数据吗？ 我们不妨来试一试，这里使用一个跳线帽直接把19，21两个SPI的通信管脚短接。","text_tokens":["如果","自己","我们","两个","的","，","接收","到","数据","来","使用","直接","在","和","试一试","21","有","同","帽"," ","？","岂","不妨","这里","能","spi","跳线","接到","负责","一个","管脚","发送","另外","一组","吗","短接","。","通信","中","一起","不是","19","把"],"title":"硬件连线","title_tokens":["连线","硬件"]},{"location":"hhp/4.4_SPI%E5%90%8C%E6%AD%A5%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1/#_2","text":"大家来运行例程，看看会发生什么？ $ sudo python3 test_spi.py 在旭日X3派的终端中，输入运行例程的指令，接下来我们就可以看到通过SPI传输并收到的数据啦，相当于是左手传递给右手，自己给自己循环传输数据了。","text_tokens":["看看","是","传递","例程","自己","test","py","我们","可以","，","的","输入","来","指令","下来","接下来","通过","数据","在","旭日","终端","运行"," ","？","看到","派","当于",".","了","相当","spi","就","x3","啦","接下","左手","_","循环","相当于","给","发生","$","大家","收到","会","右手","并","传输数据","。","中","什么","sudo","python3","传输"],"title":"运行示例程序","title_tokens":["示例","程序","运行"]},{"location":"hhp/4.4_SPI%E5%90%8C%E6%AD%A5%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1/#_3","text":"test_spi.py： #!/usr/bin/env python3 import sys import os import time # 导入spidev模块 import spidev def BytesToHex ( Bytes ): return '' . join ([ \"0x %02X \" % x for x in Bytes ]) . strip () def spidevTest (): # 设置spi的bus号（0, 1, 2）和片选(0, 1) spi_bus = input ( \"Please input SPI bus num:\" ) spi_device = input ( \"Please input SPI cs num:\" ) # 创建spidev类的对象以访问基于spidev的Python函数。 spi = spidev . SpiDev () # 打开spi总线句柄 spi . open ( int ( spi_bus ), int ( spi_device )) # 设置 spi 频率为 12MHz spi . max_speed_hz = 12000000 print ( \"Starting demo now! Press CTRL+C to exit\" ) # 发送 [0x55, 0xAA], 接收的数据应该也是 [0x55, 0xAA] try : while True : resp = spi . xfer2 ([ 0x55 , 0xAA ]) print ( BytesToHex ( resp )) time . sleep ( 1 ) except KeyboardInterrupt : spi . close () if __name__ == '__main__' : print ( \"List of enabled spi controllers:\" ) os . system ( 'ls /dev/spidev*' ) spidevTest () 在python中使用spidev这个库，初始化X3Pi的SPI，之后使用xerf2发送数据，同时接收数据，并打印出来，会发现打印出来的就是我们发送的。","text_tokens":["x","keyboardinterrupt","ctrl","2","句柄","py","exit","os","input","数据","打开","cs","of","import","]",":","starting","1","\"","模块","%","02x","基于","以","打印","xerf2","'","发送数据","就是","true","spidevtest","0xaa","env","应该","我们","，","使用","片选","__","main","函数","sleep","device",".","(","now","int","初始化","for","0x","strip","open","please","号","初始","time","导入","return","in","python3","创建","x3pi","test","spidev","dev","resp","usr","#","num","close","发现","在","总线","之后",",","sys","ls","同时","xfer2","try","bin","设置","speed","except","c","spi","访问","也","_","while","controllers","hz","类","接收数据","会","发送","12mhz","if","。","出来","0x55",")","*","是","to","print","：","的","（","接收","press","+","为","频率","system","和"," ","join","bytestohex","这个","）","bus","对象","!","bytes","库","max","demo","=","0","python","enabled","中","12000000","list","/","[","def","name","并打印"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"hhp/4.5_I2C%E5%90%8C%E6%AD%A5%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1/","text":"I2C同步串行通信 SPI通信虽然功能更强大了，但是需要4根线做连接，还是有点复杂，接下来I2C的连线就简单很多了。 I2C通信原理 I2C也是一种常用的串行通信方式，和SPI一样可以连接多个设备，重点是它只需要两根线就可以完成。 不过他的两根线和UART不同，不全是传输数据用的，I2C中的一根线是时钟线，另一根才是传输数据的，这根线可以双向的传输数据。 I2C通信中可以有多个主设备或者从设备，只要能通过地址找到彼此的位置即可。 主器件用于启动总线传送数据，并产生时钟给各种从机，此时任何被寻址的器件均被认为是从机。在总线上主和从、发和收的关系不是恒定的，而取决于此时数据传送方向。如果主机要发送数据给从机，主机首先得找到从机的地址，然后主动发送数据过去，最后也得由主机终止数据传送；如果主机要接收从机的数据，同样由主机得找到从机的地址，然后主机接收从器件发送的数据，最后由主机终止接收过程。 因为I2C的特性，使用I2C的设备比SPI多很多，比如图中的紫外线传感器，陀螺仪之类的，都是使用I2C进行通信的。 硬件接线 我们找来一个常用的陀螺仪模块，按照这里的接线图连接到旭日X3派的40PIN接口上，这里除了I2C通信的两根线之外，另外两根是电源线，负责给这个模块供电的，让它正常工作起来。 运行示例程序 接线是挺简单的，我们继续来运行这个例程，看下能否收到数据。 $ sudo python3 mpu6500_i2c.py 在终端启动例程，很快就可以看到通过I2C读取到了大量传感器的数据，这些就是陀螺仪模块的原始数据，收到之后我们就可以进行结算处理啦，这就是我们后续机器人开发的需要解决的问题了。 代码解析 mpu6500_i2c.py： #!/usr/bin/env python3 import smbus , time def MPU6050_start (): # alter sample rate (stability) samp_rate_div = 0 # sample rate = 8 kHz/(1+samp_rate_div) bus . write_byte_data ( MPU6050_ADDR , SMPLRT_DIV , samp_rate_div ) time . sleep ( 0.1 ) # reset all sensors bus . write_byte_data ( MPU6050_ADDR , PWR_MGMT_1 , 0x00 ) time . sleep ( 0.1 ) # power management and crystal settings bus . write_byte_data ( MPU6050_ADDR , PWR_MGMT_1 , 0x01 ) time . sleep ( 0.1 ) #Write to Configuration register bus . write_byte_data ( MPU6050_ADDR , CONFIG , 0 ) time . sleep ( 0.1 ) #Write to Gyro configuration register gyro_config_sel = [ 0b00000 , 0b010000 , 0b10000 , 0b11000 ] # byte registers gyro_config_vals = [ 250.0 , 500.0 , 1000.0 , 2000.0 ] # degrees/sec gyro_indx = 0 bus . write_byte_data ( MPU6050_ADDR , GYRO_CONFIG , int ( gyro_config_sel [ gyro_indx ])) time . sleep ( 0.1 ) #Write to Accel configuration register accel_config_sel = [ 0b00000 , 0b01000 , 0b10000 , 0b11000 ] # byte registers accel_config_vals = [ 2.0 , 4.0 , 8.0 , 16.0 ] # g (g = 9.81 m/s^2) accel_indx = 0 bus . write_byte_data ( MPU6050_ADDR , ACCEL_CONFIG , int ( accel_config_sel [ accel_indx ])) time . sleep ( 0.1 ) # interrupt register (related to overflow of data [FIFO]) bus . write_byte_data ( MPU6050_ADDR , INT_ENABLE , 1 ) time . sleep ( 0.1 ) return gyro_config_vals [ gyro_indx ], accel_config_vals [ accel_indx ] def read_raw_bits ( register ): # read accel and gyro values high = bus . read_byte_data ( MPU6050_ADDR , register ) low = bus . read_byte_data ( MPU6050_ADDR , register + 1 ) # combine higha and low for unsigned bit value value = (( high << 8 ) | low ) # convert to +- value if ( value > 32768 ): value -= 65536 return value def mpu6050_conv (): # raw acceleration bits acc_x = read_raw_bits ( ACCEL_XOUT_H ) acc_y = read_raw_bits ( ACCEL_YOUT_H ) acc_z = read_raw_bits ( ACCEL_ZOUT_H ) # raw temp bits ## t_val = read_raw_bits(TEMP_OUT_H) # uncomment to read temp # raw gyroscope bits gyro_x = read_raw_bits ( GYRO_XOUT_H ) gyro_y = read_raw_bits ( GYRO_YOUT_H ) gyro_z = read_raw_bits ( GYRO_ZOUT_H ) #convert to acceleration in g and gyro dps a_x = ( acc_x / ( 2.0 ** 15.0 )) * accel_sens a_y = ( acc_y / ( 2.0 ** 15.0 )) * accel_sens a_z = ( acc_z / ( 2.0 ** 15.0 )) * accel_sens w_x = ( gyro_x / ( 2.0 ** 15.0 )) * gyro_sens w_y = ( gyro_y / ( 2.0 ** 15.0 )) * gyro_sens w_z = ( gyro_z / ( 2.0 ** 15.0 )) * gyro_sens ## temp = ((t_val)/333.87)+21.0 # uncomment and add below in return return a_x , a_y , a_z , w_x , w_y , w_z # MPU6050 Registers MPU6050_ADDR = 0x68 PWR_MGMT_1 = 0x6B SMPLRT_DIV = 0x19 CONFIG = 0x1A GYRO_CONFIG = 0x1B ACCEL_CONFIG = 0x1C INT_ENABLE = 0x38 ACCEL_XOUT_H = 0x3B ACCEL_YOUT_H = 0x3D ACCEL_ZOUT_H = 0x3F TEMP_OUT_H = 0x41 GYRO_XOUT_H = 0x43 GYRO_YOUT_H = 0x45 GYRO_ZOUT_H = 0x47 # start I2C driver bus = smbus . SMBus ( 0 ) # start comm with i2c bus gyro_sens , accel_sens = MPU6050_start () # instantiate gyro/accel while True : print ( mpu6050_conv ()) 这里我们看一下怎么使用I2C和陀螺仪通信来获取信息。主体上有三个大的函数，而这三个函数的功能都比较单一，第一个函数通过给陀螺仪发送数据来进行初始化的设置，比如配置陀螺仪的电源寄存器，加速度寄存器等；第二个函数则是从陀螺仪读取数据；第三个函数则是将读取到的函数进行计算，从而变成真正的加速度等信息。 具体的读写操作可以看下面的代码片段，也是直接调用函数指定地址和数据就好了。 这里我们也能看到几个关键的参数，比如陀螺仪MPU6050的地址是0x68，通过这个地址才能确认到陀螺仪的存在，然后进行初始化，初始化完成之后进入循环，不停的将数据打印出来。","text_tokens":["x","py","功能","关键","dps","temp","有点","才能","一下","好","双向","派","crystal","0x3d","就","从机","40pin","yout","电源","机器","就是","强大","最后","unsigned","env","接线图","out","传送数据","发和收","器件","使用","不过","位置","彼此","寄存","第三",".","int","config","byte","并","另外","sensors","初始","图中","time","samp","找到","串行","sec","地址","简单","g","通过","#","首先","一根","进行","0x45","从","之后","mpu6050","需要","下","三个","供电","很多","很快","-","high","accel","还是","速度","看","怎么","8","主机","if","。","出来","i2c",")","产生","to","处理","9.81","21.0","过去","能","bus","value","h","代码","接线","overflow","确认","0","通信","机","enable","继续","传输","all","之外","of","二个","gyroscope","第一","都","khz","register","add","settings","y","这些","片段","management","0x68","则","true","开发","bits","线","接口","起来","但是","instantiate","按照","找","下来","工作","0b01000","程序","a","终止","除了","x3","0x1c","0x41","调用","python3","用于","主","之类","方向","由","raw","信息","在","总线","acc","硬件","bin","start","不全是","配置","15.0","此时","接下","传送","_","循环","连接","rate","下面","一个","上","存在","uncomment","发送","同样","调用函数","0b010000","计算","zout","不是","read","获取信息","smplrt","*","是","一种","将","或者","旭日","这","这个","!","启动","一样","stability","多个","mpu6500","比","读写操作","多","=","333.87","registers","0.1","sel","sudo","/","<","0x01","2","只","加速","可以","他","传感器","外线","250.0","进入","]","终端",":","reset","同步","、","陀螺仪","负责","它","收到","low","发送数据","vals","0b10000","连线","write","机器人","完成","4.0","，","正常","然后","直接","具体","函数","只要","读取","interrupt","power","紫外线","真正","取决","sleep","变成","(","读取数据","啦","65536","操作","电源线","比如","and","below","时钟","初始化","等","in","0x3f","是从","问题","##","0x00","values","运行","16.0","0x1a","紫外","第一个","xout","设置","第三个","spi","才","也","500.0","解决","主体","特性","0x19","不停","uart","degrees","|","原始","alter","div","能否","0x43","：","陀螺","加速度","的","comm","gyro","+","这根","常用","和",">","0x6b","有"," ","0x47","任何","重点","设备","上主","t","$","各种","取决于","两根","中","^","如果","例程","w","复杂","数据","取信","更","import","大量","1","fifo","方式","模块","related","val","传感","让","打印","0b00000","4","bit","driver","得","被","关系","过程","示例","s","我们","higha","configuration","0x1b","第二个","+-","这里","convert","后续","了","conv","线图","从而","恒定","因为","for","认为","2.0","传输数据","比较","2000.0","return","另","sample","1000.0","到","接下来","usr","解析","0b11000",",","寄存器","sens","挺","第二","indx","虽然","根线","结算","while","给","8.0","而","acceleration","0x38","print","即可","with","用","接收","来","不同","原始数据","0x3b","大","addr","寻址","；","32768","看到","smbus","要","主动","读写","感器","获取","data","均","mgmt","z","单一","指定","几个","参数","原理","pwr","combine","做","[","def","m"],"title":"I2C同步串行通信","title_tokens":["同步","串行","通信","i2c"]},{"location":"hhp/4.5_I2C%E5%90%8C%E6%AD%A5%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1/#i2c","text":"SPI通信虽然功能更强大了，但是需要4根线做连接，还是有点复杂，接下来I2C的连线就简单很多了。","text_tokens":["连线","但是","复杂","简单","功能","，","接下来","的","下来","更","有点","需要","很多","虽然","根线","了","spi","就","接下","连接","还是","强大","。","4","通信","做","i2c"],"title":"I2C同步串行通信","title_tokens":["同步","串行","通信","i2c"]},{"location":"hhp/4.5_I2C%E5%90%8C%E6%AD%A5%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1/#i2c_1","text":"I2C也是一种常用的串行通信方式，和SPI一样可以连接多个设备，重点是它只需要两根线就可以完成。 不过他的两根线和UART不同，不全是传输数据用的，I2C中的一根线是时钟线，另一根才是传输数据的，这根线可以双向的传输数据。 I2C通信中可以有多个主设备或者从设备，只要能通过地址找到彼此的位置即可。 主器件用于启动总线传送数据，并产生时钟给各种从机，此时任何被寻址的器件均被认为是从机。在总线上主和从、发和收的关系不是恒定的，而取决于此时数据传送方向。如果主机要发送数据给从机，主机首先得找到从机的地址，然后主动发送数据过去，最后也得由主机终止数据传送；如果主机要接收从机的数据，同样由主机得找到从机的地址，然后主机接收从器件发送的数据，最后由主机终止接收过程。 因为I2C的特性，使用I2C的设备比SPI多很多，比如图中的紫外线传感器，陀螺仪之类的，都是使用I2C进行通信的。","text_tokens":["如果","只","可以","他","数据","传感器","外线","都","双向","方式","、","就","从机","陀螺仪","传感","它","发送数据","最后","得","被","关系","过程","线","传送数据","完成","发和收","，","器件","使用","然后","不过","只要","位置","彼此","紫外线","取决","终止","比如","时钟","恒定","因为","认为","并","传输数据","图中","用于","找到","另","串行","是从","地址","主","之类","方向","通过","由","首先","一根","进行","在","总线","从","需要","紫外","很多","不全是","spi","此时","才","也","传送","连接","给","特性","uart","发送","同样","主机","。","而","不是","i2c","产生","是","即可","一种","陀螺","用","的","接收","不同","这根","或者","常用","和","有","寻址","；"," ","任何","重点","设备","过去","能","启动","要","主动","感器","上主","一样","均","多个","比","多","各种","取决于","两根","通信","中","机","传输"],"title":"I2C通信原理","title_tokens":["原理","通信","i2c"]},{"location":"hhp/4.5_I2C%E5%90%8C%E6%AD%A5%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1/#_1","text":"我们找来一个常用的陀螺仪模块，按照这里的接线图连接到旭日X3派的40PIN接口上，这里除了I2C通信的两根线之外，另外两根是电源线，负责给这个模块供电的，让它正常工作起来。","text_tokens":["是","接线图","起来","我们","按照","陀螺","之外","找","的","，","来","到","正常","工作","常用","旭日","这里","这个","派","供电","除了","模块","线图","x3","电源线","陀螺仪","接线","负责","连接","给","40pin","让","一个","上","它","电源","另外","两根","。","通信","i2c","线","接口"],"title":"硬件接线","title_tokens":["接线","硬件"]},{"location":"hhp/4.5_I2C%E5%90%8C%E6%AD%A5%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1/#_2","text":"接线是挺简单的，我们继续来运行这个例程，看下能否收到数据。 $ sudo python3 mpu6500_i2c.py 在终端启动例程，很快就可以看到通过I2C读取到了大量传感器的数据，这些就是陀螺仪模块的原始数据，收到之后我们就可以进行结算处理啦，这就是我们后续机器人开发的需要解决的问题了。","text_tokens":["是","例程","机器人","我们","py","问题","简单","可以","陀螺","处理","的","，","数据","来","通过","到","原始数据","传感器","进行","在","大量","这","终端","运行","之后","下"," ","需要","读取","挺","python3","看到","这个","后续","很快",".","启动","了","就","感器","模块","结算","啦","mpu6500","_","接线","陀螺仪","这些","解决","$","传感","看","收到","机器","就是","原始","。","sudo","i2c","开发","继续","能否"],"title":"运行示例程序","title_tokens":["示例","程序","运行"]},{"location":"hhp/4.5_I2C%E5%90%8C%E6%AD%A5%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1/#_3","text":"mpu6500_i2c.py： #!/usr/bin/env python3 import smbus , time def MPU6050_start (): # alter sample rate (stability) samp_rate_div = 0 # sample rate = 8 kHz/(1+samp_rate_div) bus . write_byte_data ( MPU6050_ADDR , SMPLRT_DIV , samp_rate_div ) time . sleep ( 0.1 ) # reset all sensors bus . write_byte_data ( MPU6050_ADDR , PWR_MGMT_1 , 0x00 ) time . sleep ( 0.1 ) # power management and crystal settings bus . write_byte_data ( MPU6050_ADDR , PWR_MGMT_1 , 0x01 ) time . sleep ( 0.1 ) #Write to Configuration register bus . write_byte_data ( MPU6050_ADDR , CONFIG , 0 ) time . sleep ( 0.1 ) #Write to Gyro configuration register gyro_config_sel = [ 0b00000 , 0b010000 , 0b10000 , 0b11000 ] # byte registers gyro_config_vals = [ 250.0 , 500.0 , 1000.0 , 2000.0 ] # degrees/sec gyro_indx = 0 bus . write_byte_data ( MPU6050_ADDR , GYRO_CONFIG , int ( gyro_config_sel [ gyro_indx ])) time . sleep ( 0.1 ) #Write to Accel configuration register accel_config_sel = [ 0b00000 , 0b01000 , 0b10000 , 0b11000 ] # byte registers accel_config_vals = [ 2.0 , 4.0 , 8.0 , 16.0 ] # g (g = 9.81 m/s^2) accel_indx = 0 bus . write_byte_data ( MPU6050_ADDR , ACCEL_CONFIG , int ( accel_config_sel [ accel_indx ])) time . sleep ( 0.1 ) # interrupt register (related to overflow of data [FIFO]) bus . write_byte_data ( MPU6050_ADDR , INT_ENABLE , 1 ) time . sleep ( 0.1 ) return gyro_config_vals [ gyro_indx ], accel_config_vals [ accel_indx ] def read_raw_bits ( register ): # read accel and gyro values high = bus . read_byte_data ( MPU6050_ADDR , register ) low = bus . read_byte_data ( MPU6050_ADDR , register + 1 ) # combine higha and low for unsigned bit value value = (( high << 8 ) | low ) # convert to +- value if ( value > 32768 ): value -= 65536 return value def mpu6050_conv (): # raw acceleration bits acc_x = read_raw_bits ( ACCEL_XOUT_H ) acc_y = read_raw_bits ( ACCEL_YOUT_H ) acc_z = read_raw_bits ( ACCEL_ZOUT_H ) # raw temp bits ## t_val = read_raw_bits(TEMP_OUT_H) # uncomment to read temp # raw gyroscope bits gyro_x = read_raw_bits ( GYRO_XOUT_H ) gyro_y = read_raw_bits ( GYRO_YOUT_H ) gyro_z = read_raw_bits ( GYRO_ZOUT_H ) #convert to acceleration in g and gyro dps a_x = ( acc_x / ( 2.0 ** 15.0 )) * accel_sens a_y = ( acc_y / ( 2.0 ** 15.0 )) * accel_sens a_z = ( acc_z / ( 2.0 ** 15.0 )) * accel_sens w_x = ( gyro_x / ( 2.0 ** 15.0 )) * gyro_sens w_y = ( gyro_y / ( 2.0 ** 15.0 )) * gyro_sens w_z = ( gyro_z / ( 2.0 ** 15.0 )) * gyro_sens ## temp = ((t_val)/333.87)+21.0 # uncomment and add below in return return a_x , a_y , a_z , w_x , w_y , w_z # MPU6050 Registers MPU6050_ADDR = 0x68 PWR_MGMT_1 = 0x6B SMPLRT_DIV = 0x19 CONFIG = 0x1A GYRO_CONFIG = 0x1B ACCEL_CONFIG = 0x1C INT_ENABLE = 0x38 ACCEL_XOUT_H = 0x3B ACCEL_YOUT_H = 0x3D ACCEL_ZOUT_H = 0x3F TEMP_OUT_H = 0x41 GYRO_XOUT_H = 0x43 GYRO_YOUT_H = 0x45 GYRO_ZOUT_H = 0x47 # start I2C driver bus = smbus . SMBus ( 0 ) # start comm with i2c bus gyro_sens , accel_sens = MPU6050_start () # instantiate gyro/accel while True : print ( mpu6050_conv ()) 这里我们看一下怎么使用I2C和陀螺仪通信来获取信息。主体上有三个大的函数，而这三个函数的功能都比较单一，第一个函数通过给陀螺仪发送数据来进行初始化的设置，比如配置陀螺仪的电源寄存器，加速度寄存器等；第二个函数则是从陀螺仪读取数据；第三个函数则是将读取到的函数进行计算，从而变成真正的加速度等信息。 具体的读写操作可以看下面的代码片段，也是直接调用函数指定地址和数据就好了。 这里我们也能看到几个关键的参数，比如陀螺仪MPU6050的地址是0x68，通过这个地址才能确认到陀螺仪的存在，然后进行初始化，初始化完成之后进入循环，不停的将数据打印出来。","text_tokens":["x","0x01","all","2","w","py","加速","可以","功能","数据","of","关键","dps","取信","二个","250.0","temp","import","gyroscope","进入","]","第一",":","一下","好","才能","1","都","reset","crystal","khz","register","fifo","0x3d","add","settings","就","y","陀螺仪","片段","related","management","val","<","low","打印","0b00000","yout","电源","0x68","发送数据","则","vals","bit","driver","true","unsigned","env","bits","0b10000","write","s","instantiate","我们","out","4.0","完成","，","higha","使用","直接","configuration","0x1b","第二个","然后","具体","函数","0b01000","读取","interrupt","+-","power","convert","这里","寄存","sleep","第三","a","变成",".","(","真正","读取数据","了","int","conv","65536","操作","从而","0x1c","and","初始化","below","比如","for","config","0x41","等","byte","调用","2.0","比较","sensors","初始","time","2000.0","samp","return","python3","in","0x3f","sec","是从","地址","g","sample","1000.0","usr","##","通过","#","raw","到","进行","0x00","信息","values","0x45","0b11000","0x1a","16.0","mpu6050",",","acc","sens","第一个","寄存器","之后","三个","第二","bin","xout","设置","indx","start","第三个","-","配置","high","15.0","while","_","也","循环","500.0","accel","给","8.0","主体","rate","0x19","速度","一个","看","上","下面","怎么","uncomment","存在","不停","degrees","8","|","发送","调用函数","0b010000","if","。","计算","而","出来","zout","alter","read","获取信息","acceleration","i2c","div","smplrt",")","*","是","to","0x38","print","0x43","：","陀螺","加速度","with","的","comm","gyro","来","+","0x3b","大","addr","将","和",">","0x6b","这","9.81","有","；"," ","32768","21.0","0x47","看到","这个","bus","value","能","!","smbus","h","代码","读写","获取","data","mgmt","stability","mpu6500","z","t","单一","指定","overflow","读写操作","几个","=","确认","参数","333.87","0","registers","pwr","combine","0.1","sel","通信","^","enable","/","[","def","m"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"hhp/4.6_USB%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/","text":"USB外设驱动 在电脑上，我们最常用的接口之一，应该就是USB了，相比之前讲到的外设通信方法，USB更加复杂，速度也更快。 USB通信原理 USB不仅是我们生活中最常用的一种接口，也是一种串行总线的通讯方式。他类似于UART，有两根线用来传输数据。 而且USB还有专门的接口规范，比如我们常听说的USB Type A、Type C。例如这里列出来的USB口，打印机常用的B口，手机上用的C口，都是标准的USB接口。 USB的接口规范，使用广泛，很多成熟的外设都是采用的USB接口。 摄像头驱动 比如USB摄像头。 硬件接线 这里我们使用一个USB摄像头，通过一个相机驱动把它跑起来，并且可以看到图像数据。 方法有很多中，TogetherROS兼容ROS2的所有功能，那我们就先试试ROS2中的标准方法，在旭日X3PI上直接安装一个usb_cam功能包。 ROS2相机驱动 安装与配置 首先安装ROS2的相机驱动包： # 安装功能包 $ sudo apt install ros-foxy-usb-cam 安装好之后，为了让系统能够找到该功能包，需要进入tros的目录，建立对应的软连接。 # 建立软连接 $ cd /opt/tros $ sudo python3 create_soft_link.py --foxy /opt/ros/foxy/ --tros /opt/tros/ 因为旭日X3Pi可以连接csi摄像头，设备名占用了video0-7，所以外接的USB摄像头会被自动分配到video8，我们需要在ROS2的功能包中修改一下设备号。 # 修改配置文件 $ cd /opt/tros/share/usb_cam/config $ sudo vim params.yaml 然后给这个设备添加权限，最后再设置TogetherROS的环境变量就可以使用啦。 # 添加可执行权限 $ sudo chmod 777 /dev/video8 # 添加环境变量 $ source /opt/tros/local_setup.bash 运行相机驱动 我们来试一试。 $ ros2 launch usb_cam demo_launch.py #启动相机，X3Pi $ ros2 run rqt_image_view rqt_image_view #查看图像，PC 这里直接在X3Pi中启动usb_cam的launch文件，然后再启动一个能和他通信的Ubuntu桌面系统，打开rqt_image_view，选择对应的话题，就可以看到图像了。也就是说明我们成功的用TROS驱动了这个USB摄像头。 TogetherROS相机驱动 除此之外，TogetherROS中也提供了USB摄像头的驱动节点，连接摄像头之后，直接设置设备的权限和TogetherROS的环境变量就可以使用了。 $ source /opt/tros/local_setup.bash $ sudo chmod 777 /dev/video8 $ ros2 launch hobot_usb_cam hobot_usb_cam.launch.py 之后可以再打开一个新的终端，输入对应的指令，然后启动websocket这个节点，就可以把image这个话题的数据发送到网页了。 $ source /opt/tros/local_setup.bash $ cd /opt/tros/lib/websocket/webservice $ sudo chmod +x ./sbin/nginx $ sudo ./sbin/nginx -p . $ ros2 run websocket websocket --ros-args -p image_topic: = /image -p image_type: = mjpeg -p only_show_image: = true 这时我们直接打开在通一个局域网下的浏览器，输入X3Pi的地址，就可以进去到一个网页，点击左上方web端展示即可看到USB摄像头的实时画面。 激光雷达驱动 移动机器人中常用的激光雷达大多也是USB借口的，比如这款rplidar。 安装与配置 如果我们想把它跑起来，同样需要一个驱动包，大家可以在工作空间中下载雷达的驱动包，然后进行编译。编译完成后，添加环境变量就可以使用这个功能包了。 # 下载源码 $ mkdir -p catkin_ws/src $ cd ~/catkin_ws/src $ git clone -b ros2 https://github.com/slamtec/rplidar_ros.git # 编译 $ cd ~/catkin_ws $ colcon build --symlink-install # 添加环境变量 $ source ~/catkin_ws/install/setup.bash # 添加权限 $ sudo chmod 777 /dev/ttyUSB0 还要记得给激光雷达的USB口设置对应的权限。 运行激光雷达驱动 驱动安装好之后，就可以启动雷达了。 在旭日X3派的终端中，运行启动激光雷达的launch文件。 $ ros2 launch rplidar_ros2 rplidar_launch.py #启动雷达，X3PI $ ros2 run rviz2 rviz2 #查看点云，PC 启动成功后，我们在电脑端的Ubuntu系统中，在ros2环境下打开rviz2，然后将世界坐标系改为laser，然后添加LaserScan的可视化选项，并且把Reliability Policy的选项改为System Default，此时就可以看到激光雷达的点云数据了。","text_tokens":["x","py","例如","github","功能","可","show","指令","打开","一下","好","并且","派","就","websocket","对应","列出","规范","机器","就是","ros","配置文件","最后","除此","兼容","动机","还有","名","vim","使用","选择","video8","节点",".","相比","讲到","laserscan","该","广泛","config","浏览","大多","usb","找到","串行","环境变","地址","通过","#","就是说","首先","进行","试一试","占用","之后","需要","下","世界","togetherros","很多","-","reliability","空间","打印机","速度","手机","会","。","出来","试试","opt","为了","摄像头","bash","csi","执行","点云","local","b","方法","可视化","自动","能","hobot","777","专门","接线","之前","cam","通信","外接","更加","video0","传输","web","之外","环境","再","都","与","source","先","除此之外","launch","包中","桌面","再启动","true","最","系统","线","接口","symlink","nginx","查看","起来","实时","端的","tros","工作","成功","a","x3","口","之一","rplidar","python3","那","7","--","文件","在","总线","soft","硬件","webservice","局域网","配置","此时","软","_","连接","image","用来","一个","上","发送","同样","rviz2","link","能够","是","一种","cd","端","catkin","将","旭日","提供","印机","这款","编译","修改","这个","启动","上方","新","default","demo","=","进去","policy","浏览器","串行总线","git","sudo","局域","/","常","com","他","可以","驱动","foxy","topic","args","进入","终端","分配","目录",":","clone","src","setup","后","、","类似","only","apt","选项","添加","它","摄像","ros2","上用","chmod","机器人","应该","完成","，","而且","然后","直接","create","发送到","mjpeg","啦","params","比如","所以","标准","view","明","dev","移动","所有","运行","安装","激光","设置","图像","也","run","话题","uart","借口","外设","快","包","install","左上方","激光雷达","点击","于","：","的","权限","输入","+","常用","和","改为","有","画面"," ","设备","sbin","laser","$","两根","中","把","如果","复杂","记得","数据","更","方式","跑","这时","让","yaml","打印","列出来","p","被","我们","坐标","坐标系","成熟","通","这里","了","网页","因为","大家","传输数据","号","展示","环境变量","电脑","colcon","x3pi","到","听说","slamtec","通讯","可视","type","c","送到","也就是说","左上","给","不仅","lib","ubuntu","像头","mkdir","采用","雷达","想","即可","用","来","system","生活","ttyusb0","share","https","看到","pc","rqt","变量","移动机器人","下载","~","build","原理","还要","ws","相机","源码","建立","包了"],"title":"USB外设驱动","title_tokens":["驱动","usb","外设"]},{"location":"hhp/4.6_USB%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/#usb","text":"在电脑上，我们最常用的接口之一，应该就是USB了，相比之前讲到的外设通信方法，USB更加复杂，速度也更快。","text_tokens":["电脑","应该","我们","复杂","，","的","在","更","常用","方法","了","相比","讲到","也","之前","之一","速度","上","外设","就是","快","usb","。","通信","最","更加","接口"],"title":"USB外设驱动","title_tokens":["驱动","usb","外设"]},{"location":"hhp/4.6_USB%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/#usb_1","text":"USB不仅是我们生活中最常用的一种接口，也是一种串行总线的通讯方式。他类似于UART，有两根线用来传输数据。 而且USB还有专门的接口规范，比如我们常听说的USB Type A、Type C。例如这里列出来的USB口，打印机常用的B口，手机上用的C口，都是标准的USB接口。 USB的接口规范，使用广泛，很多成熟的外设都是采用的USB接口。","text_tokens":["还有","串行","是","标准","采用","我们","于","例如","一种","他","的","，","数据","而且","听说","使用","总线","常用","成熟","生活","有","通讯","b"," ","印机","都","这里","很多","a","type","方式","、","类似","c","广泛","也","专门","常","比如","口","列出","打印机","用来","手机","不仅","规范","uart","打印","列出来","外设","usb","两根","。","传输数据","出来","串行总线","中","最","上用","传输","线","接口"],"title":"USB通信原理","title_tokens":["原理","通信","usb"]},{"location":"hhp/4.6_USB%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/#_1","text":"比如USB摄像头。","text_tokens":["摄像","usb","。","摄像头","比如","像头"],"title":"摄像头驱动","title_tokens":["驱动","摄像头","摄像","像头"]},{"location":"hhp/4.6_USB%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/#_2","text":"这里我们使用一个USB摄像头，通过一个相机驱动把它跑起来，并且可以看到图像数据。 方法有很多中，TogetherROS兼容ROS2的所有功能，那我们就先试试ROS2中的标准方法，在旭日X3PI上直接安装一个usb_cam功能包。","text_tokens":["标准","起来","x3pi","我们","那","摄像头","可以","功能","驱动","，","数据","通过","的","使用","直接","在","旭日","有","方法","所有"," ","安装","这里","看到","并且","很多","togetherros","图像","跑","先","就","_","cam","一个","它","上","摄像","usb","相机","。","包","中","ros2","像头","试试","兼容","把"],"title":"硬件接线","title_tokens":["接线","硬件"]},{"location":"hhp/4.6_USB%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/#ros2","text":"","text_tokens":[],"title":"ROS2相机驱动","title_tokens":["驱动","相机","ros2"]},{"location":"hhp/4.6_USB%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/#_3","text":"首先安装ROS2的相机驱动包： # 安装功能包 $ sudo apt install ros-foxy-usb-cam 安装好之后，为了让系统能够找到该功能包，需要进入tros的目录，建立对应的软连接。 # 建立软连接 $ cd /opt/tros $ sudo python3 create_soft_link.py --foxy /opt/ros/foxy/ --tros /opt/tros/ 因为旭日X3Pi可以连接csi摄像头，设备名占用了video0-7，所以外接的USB摄像头会被自动分配到video8，我们需要在ROS2的功能包中修改一下设备号。 # 修改配置文件 $ cd /opt/tros/share/usb_cam/config $ sudo vim params.yaml 然后给这个设备添加权限，最后再设置TogetherROS的环境变量就可以使用啦。 # 添加可执行权限 $ sudo chmod 777 /dev/video8 # 添加环境变量 $ source /opt/tros/local_setup.bash","text_tokens":["py","可以","功能","驱动","foxy","可","环境","进入","再","分配","目录","一下","好","setup","source","就","apt","包中","对应","添加","让","yaml","摄像","ros","配置文件","最后","ros2","被","系统","chmod","名","我们","，","vim","tros","然后","使用","video8","create",".","了","啦","该","params","因为","config","usb","号","python3","找到","所以","环境变量","环境变","x3pi","7","dev","到","#","--","文件","首先","在","soft","占用","之后","安装","需要","设置","togetherros","-","配置","软","_","连接","给","会","link","包","。","install","能够","像头","opt","为了","：","摄像头","bash","cd","的","权限","csi","执行","旭日","local","share"," ","自动","修改","这个","设备","变量","777","cam","$","相机","sudo","建立","外接","video0","/"],"title":"安装与配置","title_tokens":["安装","与","配置"]},{"location":"hhp/4.6_USB%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/#_4","text":"我们来试一试。 $ ros2 launch usb_cam demo_launch.py #启动相机，X3Pi $ ros2 run rqt_image_view rqt_image_view #查看图像，PC 这里直接在X3Pi中启动usb_cam的launch文件，然后再启动一个能和他通信的Ubuntu桌面系统，打开rqt_image_view，选择对应的话题，就可以看到图像了。也就是说明我们成功的用TROS驱动了这个USB摄像头。","text_tokens":["查看","view","x3pi","我们","py","明","摄像头","他","可以","用","，","的","打开","来","#","文件","就是说","驱动","tros","然后","直接","在","选择","成功","和","试一试"," ","这里","看到","这个","能",".","启动","图像","了","pc","就","rqt","launch","也就是说","_","对应","run","cam","$","image","桌面","demo","话题","一个","就是","摄像","usb","相机","。","ubuntu","再启动","通信","中","ros2","像头","系统"],"title":"运行相机驱动","title_tokens":["驱动","相机","运行"]},{"location":"hhp/4.6_USB%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/#togetherros","text":"除此之外，TogetherROS中也提供了USB摄像头的驱动节点，连接摄像头之后，直接设置设备的权限和TogetherROS的环境变量就可以使用了。 $ source /opt/tros/local_setup.bash $ sudo chmod 777 /dev/video8 $ ros2 launch hobot_usb_cam hobot_usb_cam.launch.py 之后可以再打开一个新的终端，输入对应的指令，然后启动websocket这个节点，就可以把image这个话题的数据发送到网页了。 $ source /opt/tros/local_setup.bash $ cd /opt/tros/lib/websocket/webservice $ sudo chmod +x ./sbin/nginx $ sudo ./sbin/nginx -p . $ ros2 run websocket websocket --ros-args -p image_topic: = /image -p image_type: = mjpeg -p only_show_image: = true 这时我们直接打开在通一个局域网下的浏览器，输入X3Pi的地址，就可以进去到一个网页，点击左上方web端展示即可看到USB摄像头的实时画面。","text_tokens":["x","py","可以","之外","驱动","show","指令","打开","数据","topic","环境","args","再","终端",":","setup","source","就","除此之外","only","这时","launch","websocket","对应","摄像","p","ros","除此","ros2","true","chmod","nginx","我们","，","实时","使用","tros","直接","然后","video8","发送到","通","节点",".","mjpeg","了","网页","浏览","usb","展示","环境变量","环境变","x3pi","地址","dev","到","--","在","之后","下","togetherros","设置","type","webservice","-","局域网","送到","也","_","左上","连接","run","image","话题","一个","发送","。","lib","像头","左上方","opt","点击","即可","摄像头","bash","cd","的","权限","输入","端","+","和","local","提供","画面"," ","看到","这个","设备","启动","hobot","上方","变量","777","sbin","新","cam","$","=","进去","浏览器","中","sudo","局域","/","把","web"],"title":"TogetherROS相机驱动","title_tokens":["驱动","togetherros","相机"]},{"location":"hhp/4.6_USB%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/#_5","text":"移动机器人中常用的激光雷达大多也是USB借口的，比如这款rplidar。","text_tokens":["是","雷达","机器人","的","，","移动","常用","这款","激光","移动机器人","也","比如","借口","机器","大多","usb","。","中","rplidar","激光雷达","动机"],"title":"激光雷达驱动","title_tokens":["驱动","激光","雷达","激光雷达"]},{"location":"hhp/4.6_USB%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/#_6","text":"如果我们想把它跑起来，同样需要一个驱动包，大家可以在工作空间中下载雷达的驱动包，然后进行编译。编译完成后，添加环境变量就可以使用这个功能包了。 # 下载源码 $ mkdir -p catkin_ws/src $ cd ~/catkin_ws/src $ git clone -b ros2 https://github.com/slamtec/rplidar_ros.git # 编译 $ cd ~/catkin_ws $ colcon build --symlink-install # 添加环境变量 $ source ~/catkin_ws/install/setup.bash # 添加权限 $ sudo chmod 777 /dev/ttyUSB0 还要记得给激光雷达的USB口设置对应的权限。","text_tokens":["如果","记得","com","可以","github","功能","驱动","环境",":","clone","src","setup","source","后","跑","就","对应","添加","它","p","ros","ros2","chmod","symlink","起来","我们","完成","，","使用","然后","工作",".","口","大家","usb","rplidar","环境变量","环境变","colcon","dev","#","--","进行","在","slamtec","需要","激光","设置","-","_","给","空间","一个","同样","包","。","install","mkdir","激光雷达","雷达","想","bash","cd","的","权限","catkin","b","ttyusb0"," ","https","编译","这个","变量","777","下载","~","$","build","还要","ws","源码","中","git","sudo","/","把","包了"],"title":"安装与配置","title_tokens":["安装","与","配置"]},{"location":"hhp/4.6_USB%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/#_7","text":"驱动安装好之后，就可以启动雷达了。 在旭日X3派的终端中，运行启动激光雷达的launch文件。 $ ros2 launch rplidar_ros2 rplidar_launch.py #启动雷达，X3PI $ ros2 run rviz2 rviz2 #查看点云，PC 启动成功后，我们在电脑端的Ubuntu系统中，在ros2环境下打开rviz2，然后将世界坐标系改为laser，然后添加LaserScan的可视化选项，并且把Reliability Policy的选项改为System Default，此时就可以看到激光雷达的点云数据了。","text_tokens":["查看","电脑","雷达","x3pi","我们","py","可以","坐标","驱动","，","的","端的","#","文件","打开","数据","然后","坐标系","在","环境","将","成功","改为","旭日","system","点云","终端","之后","运行","安装"," ","好","下","可视化","世界","激光","可视","看到","派","并且","后",".","启动","了","就","pc","laserscan","x3","launch","此时","_","laser","reliability","run","$","选项","添加","default","policy","rviz2","。","ubuntu","系统","中","ros2","rplidar","激光雷达","把"],"title":"运行激光雷达驱动","title_tokens":["雷达","运行","驱动","激光","激光雷达"]},{"location":"hhp/5.1_%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E4%BB%8B%E7%BB%8D/","text":"机器视觉介绍 机器视觉概念 机器视觉， 就是用计算机来模拟人的视觉功能，但这并不仅仅是人眼的简单延伸，更重要的是像人脑一样，可以从客观事物的图像中提取信息，进行处理并加以理解，最终用于实际检测、控制等场景。 获取图像信息相对简单，但想让机器人理解图像中千变万化的物品，就难上加难了。 为了解决这一系列复杂的问题，机器视觉也是一个涉猎广泛的交叉学科，横跨人工智能、神经生物学、物理学、计算机科学、图像处理、模式识别等诸多领域。时至今日，在各个领域中，都有大量开发者或组织参与其中，也积累了众多技术，不过依然还有很多问题亟待解决，就像我们对自己大脑的研究也只是冰山一角一样，机器视觉的研究也将会是一个长久的工作。 机器视觉相关的关键技术也有不少，比如视觉图像的采集和信号处理，这个过程主要是通过传感器硬件采集外部光信号的过程，光信号最终会转变成数字电路的信号，便于下一步的处理；类似左边图片中看到的效果，获取图像之后，更重要的是要识别图像中的物体、确定物体的位置、或者检测物品的变化，这就要用到模式识别或者机器学习等技术，这个部分也是当今机器视觉研究的重点。 和人类的两只眼睛不同，机器用于获取图像的传感器种类较为丰富，可以是一个摄像头，也可以是两个摄像头，还可以是三个、四个、很多个摄像头，不仅可以获取颜色信息，还可以通过红外相机获取深度或者能量信息，这可比人眼获取的信息丰富多了，当然，这也会对后期的处理带来不同的计算压力。 在工业领域，机器视觉系统已经被广泛用于自动检验、工件加工、装配自动化以及生产过程控制等工作。随着机器人的快速发展和应用，机器视觉也逐渐应用于农业机器人、AMR物流机器人、服务机器人、无人驾驶汽车等各种机器人，活跃在农场、物流、仓储、交通、医院等多种环境中。 机器视觉流程 人类视觉擅长于对复杂、非结构化的场景进行定性解释，但机器视觉凭借速度、精度和可重复性等优势，非常适合对结构化场景进行定量测量。 一般来讲，典型的机器视觉系统可以分为如图所示的三个部分：图像采集、图像分析和控制输出。 图像采集注重对原始光学信号的采样，是整个视觉系统的传感部分，核心是相机和相关的配件。 其中光源用于照明待检测的物体，并突显其特征，便于让相机能够更好的捕捉图像。光源是影响机器视觉系统成像质量的重要因素，好的光源和照明效果对机器视觉判断影响很大。当前，机器视觉的光源已经突破人眼的可见光范围，其光谱范围跨越红外光（IR）、可见光、紫外光（UV）乃至X射线波段，可实现更精细和更广泛的检测范围，以及特殊成像需求。 相机被喻为机器视觉系统的“眼睛”，承担着图像信息采集的重要任务。图像传感器又是相机的核心元器件，主要有CCD和CMOS两种类型，其工作原理是将相机镜头接收到的光学信号转化成数字信号。选择合适的相机是机器视觉系统设计的重要环节，不仅直接决定了采集图像的质量和速度，同时也与整个系统的运行模式相关。 图像处理系统接收到相机传来的数字图像之后，通过各种软件算法进行图像特征提取、特征分析和数据标定，最后进行判断。这是各种视觉算法研究最为集中的部分，从传统的模式识别算法，到当前热门的各种机器学习方法，都是为了更好的让机器理解环境。 对于人来讲，识别某一个物体是苹果似乎理所当然，但是对于机器人来讲，就需要提取各种各样不同种类、颜色、形状的苹果特征，然后训练得到一个苹果的“模型”，再通过这个模型对实时图像做匹配，从而分析面前这个东西到底是不是苹果。 在机器人系统中，视觉识别的结果最终要和机器人的某些行为绑定，也就是第三个部分——控制输出，包含I/O接口、运动控制、可视化显示等。当图像处理系统完成图像分析后，将判断的结果发给机器人控制系统，接下来机器人完成运动控制。比如视觉识别到了抓取目标的位置，通过IO口控制夹爪完成抓取和放置，过程中识别的结果和运动的状态，都可以在上位机中显示，方便我们监控。 就机器视觉而言，在这三个部分中，图像分析占据了绝对的核心，涉及的方法、使用的各种开源软件或者框架非常多，这也是我们后续开发的重点，TogetherROS中提供了大量的算法、工具和功能支持。 旭日X3派配置 了解了机器视觉的基本原理和流程，相信大家对视觉应用已经充满了期待，我们这就准备开始。 后续课程中，我们将继续在旭日X3派的开发板上，使用TogetherROS实现各种各样的视觉例程，不过我们得先找到一个相机，比如usb相机或者MIPI接口配套的相机模块，然后连接到开发板对应的接口上。 电脑和开发板之前通过网线连接，便于我们查看视觉处理的结果，速度更快。 如果有HDMI屏幕的话，也可以准备好，稍后需要使用的时候插上查看结果，如果没有的话，也没有影响，后续我们会使用一套网络传输工具，通过板卡的IP地址，就可以看到图像处理的实时状态啦。 USB相机图像采集 关于相机的驱动，请大家也再确认一下，这是后续视觉处理的基础。 如果是USB相机的话，可以参考这个过程验证下是否可以顺利看到图像。 # 旭日X3派 $ sudo apt install ros-foxy-usb-cam $ cd /opt/tros $ python3 create_soft_link.py --foxy /opt/ros/foxy/ --tros /opt/tros $ source /opt/tros/local_setup.bash $ ros2 launch usb_cam demo_launch.py # 修改params.yaml配置文件中的设备号 # PC $ source /opt/ros/foxy/local_setup.bash $ ros2 run rqt_image_view rqt_image_view MIPI相机图像采集 如果使用的是MIPI相机的话，可以参考这个流程驱动相机并显示图像。 # 旭日X3派 $ source /opt/tros/local_setup.bash $ ros2 run mipi_cam mipi_cam --ros-args -p video_device: = F37 -p image_width: = 960 -p image_height: = 540 # PC $ source /opt/ros/foxy/local_setup.bash $ ros2 run rqt_image_view rqt_image_view 为了提高图像的编码和传输效率，我们建议大家使用MIPI接口的相机，后续应用功能我们也会以该相机为主。","text_tokens":["各样","是不是","主要","py","ip地址","ir","种类","功能","可","hdmi","关键","一下","计算机","好","io","派","应用","擅长于","就","对应","便于","机器","就是","验证","场景","ros","算机","最后","方便","配置文件","绑定","活跃","实现","屏幕","还有","汽车","结构化","器件","类型","传统","数字","丰富","可见光","使用","选择","不过","定性","重要","位置","装配","多种","第三","任务","amr",".","课程","突显","该","广泛","积累","f37","红外","参考","注重","一般来讲","组织","最为","并","解释","usb","依然","cmos","夹","找到","特征分析","光","地址","简单","通过","#","进行","交叉","环节","就要","从","之后","当然","可比","下","需要","转变","没有","同时","三个","togetherros","很多","算法","各种各样","-","诸多","涉猎","亟待","速度","各个","监控","会","不仅仅","转变成","目标","。","镜头","人眼","opt","为了","照明","摄像头","bash","处理","影响","千变万化","插上","四个","乃至","local","方法","模式识别","可视化","自动","今日","时至今日","如图所示","涉及","确定","—","效率","到底","特征","之前","cam","建议","大脑","擅长","确认","精细","理解","继续","传输","对于","基本","匹配","成像","精度","深度","一套","环境","用到","理所当然","再","后期","各个领域","工具","都","与","source","理学","的话","先","客观事物","机中","压力","launch","加工","以","可见","射线","关于","复性","开发","一角","系统","支持","接口","查看","自己","但是","冰山一角","农业","实时","相信","下来","网络","tros","工作","检验","加以","无人","波段","物体","这是","本原","device","数字信号","当今","图像处理","当","模拟","爪","x3","采样","概念","口","提高","适合","配件","了解","为主","设计","人脑","非","python3","用于","--","文件","信息","在","人","soft","典型","板卡","硬件","数字电路","研究","o","输出","因素","分为","配置","对","接下","特征提取","_","充满","得到","连接","image","一个","上","link","计算","亟待解决","至今","不是","能够","喻为","人类","非常适合","时候","特殊","关键技术","是","结构","快速","cd","两种","（","放置","uv","将","或者","旭日","这","参与","两只","提供","修改","这个","眼睛","一系","工业","运动","一样","包含","“","长久","或","demo","多","=","已经","x射线","期待","核心","sudo","学科","/","非常","延伸","交通","可以","其中","驱动","foxy","定量","传感器","能量","苹果","测量","相对","args","以及","抓取","逐渐",":","元器件","热门","setup","后","、","video","类似","占据","apt","960","开发者","采集","随着","状态","神经","而言","介绍","编码","540","摄像","ros2","配套","准备","东西","机器人","难上加难","完成","，","仓储","然后","直接","height","判断","生产","只是","领域","视觉","学习","create","长于","标定","绝对","变成","紫外光","突破","啦","params","比如","重复","等","自动化","化成","元器","行为","模型","提取","部分","view","左边","问题","转化成","识别","个","训练","运行","紫外","系列","但","事物","检测","图像","第三个","也","无人驾驶","解决","run","网线","人工智能","当前","快","原始","i","驾驶","install","医院","仅仅","一般","开源","颜色","需求","于","：","的","着","面前","ccd","生物学","物品","和","基本原理","有"," ","整个","重点","某","设备","物理学","$","各种","”","mipi","中","一步","发给","众多","如果","图片","例程","复杂","模式","基础","数据","技术","似乎","光谱","最终","更","大量","客观","数字图像","所示","其","电路","信号处理","数字电","模块","带来","分析","传感","让","较为","yaml","p","控制","width","人工","得","过程","被","还","软件","工件","我们","物流","决定","光源","后续","更好","农场","请","信号","了","冰山","光学","集中","外部","从而","计算机科学","控制系统","待","大家","交叉学科","相关","是否","承担","很大","顺利","号","传来","上位","开始","电脑","两个","像","流程","到","接下来","框架","实际","可视","变化","形状","发展","不仅","范围","可重复性","物理","捕捉","转化","凭借","像头","不少","结果","想","用","生物","来","不同","又","红外光","接收","开发板","合适","横跨","；","稍后","服务","看到","）","智能","效果","要","pc","感器","rqt","获取","某些","科学","重要环节","重复性","跨越","一系列","来讲","原理","显示","相机","优势","做","质量"],"title":"机器视觉介绍","title_tokens":["视觉","机器","介绍"]},{"location":"hhp/5.1_%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E4%BB%8B%E7%BB%8D/#_1","text":"","text_tokens":[],"title":"机器视觉介绍","title_tokens":["视觉","机器","介绍"]},{"location":"hhp/5.1_%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E4%BB%8B%E7%BB%8D/#_2","text":"机器视觉， 就是用计算机来模拟人的视觉功能，但这并不仅仅是人眼的简单延伸，更重要的是像人脑一样，可以从客观事物的图像中提取信息，进行处理并加以理解，最终用于实际检测、控制等场景。 获取图像信息相对简单，但想让机器人理解图像中千变万化的物品，就难上加难了。 为了解决这一系列复杂的问题，机器视觉也是一个涉猎广泛的交叉学科，横跨人工智能、神经生物学、物理学、计算机科学、图像处理、模式识别等诸多领域。时至今日，在各个领域中，都有大量开发者或组织参与其中，也积累了众多技术，不过依然还有很多问题亟待解决，就像我们对自己大脑的研究也只是冰山一角一样，机器视觉的研究也将会是一个长久的工作。 机器视觉相关的关键技术也有不少，比如视觉图像的采集和信号处理，这个过程主要是通过传感器硬件采集外部光信号的过程，光信号最终会转变成数字电路的信号，便于下一步的处理；类似左边图片中看到的效果，获取图像之后，更重要的是要识别图像中的物体、确定物体的位置、或者检测物品的变化，这就要用到模式识别或者机器学习等技术，这个部分也是当今机器视觉研究的重点。 和人类的两只眼睛不同，机器用于获取图像的传感器种类较为丰富，可以是一个摄像头，也可以是两个摄像头，还可以是三个、四个、很多个摄像头，不仅可以获取颜色信息，还可以通过红外相机获取深度或者能量信息，这可比人眼获取的信息丰富多了，当然，这也会对后期的处理带来不同的计算压力。 在工业领域，机器视觉系统已经被广泛用于自动检验、工件加工、装配自动化以及生产过程控制等工作。随着机器人的快速发展和应用，机器视觉也逐渐应用于农业机器人、AMR物流机器人、服务机器人、无人驾驶汽车等各种机器人，活跃在农场、物流、仓储、交通、医院等多种环境中。","text_tokens":["图片","主要","复杂","模式","交通","可以","其中","种类","功能","技术","关键","传感器","深度","最终","能量","环境","更","相对","大量","用到","以及","逐渐","后期","计算机","各个领域","都","客观","应用","电路","理学","、","信号处理","数字电","类似","就","客观事物","带来","压力","加工","开发者","采集","便于","随着","神经","传感","让","较为","机器","就是","摄像","场景","控制","算机","人工","活跃","过程","开发","一角","还","系统","被","还有","自己","机器人","工件","难上加难","我们","物流","汽车","冰山一角","农业","，","仓储","数字","丰富","工作","检验","不过","生产","重要","加以","只是","领域","视觉","位置","学习","装配","无人","多种","物体","amr","变成","农场","信号","当今","图像处理","了","模拟","冰山","广泛","积累","外部","比如","红外","计算机科学","等","交叉学科","相关","组织","并","依然","人脑","自动化","用于","提取","光","部分","左边","问题","两个","简单","像","通过","识别","进行","信息","交叉","在","个","就要","人","从","实际","之后","当然","可比","下","转变","系列","硬件","数字电路","但","事物","检测","研究","很多","三个","变化","图像","发展","诸多","涉猎","亟待","对","也","无人驾驶","解决","一个","不仅","各个","人工智能","不仅仅","物理","会","转变成","计算","。","亟待解决","至今","驾驶","像头","不少","医院","仅仅","人类","人眼","为了","是","关键技术","颜色","想","快速","于","摄像头","处理","千变万化","用","的","生物","来","不同","四个","生物学","将","物品","或者","和","横跨","这","有","参与","两只","；"," ","模式识别","服务","自动","重点","看到","这个","今日","时至今日","智能","确定","效果","要","一系","眼睛","工业","感器","获取","一样","物理学","科学","长久","或","多","各种","大脑","已经","一系列","相机","中","一步","理解","众多","学科","延伸"],"title":"机器视觉概念","title_tokens":["视觉","机器","概念"]},{"location":"hhp/5.1_%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E4%BB%8B%E7%BB%8D/#_3","text":"人类视觉擅长于对复杂、非结构化的场景进行定性解释，但机器视觉凭借速度、精度和可重复性等优势，非常适合对结构化场景进行定量测量。 一般来讲，典型的机器视觉系统可以分为如图所示的三个部分：图像采集、图像分析和控制输出。 图像采集注重对原始光学信号的采样，是整个视觉系统的传感部分，核心是相机和相关的配件。 其中光源用于照明待检测的物体，并突显其特征，便于让相机能够更好的捕捉图像。光源是影响机器视觉系统成像质量的重要因素，好的光源和照明效果对机器视觉判断影响很大。当前，机器视觉的光源已经突破人眼的可见光范围，其光谱范围跨越红外光（IR）、可见光、紫外光（UV）乃至X射线波段，可实现更精细和更广泛的检测范围，以及特殊成像需求。 相机被喻为机器视觉系统的“眼睛”，承担着图像信息采集的重要任务。图像传感器又是相机的核心元器件，主要有CCD和CMOS两种类型，其工作原理是将相机镜头接收到的光学信号转化成数字信号。选择合适的相机是机器视觉系统设计的重要环节，不仅直接决定了采集图像的质量和速度，同时也与整个系统的运行模式相关。 图像处理系统接收到相机传来的数字图像之后，通过各种软件算法进行图像特征提取、特征分析和数据标定，最后进行判断。这是各种视觉算法研究最为集中的部分，从传统的模式识别算法，到当前热门的各种机器学习方法，都是为了更好的让机器理解环境。 对于人来讲，识别某一个物体是苹果似乎理所当然，但是对于机器人来讲，就需要提取各种各样不同种类、颜色、形状的苹果特征，然后训练得到一个苹果的“模型”，再通过这个模型对实时图像做匹配，从而分析面前这个东西到底是不是苹果。 在机器人系统中，视觉识别的结果最终要和机器人的某些行为绑定，也就是第三个部分——控制输出，包含I/O接口、运动控制、可视化显示等。当图像处理系统完成图像分析后，将判断的结果发给机器人控制系统，接下来机器人完成运动控制。比如视觉识别到了抓取目标的位置，通过IO口控制夹爪完成抓取和放置，过程中识别的结果和运动的状态，都可以在上位机中显示，方便我们监控。 就机器视觉而言，在这三个部分中，图像分析占据了绝对的核心，涉及的方法、使用的各种开源软件或者框架非常多，这也是我们后续开发的重点，TogetherROS中提供了大量的算法、工具和功能支持。","text_tokens":["各样","是不是","主要","复杂","模式","对于","可以","其中","ir","种类","成像","可","数据","匹配","定量","似乎","功能","精度","光谱","传感器","苹果","测量","环境","更","最终","大量","以及","理所当然","再","抓取","好","元器件","与","热门","都","工具","io","数字图像","所示","后","其","、","擅长于","就","占据","机中","分析","采集","便于","状态","而言","传感","让","可见","射线","机器","就是","场景","控制","最后","方便","绑定","实现","复性","被","系统","过程","开发","支持","接口","东西","软件","但是","机器人","我们","结构化","完成","，","实时","器件","类型","下来","传统","可见光","数字","然后","直接","选择","工作","光源","决定","使用","定性","重要","判断","波段","学习","视觉","位置","质量","长于","物体","标定","这是","任务","第三","绝对","更好","后续","信号","数字信号","紫外光","图像处理","当","光学","突破","了","爪","突显","采样","广泛","集中","从而","重复","红外","比如","控制系统","口","待","等","适合","注重","一般来讲","相关","配件","很大","承担","最为","并","解释","设计","cmos","化成","元器","夹","非","行为","用于","特征分析","模型","传来","上位","提取","部分","到","接下来","通过","框架","转化成","识别","进行","信息","在","环节","人","从","训练","运行","之后","典型","当然","紫外","需要","同时","但","三个","检测","研究","o","可视","togetherros","图像","输出","分为","因素","算法","各种各样","形状","第三个","放置","对","接下","也","特征提取","得到","速度","一个","不仅","监控","范围","可重复性","当前","目标","捕捉","转化","原始","i","。","凭借","不是","能够","喻为","人类","非常适合","一般","镜头","开源","特殊","人眼","照明","是","结构","为了","需求","颜色","结果","：","影响","处理","的","两种","（","着","又","接收","红外光","uv","ccd","不同","合适","面前","将","乃至","和","或者","这","有","方法","提供"," ","整个","模式识别","可视化","某","重点","这个","）","如图所示","涉及","眼睛","效果","要","—","感器","运动","包含","某些","到底","“","特征","重要环节","多","各种","重复性","擅长","已经","跨越","来讲","x射线","”","原理","显示","精细","相机","核心","中","发给","理解","优势","做","/","非常"],"title":"机器视觉流程","title_tokens":["视觉","机器","流程"]},{"location":"hhp/5.1_%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E4%BB%8B%E7%BB%8D/#x3","text":"了解了机器视觉的基本原理和流程，相信大家对视觉应用已经充满了期待，我们这就准备开始。 后续课程中，我们将继续在旭日X3派的开发板上，使用TogetherROS实现各种各样的视觉例程，不过我们得先找到一个相机，比如usb相机或者MIPI接口配套的相机模块，然后连接到开发板对应的接口上。 电脑和开发板之前通过网线连接，便于我们查看视觉处理的结果，速度更快。 如果有HDMI屏幕的话，也可以准备好，稍后需要使用的时候插上查看结果，如果没有的话，也没有影响，后续我们会使用一套网络传输工具，通过板卡的IP地址，就可以看到图像处理的实时状态啦。","text_tokens":["如果","各样","例程","基本","可以","ip地址","hdmi","一套","更","好","工具","派","应用","的话","先","就","模块","对应","便于","状态","机器","实现","得","屏幕","开发","配套","接口","准备","查看","我们","，","实时","相信","使用","然后","网络","不过","视觉","本原","后续","图像处理","了","课程","x3","啦","比如","大家","了解","usb","找到","开始","电脑","地址","流程","到","通过","在","没有","需要","板卡","togetherros","各种各样","图像","对","也","充满","连接","速度","一个","上","网线","会","快","。","时候","结果","处理","影响","的","插上","开发板","将","或者","和","基本原理","旭日","这","有"," ","稍后","看到","之前","各种","已经","原理","期待","相机","mipi","中","继续","传输"],"title":"旭日X3派配置","title_tokens":["旭日","x3","派","配置"]},{"location":"hhp/5.1_%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E4%BB%8B%E7%BB%8D/#usb","text":"关于相机的驱动，请大家也再确认一下，这是后续视觉处理的基础。 如果是USB相机的话，可以参考这个过程验证下是否可以顺利看到图像。 # 旭日X3派 $ sudo apt install ros-foxy-usb-cam $ cd /opt/tros $ python3 create_soft_link.py --foxy /opt/ros/foxy/ --tros /opt/tros $ source /opt/tros/local_setup.bash $ ros2 launch usb_cam demo_launch.py # 修改params.yaml配置文件中的设备号 # PC $ source /opt/ros/foxy/local_setup.bash $ ros2 run rqt_image_view rqt_image_view","text_tokens":["如果","py","可以","基础","驱动","foxy","再","一下","setup","派","source","的话","launch","apt","yaml","验证","ros","配置文件","ros2","关于","过程","，","tros","create","视觉","这是","后续","请",".","x3","params","参考","大家","是否","顺利","usb","号","python3","view","#","--","文件","soft","下","图像","-","配置","也","_","run","image","link","。","install","opt","是","bash","处理","cd","的","旭日","local"," ","修改","看到","这个","设备","pc","rqt","cam","$","demo","确认","相机","中","sudo","/"],"title":"USB相机图像采集","title_tokens":["图像","usb","相机","采集"]},{"location":"hhp/5.1_%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E4%BB%8B%E7%BB%8D/#mipi","text":"如果使用的是MIPI相机的话，可以参考这个流程驱动相机并显示图像。 # 旭日X3派 $ source /opt/tros/local_setup.bash $ ros2 run mipi_cam mipi_cam --ros-args -p video_device: = F37 -p image_width: = 960 -p image_height: = 540 # PC $ source /opt/ros/foxy/local_setup.bash $ ros2 run rqt_image_view rqt_image_view 为了提高图像的编码和传输效率，我们建议大家使用MIPI接口的相机，后续应用功能我们也会以该相机为主。","text_tokens":["如果","opt","是","为了","view","我们","bash","可以","流程","功能","驱动","的","，","foxy","#","--","使用","tros","height","和","旭日","args","local"," ",":","setup","这个","派","source","device","后续",".","的话","图像","效率","-","video","应用","pc","rqt","x3","该","也","_","960","f37","run","cam","$","image","建议","参考","提高","以","=","大家","会","编码","540","并","显示","为主","相机","。","ros","p","width","mipi","ros2","传输","/","接口"],"title":"MIPI相机图像采集","title_tokens":["图像","mipi","相机","采集"]},{"location":"hhp/5.2_CV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%8A%A0%E9%80%9F/","text":"CV图像加速处理 OpenCV是一个著名的机器视觉处理库，相信大家都有听过，这个库中有很多图像处理的基础算法，比如灰度变化、图像滤波等，不过这个库为了保证较好的通用性，主要通过软件实现各种算法，HHP对此作了大量优化，我们一起来看看。 HHP视觉加速 HHP中集成了地平线Hobot CV视觉加速库，通过底层芯片中的硬件引擎，软硬件协同，可以提升常用CV算子的性能，降低系统资源的消耗，例如高斯滤波、图像缩放、畸变校正等常用的视觉处理方法。 而且在接口风格上兼容OpenCV，可以做到与OpenCV混合编程，便于视觉应用的开发。 具体测试CV加速库的效率，与OpenCV中软件实现的效率进行对比，我们分别对比图像缩放的帧率，图像旋转的帧率，高斯滤波的帧率，通过Hobot CV视觉加速库运行的帧率可以做到OpenCV的2到3倍，甚至更多倍。 效果这么好，具体该如何使用呢？ 高斯滤波 我们先来看下图像处理中常用的高斯滤波算法，OpenCV和hobotcv，正面PK一下，我们也看看在程序中如何使用hobotcv的图像处理加速算法。 运行示例程序 $ source /opt/tros/setup.bash $ cp -r /opt/tros/lib/hobot_cv/config/ . $ ros2 launch hobot_cv hobot_cv_gaussian_blur.launch.py 代码解析 代码地址：https://c-gitlab.horizon.ai/HHP/box/hobot_cv/-/blob/develop/test/test_gaussian_blur.cpp // Copyright (c) 2021 Horizon Robotics.All Rights Reserved. // // The material in this file is confidential and contains trade secrets // of Horizon Robotics Inc. This is proprietary information owned by // Horizon Robotics Inc. No part of this work may be disclosed, // reproduced, copied, transmitted, or used in any way for any purpose, // without the express written permission of Horizon Robotics Inc. #include <algorithm> #include <chrono> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <queue> #include <utility> #include \"hobotcv_gaussian_blur.h\" #include \"opencv2/core/mat.hpp\" #include \"opencv2/imgcodecs.hpp\" #include \"opencv2/imgproc.hpp\" void analyse_result ( cv :: Mat & out_filter , cv :: Mat & cls_filter , std :: string flag_name ) { auto start_time = std :: chrono :: steady_clock :: now (); std :: cout << \"\" << std :: endl ; std :: cout << \"analyse_result start \" << std :: endl ; std :: cout << \"---------\" << flag_name << std :: endl ; std :: cout << \"out_filter type:\" << out_filter . type () << \",cols:\" << out_filter . cols << \",rows:\" << out_filter . rows << \",channel:\" << out_filter . channels () << std :: endl ; std :: cout << \"cls_filter type:\" << cls_filter . type () << \",cols:\" << cls_filter . cols << \",rows:\" << cls_filter . rows << \",channel:\" << cls_filter . channels () << std :: endl ; double minvalue , maxvalue ; cv :: Point mixIdx , maxIdx ; cv :: minMaxLoc ( out_filter , & minvalue , & maxvalue , & mixIdx , & maxIdx ); std :: cout << \"out_filter minvalue:\" << minvalue << \",max:\" << maxvalue << std :: endl ; std :: cout << \"out_filter min,x:\" << mixIdx . x << \",y:\" << mixIdx . y << std :: endl ; std :: cout << \"out_filter max,x:\" << maxIdx . x << \",y:\" << maxIdx . y << std :: endl ; cv :: minMaxLoc ( cls_filter , & minvalue , & maxvalue , & mixIdx , & maxIdx ); std :: cout << \"cls_filter minvalue:\" << minvalue << \",max:\" << maxvalue << std :: endl ; std :: cout << \"cls_filter min,x:\" << mixIdx . x << \",y:\" << mixIdx . y << std :: endl ; std :: cout << \"cls_filter max,x:\" << maxIdx . x << \",y:\" << maxIdx . y << std :: endl ; cv :: Mat mat_diff = cv :: abs ( out_filter - cls_filter ); cv :: Scalar sum_error = cv :: sum ( mat_diff >= 1 ); cv :: Scalar mean_error = cv :: sum ( mat_diff ) / ( mat_diff . rows * mat_diff . cols ); cv :: minMaxLoc ( mat_diff , & minvalue , & maxvalue , & mixIdx , & maxIdx ); std :: cout << \"\" << std :: endl ; std :: cout << \"diff diff diff\" << std :: endl ; std :: cout << \"mat_diff minvalue:\" << minvalue << \",max:\" << maxvalue << std :: endl ; std :: cout << \"mat_diff min,x:\" << mixIdx . x << \",y:\" << mixIdx . y << std :: endl ; std :: cout << \"mat_diff max,x:\" << maxIdx . x << \",y:\" << maxIdx . y << std :: endl ; std :: cout << \"\" << std :: endl ; std :: cout << \"error sum:\" << sum_error [ 0 ] << \",max:\" << maxvalue << \",mean_error:\" << mean_error [ 0 ] << std :: endl ; int time_used_ms_end = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( std :: chrono :: steady_clock :: now () - start_time ) . count (); std :: cout << \"analyse_result,time_used_ms_end:\" << time_used_ms_end << std :: endl ; std :: cout << \"analyse_result end \" << std :: endl ; std :: cout << \"\" << std :: endl ; } int main () { int32_t ret = -1 ; HobotGaussianBlurParam blur_param ; HOBOTCV_INITIALIZE_GAUSSIAN_BLUR_PARAM ( & blur_param ); HobotCVGaussianBlurHandle handle ; ret = HobotCVGaussianBlurCreate ( blur_param , & handle ); if ( ret < 0 ) { printf ( \"HobotCVGaussianBlurCreate failed, error msg:%d \\n \" , ret ); return -1 ; } for ( int i = 0 ; i < 5 ; i ++ ) { std :: string m_tof_file_s = \"images/frame1_\" + std :: to_string ( i ) + \".png\" ; std :: cout << \"===================\" << std :: endl ; std :: cout << \"image name :\" << m_tof_file_s << std :: endl ; cv :: Mat src = cv :: imread ( m_tof_file_s , CV_16UC1 ); cv :: Mat dst ; cv :: medianBlur ( src , src , 3 ); auto start_time_infe = std :: chrono :: steady_clock :: now (); ret = HobotCVGaussianBlurProcess ( handle , & src , & dst ); if ( ret < 0 ) { printf ( \"HobotCVGaussianBlurProcess failed, error msg:%d \\n \" , ret ); return -1 ; } int infe_time = std :: chrono :: duration_cast < std :: chrono :: microseconds > ( std :: chrono :: steady_clock :: now () - start_time_infe ). count (); std :: cout << \"infe cost time:\" << infe_time << std :: endl ; auto start_time_gauss = std :: chrono :: steady_clock :: now (); cv :: Mat gaussian_tof ; cv :: GaussianBlur ( src , gaussian_tof , cv :: Size ( 3 , 3 ), 0 , 0 , cv :: BORDER_REPLICATE ); int guss_time = std :: chrono :: duration_cast < std :: chrono :: microseconds > ( std :: chrono :: steady_clock :: now () - start_time_gauss ). count (); std :: cout << \"guss_time cost time:\" << guss_time << std :: endl ; float save_rate = float (( guss_time * 1.0 - infe_time * 1.0 ) / guss_time ); std :: cout << \"hobotcv save rate:\" << save_rate << std :: endl ; analyse_result ( dst , gaussian_tof , \"GaussianBlur\" ); std :: cout << \"-------------------------\" << std :: endl ; std :: cout << \"\" << std :: endl ; } ret = HobotCVGaussianBlurDestroy ( handle ); if ( ret < 0 ) { printf ( \"HobotCVGaussianBlurDestroy failed, error msg:%d \\n \" , ret ); return -1 ; } return 0 ; } 图像裁剪与缩放 再来看另外一个案例，图像的裁剪与缩放，比如这样一幅图片，我们尝试剪裁左上角的一小块图像出来，或者对裁剪的某一块图像放大来看看。 运行示例程序 # 配置TogetherROS环境 source /opt/tros/setup.bash # 从TogetherROS的安装路径中拷贝出运行示例需要的模型和配置文件。 cp -r /opt/tros/lib/hobot_cv/config/ . # 启动launch文件 ros2 launch hobot_cv hobot_cv_crop_resize.launch.py 代码解析 代码地址：https://c-gitlab.horizon.ai/HHP/box/hobot_cv/-/blob/develop/src/test.cpp // Copyright (c) 2021 Horizon Robotics.All Rights Reserved. // // The material in this file is confidential and contains trade secrets // of Horizon Robotics Inc. This is proprietary information owned by // Horizon Robotics Inc. No part of this work may be disclosed, // reproduced, copied, transmitted, or used in any way for any purpose, // without the express written permission of Horizon Robotics Inc. #include \"include/hobotcv_imgproc.h\" #include \"include/utils.h\" #include \"opencv2/core/mat.hpp\" #include \"opencv2/core/types.hpp\" #include \"opencv2/imgcodecs.hpp\" #include \"opencv2/opencv.hpp\" #include <fstream> #include <string> #include <chrono> #include <iostream> void writeImg ( cv :: Mat & mat , std :: string imgfile ) { cv :: Mat img_bgr ; cv :: cvtColor ( mat , img_bgr , cv :: COLOR_YUV2BGR_NV12 ); cv :: imwrite ( imgfile , img_bgr ); } int main () { std :: string image_file = \"config/test.jpg\" ; cv :: Mat bgr_mat = cv :: imread ( image_file , cv :: IMREAD_COLOR ); auto src_height = bgr_mat . rows ; auto src_width = bgr_mat . cols ; cv :: Mat srcmat_nv12 ; BGRToNv12 ( bgr_mat , srcmat_nv12 ); auto dst_height = src_height / 2 ; auto dst_width = src_width / 2 ; cv :: Mat dstmat_nv12 ( dst_height * 3 / 2 , dst_width , CV_8UC1 ); auto before_resize = std :: chrono :: system_clock :: now (); auto ret = hobot_cv :: hobotcv_resize ( srcmat_nv12 , src_height , src_width , dstmat_nv12 , dst_height , dst_width ); auto after_resize = std :: chrono :: system_clock :: now (); auto interval = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( after_resize - before_resize ). count (); if ( 0 == ret ) { std :: cout << \"resize finish, time: \" << interval << \"ms\" << std :: endl ; } writeImg ( dstmat_nv12 , \"./resize.jpg\" ); auto before_crop = std :: chrono :: system_clock :: now (); auto cropmat = hobot_cv :: hobotcv_crop ( srcmat_nv12 , src_height , src_width , 200 , 200 , cv :: Range ( 0 , 200 ), cv :: Range ( 0 , 200 )); auto after_crop = std :: chrono :: system_clock :: now (); interval = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( after_crop - before_crop ). count (); std :: cout << \"crop finish, time: \" << interval << \"ms\" << std :: endl ; writeImg ( cropmat , \"./crop.jpg\" ); auto before_cropResize = std :: chrono :: system_clock :: now (); auto cropResizemat = hobot_cv :: hobotcv_crop ( srcmat_nv12 , src_height , src_width , src_height , src_width , cv :: Range ( 200 , 400 ), cv :: Range ( 200 , 400 )); auto after_cropResize = std :: chrono :: system_clock :: now (); interval = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( after_cropResize - before_cropResize ). count (); std :: cout << \"cropResize finish, time: \" << interval << \"ms\" << std :: endl ; writeImg ( cropResizemat , \"./cropResize.jpg\" ); return 0 ; }","text_tokens":["imgcodecs","x","after","主要","py","例如","contains","failed","一下","好","imgfile","iterator","应用","剪裁","%","maxvalue","便于","对此","通用","机器","配置文件","实现","兼容","ret","hobotcvgaussianblurdestroy","out","initialize","使用","不过","flag",".","2021","int","该","风格","cost","尝试","config","另外",";","frame1","上角","time","robotics","看看","transmitted","地址","secrets","opencv2","通过","#","进行","void","end","从","owned","下","需要","togetherros","很多","finish","算法","-","裁剪","dst","information","map","way","if","。","出来",")","opt","为了","to","bash","处理","be","save","min","混合","cropmat","方法","如何","rights","copied","h","效率","代码","hobot","hobotcvgaussianblurcreate","steady","max","milliseconds","一小","inc","cropresize","帧","confidential","channels","0","提升","blob","include","n","count","1.0","all","box","of","&","replicate","环境","再","？","都","与","source","---------","一块","先","y","launch","-------------------------","多倍","降低","utils","系统","开发","接口","bgr","起来","algorithm","filter","color","相信","地平线","tros","param","guss","程序","sum","hobotcvgaussianblurhandle","utility","优化","图像处理","一","呢","resize","reproduced","d","horizon","gaussian","较","minvalue","error","no","文件","在","minmaxloc","硬件","start","m","配置","对","正面","5","_","the","float","reserved","image","written","rate","一个","上","测试","nv12","result","灰度","*","旋转","是","hobotgaussianblurparam","甚至","或者","\\","part","这个","pk","启动","=","purpose","gitlab","opencv","iostream","yuv2bgr","/","<","name","著名","2","加速","可以","]","放大",":","permission","cv","src","\"","setup","scalar","、","一小块","cropresizemat","ros2","bgrtonv12","率","gauss","imread","before","interval","diff","disclosed","，","而且","height","gaussianblur","具体","性能","视觉","(","now","cast","200","左上角","比如","and","work","等","chrono","cpp","引擎","in","模型","test","hobotcvgaussianblurprocess","r","mixidx","express","运行","安装","hobotcv","img","案例","图像","算子","by","也","or","cout","images","trade","i","fstream","msg","：","的","+","常用","和",">","有","imgproc"," ","作","3","库中","printf","某","tof","t","develop","$","border","各种","blur","集成","cp","this","地平","中","hpp","medianblur","软硬件","string","图片","这样","小块","基础","通用性","auto","更","大量","ms","编程","1","handle","400","hhp","material","对比","writeimg","range","一幅","mean","做到","point","++","infe","拷贝","width","without","软件","iomanip","示例","s","我们","畸变","size","倍","rows","is","main","路径","dstmat","types","系统资源","proprietary","了","16uc1","crop","软硬","for","协同","大家","{","jpg","double","8uc1","return","校正","出","芯片","core","到","这么","分别","解析","int32","copyright",",","mat","ai","保证","type","变化","srcmat","any","c","左上","used","高斯","来看","std","lib","}","abs","queue","cols","缩放","来","滤波","消耗","png","system","microseconds","过","imwrite","https","duration","maxidx","效果","analyse","资源","may","clock","库","cls","底层","cvtcolor","endl","file","channel","[","听"],"title":"CV图像处理加速","title_tokens":["加速","图像","cv","处理","图像处理"]},{"location":"hhp/5.2_CV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%8A%A0%E9%80%9F/#cv","text":"OpenCV是一个著名的机器视觉处理库，相信大家都有听过，这个库中有很多图像处理的基础算法，比如灰度变化、图像滤波等，不过这个库为了保证较好的通用性，主要通过软件实现各种算法，HHP对此作了大量优化，我们一起来看看。","text_tokens":["看看","为了","是","著名","软件","起来","主要","我们","处理","基础","的","，","通过","相信","通用性","滤波","过","不过","有","大量","视觉","好","作","都","保证","库中","这个","hhp","很多","变化","优化","图像","图像处理","算法","、","了","一","库","比如","对此","各种","一个","等","大家","通用","机器","较","。","实现","灰度","opencv","听"],"title":"CV图像加速处理","title_tokens":["图像","加速","cv","处理"]},{"location":"hhp/5.2_CV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%8A%A0%E9%80%9F/#hhp","text":"HHP中集成了地平线Hobot CV视觉加速库，通过底层芯片中的硬件引擎，软硬件协同，可以提升常用CV算子的性能，降低系统资源的消耗，例如高斯滤波、图像缩放、畸变校正等常用的视觉处理方法。 而且在接口风格上兼容OpenCV，可以做到与OpenCV混合编程，便于视觉应用的开发。 具体测试CV加速库的效率，与OpenCV中软件实现的效率进行对比，我们分别对比图像缩放的帧率，图像旋转的帧率，高斯滤波的帧率，通过Hobot CV视觉加速库运行的帧率可以做到OpenCV的2到3倍，甚至更多倍。 效果这么好，具体该如何使用呢？","text_tokens":["2","例如","加速","可以","更","编程","好","cv","与","？","hhp","应用","、","对比","便于","多倍","做到","降低","实现","兼容","开发","系统","率","接口","软件","我们","畸变","倍","，","而且","地平线","使用","具体","性能","视觉","系统资源","呢","了","该","风格","软硬","协同","等","引擎","校正","芯片","到","这么","通过","分别","进行","在","运行","硬件","图像","算子","高斯","上","测试","。","旋转","缩放","处理","的","滤波","消耗","甚至","常用","混合","方法"," ","3","如何","效率","效果","hobot","资源","库","帧","底层","集成","提升","地平","中","opencv","软硬件"],"title":"HHP视觉加速","title_tokens":["视觉","加速","hhp"]},{"location":"hhp/5.2_CV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%8A%A0%E9%80%9F/#_1","text":"我们先来看下图像处理中常用的高斯滤波算法，OpenCV和hobotcv，正面PK一下，我们也看看在程序中如何使用hobotcv的图像处理加速算法。","text_tokens":["看看","我们","加速","处理","的","，","使用","滤波","在","常用","和","下","一下","程序","hobotcv","如何","pk","算法","图像处理","图像","先","正面","也","高斯","来看","。","中","opencv"],"title":"高斯滤波","title_tokens":["滤波","高斯"]},{"location":"hhp/5.2_CV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%8A%A0%E9%80%9F/#_2","text":"$ source /opt/tros/setup.bash $ cp -r /opt/tros/lib/hobot_cv/config/ . $ ros2 launch hobot_cv hobot_cv_gaussian_blur.launch.py","text_tokens":["opt","py","bash","r","tros"," ","cv","setup","source",".","-","hobot","launch","_","$","config","blur","gaussian","cp","lib","ros2","/"],"title":"运行示例程序","title_tokens":["示例","程序","运行"]},{"location":"hhp/5.2_CV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%8A%A0%E9%80%9F/#_3","text":"代码地址：https://c-gitlab.horizon.ai/HHP/box/hobot_cv/-/blob/develop/test/test_gaussian_blur.cpp // Copyright (c) 2021 Horizon Robotics.All Rights Reserved. // // The material in this file is confidential and contains trade secrets // of Horizon Robotics Inc. This is proprietary information owned by // Horizon Robotics Inc. No part of this work may be disclosed, // reproduced, copied, transmitted, or used in any way for any purpose, // without the express written permission of Horizon Robotics Inc. #include <algorithm> #include <chrono> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <queue> #include <utility> #include \"hobotcv_gaussian_blur.h\" #include \"opencv2/core/mat.hpp\" #include \"opencv2/imgcodecs.hpp\" #include \"opencv2/imgproc.hpp\" void analyse_result ( cv :: Mat & out_filter , cv :: Mat & cls_filter , std :: string flag_name ) { auto start_time = std :: chrono :: steady_clock :: now (); std :: cout << \"\" << std :: endl ; std :: cout << \"analyse_result start \" << std :: endl ; std :: cout << \"---------\" << flag_name << std :: endl ; std :: cout << \"out_filter type:\" << out_filter . type () << \",cols:\" << out_filter . cols << \",rows:\" << out_filter . rows << \",channel:\" << out_filter . channels () << std :: endl ; std :: cout << \"cls_filter type:\" << cls_filter . type () << \",cols:\" << cls_filter . cols << \",rows:\" << cls_filter . rows << \",channel:\" << cls_filter . channels () << std :: endl ; double minvalue , maxvalue ; cv :: Point mixIdx , maxIdx ; cv :: minMaxLoc ( out_filter , & minvalue , & maxvalue , & mixIdx , & maxIdx ); std :: cout << \"out_filter minvalue:\" << minvalue << \",max:\" << maxvalue << std :: endl ; std :: cout << \"out_filter min,x:\" << mixIdx . x << \",y:\" << mixIdx . y << std :: endl ; std :: cout << \"out_filter max,x:\" << maxIdx . x << \",y:\" << maxIdx . y << std :: endl ; cv :: minMaxLoc ( cls_filter , & minvalue , & maxvalue , & mixIdx , & maxIdx ); std :: cout << \"cls_filter minvalue:\" << minvalue << \",max:\" << maxvalue << std :: endl ; std :: cout << \"cls_filter min,x:\" << mixIdx . x << \",y:\" << mixIdx . y << std :: endl ; std :: cout << \"cls_filter max,x:\" << maxIdx . x << \",y:\" << maxIdx . y << std :: endl ; cv :: Mat mat_diff = cv :: abs ( out_filter - cls_filter ); cv :: Scalar sum_error = cv :: sum ( mat_diff >= 1 ); cv :: Scalar mean_error = cv :: sum ( mat_diff ) / ( mat_diff . rows * mat_diff . cols ); cv :: minMaxLoc ( mat_diff , & minvalue , & maxvalue , & mixIdx , & maxIdx ); std :: cout << \"\" << std :: endl ; std :: cout << \"diff diff diff\" << std :: endl ; std :: cout << \"mat_diff minvalue:\" << minvalue << \",max:\" << maxvalue << std :: endl ; std :: cout << \"mat_diff min,x:\" << mixIdx . x << \",y:\" << mixIdx . y << std :: endl ; std :: cout << \"mat_diff max,x:\" << maxIdx . x << \",y:\" << maxIdx . y << std :: endl ; std :: cout << \"\" << std :: endl ; std :: cout << \"error sum:\" << sum_error [ 0 ] << \",max:\" << maxvalue << \",mean_error:\" << mean_error [ 0 ] << std :: endl ; int time_used_ms_end = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( std :: chrono :: steady_clock :: now () - start_time ) . count (); std :: cout << \"analyse_result,time_used_ms_end:\" << time_used_ms_end << std :: endl ; std :: cout << \"analyse_result end \" << std :: endl ; std :: cout << \"\" << std :: endl ; } int main () { int32_t ret = -1 ; HobotGaussianBlurParam blur_param ; HOBOTCV_INITIALIZE_GAUSSIAN_BLUR_PARAM ( & blur_param ); HobotCVGaussianBlurHandle handle ; ret = HobotCVGaussianBlurCreate ( blur_param , & handle ); if ( ret < 0 ) { printf ( \"HobotCVGaussianBlurCreate failed, error msg:%d \\n \" , ret ); return -1 ; } for ( int i = 0 ; i < 5 ; i ++ ) { std :: string m_tof_file_s = \"images/frame1_\" + std :: to_string ( i ) + \".png\" ; std :: cout << \"===================\" << std :: endl ; std :: cout << \"image name :\" << m_tof_file_s << std :: endl ; cv :: Mat src = cv :: imread ( m_tof_file_s , CV_16UC1 ); cv :: Mat dst ; cv :: medianBlur ( src , src , 3 ); auto start_time_infe = std :: chrono :: steady_clock :: now (); ret = HobotCVGaussianBlurProcess ( handle , & src , & dst ); if ( ret < 0 ) { printf ( \"HobotCVGaussianBlurProcess failed, error msg:%d \\n \" , ret ); return -1 ; } int infe_time = std :: chrono :: duration_cast < std :: chrono :: microseconds > ( std :: chrono :: steady_clock :: now () - start_time_infe ). count (); std :: cout << \"infe cost time:\" << infe_time << std :: endl ; auto start_time_gauss = std :: chrono :: steady_clock :: now (); cv :: Mat gaussian_tof ; cv :: GaussianBlur ( src , gaussian_tof , cv :: Size ( 3 , 3 ), 0 , 0 , cv :: BORDER_REPLICATE ); int guss_time = std :: chrono :: duration_cast < std :: chrono :: microseconds > ( std :: chrono :: steady_clock :: now () - start_time_gauss ). count (); std :: cout << \"guss_time cost time:\" << guss_time << std :: endl ; float save_rate = float (( guss_time * 1.0 - infe_time * 1.0 ) / guss_time ); std :: cout << \"hobotcv save rate:\" << save_rate << std :: endl ; analyse_result ( dst , gaussian_tof , \"GaussianBlur\" ); std :: cout << \"-------------------------\" << std :: endl ; std :: cout << \"\" << std :: endl ; } ret = HobotCVGaussianBlurDestroy ( handle ); if ( ret < 0 ) { printf ( \"HobotCVGaussianBlurDestroy failed, error msg:%d \\n \" , ret ); return -1 ; } return 0 ; }","text_tokens":["imgcodecs","string","x","1.0","all","contains","box","of","&","replicate","auto","ms","]",":","failed","permission","cv","1","handle","\"","src","iterator","hhp","---------","scalar","material","y","%","-------------------------","maxvalue","mean","point","++","infe","ret","gauss","hobotcvgaussianblurdestroy","imread","without","iomanip","algorithm","diff","disclosed","filter","out","s","rows","size","initialize","is","param","medianblur","gaussianblur","main","guss","flag","sum","hobotcvgaussianblurhandle","utility",".","(","proprietary","2021","now","cast","int","16uc1","n","reproduced","d","and","work","cost","for","horizon","{","gaussian","chrono","minvalue","cpp",";","frame1","time","double","return","in","robotics","error","transmitted","地址","test","secrets","opencv2","core","hobotcvgaussianblurprocess","no","#","mixidx","void","end","int32","express","minmaxloc","owned","copyright",",","mat","ai","hobotcv","type","start","m","-","c","any","by","dst","information","5","_","the","or","float","map","reserved","used","image","written","rate","std","cout","images","trade","way","result","i","if","}","fstream","msg",")","abs","*","queue","hobotgaussianblurparam","to","cols","：","be","save","+","png","min",">","part","\\","microseconds","imgproc"," ","https","3","rights","duration","printf","copied","maxidx","h","代码","hobot","analyse","hobotcvgaussianblurcreate","may","clock","steady","max","tof","t","milliseconds","develop","inc","border","cls","=","blur","confidential","channels","0","this","endl","purpose","gitlab","blob","include","file","iostream","hpp","channel","/","[","<","name","count"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"hhp/5.2_CV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%8A%A0%E9%80%9F/#_4","text":"再来看另外一个案例，图像的裁剪与缩放，比如这样一幅图片，我们尝试剪裁左上角的一小块图像出来，或者对裁剪的某一块图像放大来看看。","text_tokens":["看看","图片","我们","缩放","这样","小块","，","的","来","或者","再","放大","与","某","案例","一块","图像","一小块","裁剪","剪裁","对","左上","左上角","比如","一幅","一小","来看","一个","尝试","另外","。","出来","上角"],"title":"图像裁剪与缩放","title_tokens":["缩放","图像","裁剪","与"]},{"location":"hhp/5.2_CV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%8A%A0%E9%80%9F/#_5","text":"# 配置TogetherROS环境 source /opt/tros/setup.bash # 从TogetherROS的安装路径中拷贝出运行示例需要的模型和配置文件。 cp -r /opt/tros/lib/hobot_cv/config/ . # 启动launch文件 ros2 launch hobot_cv hobot_cv_crop_resize.launch.py","text_tokens":["opt","/","示例","py","bash","的","r","#","文件","tros","环境","从","和","运行"," ","安装","需要","cv","路径","setup","togetherros","source",".","启动","-","hobot","配置","resize","crop","launch","_","模型","config","cp","。","lib","拷贝","配置文件","中","ros2","出"],"title":"运行示例程序","title_tokens":["示例","程序","运行"]},{"location":"hhp/5.2_CV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%8A%A0%E9%80%9F/#_6","text":"代码地址：https://c-gitlab.horizon.ai/HHP/box/hobot_cv/-/blob/develop/src/test.cpp // Copyright (c) 2021 Horizon Robotics.All Rights Reserved. // // The material in this file is confidential and contains trade secrets // of Horizon Robotics Inc. This is proprietary information owned by // Horizon Robotics Inc. No part of this work may be disclosed, // reproduced, copied, transmitted, or used in any way for any purpose, // without the express written permission of Horizon Robotics Inc. #include \"include/hobotcv_imgproc.h\" #include \"include/utils.h\" #include \"opencv2/core/mat.hpp\" #include \"opencv2/core/types.hpp\" #include \"opencv2/imgcodecs.hpp\" #include \"opencv2/opencv.hpp\" #include <fstream> #include <string> #include <chrono> #include <iostream> void writeImg ( cv :: Mat & mat , std :: string imgfile ) { cv :: Mat img_bgr ; cv :: cvtColor ( mat , img_bgr , cv :: COLOR_YUV2BGR_NV12 ); cv :: imwrite ( imgfile , img_bgr ); } int main () { std :: string image_file = \"config/test.jpg\" ; cv :: Mat bgr_mat = cv :: imread ( image_file , cv :: IMREAD_COLOR ); auto src_height = bgr_mat . rows ; auto src_width = bgr_mat . cols ; cv :: Mat srcmat_nv12 ; BGRToNv12 ( bgr_mat , srcmat_nv12 ); auto dst_height = src_height / 2 ; auto dst_width = src_width / 2 ; cv :: Mat dstmat_nv12 ( dst_height * 3 / 2 , dst_width , CV_8UC1 ); auto before_resize = std :: chrono :: system_clock :: now (); auto ret = hobot_cv :: hobotcv_resize ( srcmat_nv12 , src_height , src_width , dstmat_nv12 , dst_height , dst_width ); auto after_resize = std :: chrono :: system_clock :: now (); auto interval = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( after_resize - before_resize ). count (); if ( 0 == ret ) { std :: cout << \"resize finish, time: \" << interval << \"ms\" << std :: endl ; } writeImg ( dstmat_nv12 , \"./resize.jpg\" ); auto before_crop = std :: chrono :: system_clock :: now (); auto cropmat = hobot_cv :: hobotcv_crop ( srcmat_nv12 , src_height , src_width , 200 , 200 , cv :: Range ( 0 , 200 ), cv :: Range ( 0 , 200 )); auto after_crop = std :: chrono :: system_clock :: now (); interval = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( after_crop - before_crop ). count (); std :: cout << \"crop finish, time: \" << interval << \"ms\" << std :: endl ; writeImg ( cropmat , \"./crop.jpg\" ); auto before_cropResize = std :: chrono :: system_clock :: now (); auto cropResizemat = hobot_cv :: hobotcv_crop ( srcmat_nv12 , src_height , src_width , src_height , src_width , cv :: Range ( 200 , 400 ), cv :: Range ( 200 , 400 )); auto after_cropResize = std :: chrono :: system_clock :: now (); interval = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( after_cropResize - before_cropResize ). count (); std :: cout << \"cropResize finish, time: \" << interval << \"ms\" << std :: endl ; writeImg ( cropResizemat , \"./cropResize.jpg\" ); return 0 ; }","text_tokens":["imgcodecs","string","all","2","after","contains","box","of","&","auto","ms",":","permission","cv","imgfile","src","\"","400","hhp","material","writeimg","range","cropresizemat","width","utils","bgrtonv12","ret","imread","without","before","bgr","interval","disclosed","rows","color","is","height","main","dstmat","types",".","(","proprietary","2021","now","cast","int","resize","crop","200","reproduced","and","work","for","horizon","config","{","jpg","chrono","cpp",";","time","8uc1","return","in","robotics","transmitted","地址","test","secrets","opencv2","core","no","#","void","express","owned","copyright",",","mat","ai","hobotcv","img","finish","srcmat","-","c","any","by","dst","information","_","the","or","reserved","used","image","written","std","cout","trade","nv12","way","if","}","fstream",")","*","cols","：","be","system",">","part","imwrite","cropmat","imgproc"," ","https","3","rights","duration","copied","h","代码","hobot","may","clock","milliseconds","develop","inc","cropresize","=","confidential","cvtcolor","0","this","endl","purpose","gitlab","blob","include","file","opencv","hpp","iostream","yuv2bgr","/","<","count"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"hhp/5.3_%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E6%A1%86%E6%9E%B6/","text":"模型推理框架 智能机器人与机器学习是紧密相连的，机器学习又可以分成数据采集、标注、训练、推理等环节，其中数据的训练需要消耗大量算力，适合在服务器或者云端进行，不过训练好的模型可是要部署到机器人端进行推理运算的，所以模型推理的效率如何，直接决定了机器人视觉处理的效率，这刚好是HHP所擅长的地方。 Hobot DNN模型推理库 HHP集成了Hobot DNN模型推理库，集成了众多开源模型，借助底层芯片中的AI引擎BPU，提供充足的算力保障，开发者实际使用中，就不用花费很多时间在模型的调教和数据的训练上，基于这套系统，很快就可以部署人工智能应用啦。 hobot_dnn是在地平线X3开发板上利用BPU处理器实现AI推理功能，基于地平线EasyDNN和ROS2 Node进行二次开发，为应用开发提供更简单易用的模型集成开发接口，包括模型管理、基于模型描述的输入处理及结果解析，以及模型输出内存分配管理等功能。 关于hobot_dnn的使用逻辑流程如这张图所示，供大家参考，我们后续也会通过具体的案例解释代码的实现过程。 算法与应用库 在Hobot DNN模型推理库的基础上，地平线还提供了一套基于TogetherROS系统的AI算法包，称为BOXs，这样我们就不需要从零构建算法，基于这些标准而高效的算法，可以更关注应用层面的APP开发。 从这张图中我们可以看到，这套AI算法包中包含两大块，一个是基础算法，一个是应用算法。 基础算法中主要是图像分类、语义分割和目标检测这些常用的算法，应用层面就会基于这些算法和某些场景，动态实现更为复杂的人体识别、骨骼点识别、手势识别等具体的功能，这些模块就可以和机器人运功功能直接结合，节省了我们开发AI视觉部分的时间。 模型推理测试 这套模型推理和算法库的效果如何呢？ 我们先来体验一个HHP自带的案例，识别这张图片中的人，以及每个人的骨骼关键点。 # 配置TogetherROS环境 $ source /opt/tros/setup.bash # 从tros的安装路径中拷贝出运行示例需要的配置文件。config中为example使用的模型，回灌使用的本地图片 $ cp -r /opt/tros/lib/dnn_node_example/config/ . # 使用本地jpg格式图片通过同步模式进行回环预测，并存储渲染后的图片 $ ros2 launch dnn_node_example hobot_dnn_node_example_feedback.launch.py","text_tokens":["图片","务器","相连","主要","这样","复杂","节省","可以","其中","模式","功能","基础","node","数据","关键","如","一套","环境","更","充足","这张","大量","以及","动态","分配","好","处理器","与","？","分类","setup","同步","hhp","所示","应用","这套","体验","source","bpu","、","先","后","就","feedback","模块","launch","结合","云端","基于","存储","包中","开发者","这些","采集","管理","部署","易用","机器","高效","大块","场景","服务器","人工","拷贝","配置文件","ros2","实现","理器","所","关于","两大块","分割","过程","开发","系统","还","dnn","称为","接口","渲染","机器人","示例","我们","人体","每个","，","描述","标注","地平线","使用","不用","直接","tros","决定","不过","具体","学习","视觉","路径","二次开发","中为","算力","后续",".","呢","了","啦","x3","调教","供","骨骼","预测","参考","等","适合","大家","config","零","jpg","并","解释","引擎","easydnn","所以","模型","出","标准","部分","逻辑","芯片","运功","格式","简单","流程","到","r","通过","框架","#","识别","文件","进行","解析","在","环节","二次","人","从","训练","包括","实际","运行","需要","安装","ai","检测","togetherros","分成","很多","很快","案例","输出","算法","图像","-","配置","及","_","也","花费","手势","一个","上","测试","人工智能","会","层面","目标","运算","张图","包","。","利用","而","lib","example","自带","紧密","开源","保障","opt","是","结果","boxs","bash","处理","的","端","输入","来","又","构建","开发板","消耗","借助","为","或者","和","常用","这","提供","可是"," ","语义","app","服务","本地","py","如何","刚好","看到","智能","效率","代码","要","hobot","不","效果","库","包含","某些","推理","更为","$","底层","擅长","集成","时间","关注","cp","地平","中","回灌","关键点","内存","点","众多","/","地方","回环"],"title":"模型推理框架","title_tokens":["模型","推理","框架"]},{"location":"hhp/5.3_%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E6%A1%86%E6%9E%B6/#_1","text":"智能机器人与机器学习是紧密相连的，机器学习又可以分成数据采集、标注、训练、推理等环节，其中数据的训练需要消耗大量算力，适合在服务器或者云端进行，不过训练好的模型可是要部署到机器人端进行推理运算的，所以模型推理的效率如何，直接决定了机器人视觉处理的效率，这刚好是HHP所擅长的地方。","text_tokens":["是","务器","机器人","相连","所以","可以","其中","处理","的","，","数据","到","又","标注","端","进行","直接","消耗","环节","在","或者","决定","训练","大量","不过","这","学习","可是","需要","视觉","好","服务","与","算力","如何","刚好","hhp","分成","智能","效率","、","要","了","云端","推理","采集","等","适合","部署","擅长","机器","运算","。","服务器","所","紧密","模型","地方"],"title":"模型推理框架","title_tokens":["模型","推理","框架"]},{"location":"hhp/5.3_%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E6%A1%86%E6%9E%B6/#hobot-dnn","text":"HHP集成了Hobot DNN模型推理库，集成了众多开源模型，借助底层芯片中的AI引擎BPU，提供充足的算力保障，开发者实际使用中，就不用花费很多时间在模型的调教和数据的训练上，基于这套系统，很快就可以部署人工智能应用啦。 hobot_dnn是在地平线X3开发板上利用BPU处理器实现AI推理功能，基于地平线EasyDNN和ROS2 Node进行二次开发，为应用开发提供更简单易用的模型集成开发接口，包括模型管理、基于模型描述的输入处理及结果解析，以及模型输出内存分配管理等功能。 关于hobot_dnn的使用逻辑流程如这张图所示，供大家参考，我们后续也会通过具体的案例解释代码的实现过程。","text_tokens":["可以","功能","node","数据","如","更","充足","以及","分配","处理器","hhp","所示","应用","bpu","、","就","基于","开发者","管理","部署","易用","人工","ros2","实现","理器","关于","过程","开发","系统","dnn","接口","我们","，","描述","地平线","使用","不用","具体","二次开发","算力","后续","了","啦","x3","调教","供","参考","等","大家","解释","引擎","easydnn","模型","逻辑","芯片","简单","流程","通过","进行","解析","在","二次","训练","包括","实际","ai","很多","很快","案例","输出","及","_","也","花费","上","人工智能","会","张图","。","利用","开源","保障","是","结果","处理","的","输入","开发板","借助","为","和","这","提供"," ","智能","代码","hobot","库","推理","底层","集成","时间","地平","中","内存","众多","这套"],"title":"Hobot DNN模型推理库","title_tokens":["库"," ","推理","模型","dnn","hobot"]},{"location":"hhp/5.3_%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E6%A1%86%E6%9E%B6/#_2","text":"在Hobot DNN模型推理库的基础上，地平线还提供了一套基于TogetherROS系统的AI算法包，称为BOXs，这样我们就不需要从零构建算法，基于这些标准而高效的算法，可以更关注应用层面的APP开发。 从这张图中我们可以看到，这套AI算法包中包含两大块，一个是基础算法，一个是应用算法。 基础算法中主要是图像分类、语义分割和目标检测这些常用的算法，应用层面就会基于这些算法和某些场景，动态实现更为复杂的人体识别、骨骼点识别、手势识别等具体的功能，这些模块就可以和机器人运功功能直接结合，节省了我们开发AI视觉部分的时间。","text_tokens":["主要","这样","复杂","节省","可以","基础","功能","一套","更","动态","分类","应用","、","就","模块","结合","基于","包中","这些","高效","机器","大块","场景","实现","两大块","分割","开发","系统","还","dnn","称为","机器人","我们","人体","，","地平线","直接","具体","视觉","了","骨骼","等","零","模型","标准","部分","运功","识别","在","从","需要","ai","检测","togetherros","算法","图像","手势","一个","上","层面","会","目标","张图","包","。","而","是","boxs","的","构建","和","常用","这","提供","语义"," ","app","看到","不","hobot","库","包含","某些","推理","更为","时间","关注","地平","中","点","这套"],"title":"算法与应用库","title_tokens":["库","算法","与","应用"]},{"location":"hhp/5.3_%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E6%A1%86%E6%9E%B6/#_3","text":"这套模型推理和算法库的效果如何呢？ 我们先来体验一个HHP自带的案例，识别这张图片中的人，以及每个人的骨骼关键点。 # 配置TogetherROS环境 $ source /opt/tros/setup.bash # 从tros的安装路径中拷贝出运行示例需要的配置文件。config中为example使用的模型，回灌使用的本地图片 $ cp -r /opt/tros/lib/dnn_node_example/config/ . # 使用本地jpg格式图片通过同步模式进行回环预测，并存储渲染后的图片 $ ros2 launch dnn_node_example hobot_dnn_node_example_feedback.launch.py","text_tokens":["图片","模式","py","node","关键","环境","这张","以及","？","setup","同步","hhp","source","体验","后","先","feedback","launch","存储","拷贝","配置文件","ros2","dnn","渲染","示例","我们","每个","，","tros","使用","路径","中为",".","呢","骨骼","预测","config","jpg","并","出","模型","格式","r","通过","#","文件","识别","进行","人","从","运行","安装","需要","togetherros","案例","算法","-","配置","_","一个","。","lib","example","自带","opt","bash","的","来","和"," ","本地","如何","效果","hobot","库","推理","$","cp","中","回灌","关键点","/","这套","回环"],"title":"模型推理测试","title_tokens":["测试","模型","推理"]},{"location":"hhp/5.4_%E5%9B%BE%E5%83%8F%E7%89%A9%E4%BD%93%E5%88%86%E7%B1%BB/","text":"图像物体分类 接下来我们继续学习基于Hobot CNN模型推理库之上的视觉应用。 机器人要感知周边环境，那就得确定看到的图像中都有什么，比如地上有一只猫，旁边有一个桌子之类的，这个猫和桌子就是具体的物体分类啦。 图像分类原理 如果是人来识别一只猫的话，似乎再简单不过了，无论黑猫、白猫还是花猫，我们一眼就可以看出来。 不过这件事对于机器人来讲可没有那么简单，为了能够让机器准确识别一只猫，无数学者可是研究了几十年啊，虽然还赶不上人类的智慧，但是这件事已经没有那么遥不可及了。 比如说我们要让机器识别图像中有一只猫，我们就得先教会机器什么是猫，对此我们就得把各种各样猫的照片给计算机看，目的就是让机器学习，看的越多，识别的也就越准。 我们那里找这么多猫的图片呢？ 大家可能听说过一个著名的视觉对象数据库——ImageNet，里边有超过1400万张标注过的图像，2万多个类别，我们就可以利用这个庞大的数据库，找到很多猫的照片。 然后就搭建神经网络，把这些数据放进去训练了，调教出一套比较好的识别模型。 接下来把这套模型部署到机器人上，之后每当有一幅图像收到之后，就传到这个模型中，也就是模型推理，推理的结果就是类似这样的数据，概率最大的，也就是机器识别到的物体啦。 关于机器学习，理论众多，大家可以学习专门的课程，我们课上还是重点讲解在HHP中的实现方法。 编程开发方法 我们来看这样一张图片，大家很快就可以发现这是一只斑马。 运行示例程序 我们如何用机器来识别它呢，大家先来运行这个案例，这是基于ImageNet数据集训练的模型，可以识别1000种常见的物体，我们看一下效果如何？ $ cd /app/ai_inference/01_basic_sample/ $ sudo python3 ./test_mobilenetv1.py 代码解析 test_mobilenetv1.py： #!/usr/bin/env python3 from hobot_dnn import pyeasy_dnn as dnn import numpy as np import cv2 def bgr2nv12_opencv ( image ): height , width = image . shape [ 0 ], image . shape [ 1 ] area = height * width yuv420p = cv2 . cvtColor ( image , cv2 . COLOR_BGR2YUV_I420 ) . reshape (( area * 3 // 2 ,)) y = yuv420p [: area ] uv_planar = yuv420p [ area :] . reshape (( 2 , area // 4 )) uv_packed = uv_planar . transpose (( 1 , 0 )) . reshape (( area // 2 ,)) nv12 = np . zeros_like ( yuv420p ) nv12 [: height * width ] = y nv12 [ height * width :] = uv_packed return nv12 def print_properties ( pro ): print ( \"tensor type:\" , pro . tensor_type ) print ( \"data type:\" , pro . dtype ) print ( \"layout:\" , pro . layout ) print ( \"shape:\" , pro . shape ) def get_hw ( pro ): if pro . layout == \"NCHW\" : return pro . shape [ 2 ], pro . shape [ 3 ] else : return pro . shape [ 1 ], pro . shape [ 2 ] if __name__ == '__main__' : # test classification result models = dnn . load ( '../models/mobilenetv1_224x224_nv12.bin' ) # test input and output properties print ( \"=\" * 10 , \"inputs[0] properties\" , \"=\" * 10 ) print_properties ( models [ 0 ] . inputs [ 0 ] . properties ) print ( \"inputs[0] name is:\" , models [ 0 ] . inputs [ 0 ] . name ) print ( \"=\" * 10 , \"outputs[0] properties\" , \"=\" * 10 ) print_properties ( models [ 0 ] . outputs [ 0 ] . properties ) print ( \"outputs[0] name is:\" , models [ 0 ] . outputs [ 0 ] . name ) # 打开图片 img_file = cv2 . imread ( './zebra_cls.jpg' ) # 把图片缩放到模型的输入尺寸 # 获取算法模型的输入tensor 的尺寸 h , w = get_hw ( models [ 0 ] . inputs [ 0 ] . properties ) des_dim = ( w , h ) resized_data = cv2 . resize ( img_file , des_dim , interpolation = cv2 . INTER_AREA ) nv12_data = bgr2nv12_opencv ( resized_data ) # 模型推理 outputs = models [ 0 ] . forward ( nv12_data ) print ( \"=\" * 10 , \"Get output[0] numpy data\" , \"=\" * 10 ) print ( \"output[0] buffer numpy info: \" ) print ( \"shape: \" , outputs [ 0 ] . buffer . shape ) print ( \"dtype: \" , outputs [ 0 ] . buffer . dtype ) # print(\"First 10 results:\", outputs[0].buffer[0][:10]) # 从输出结果中得到值最大的那个序号，比如 zebra 就是第 340 个值，应该大于 0.99 print ( \"=\" * 10 , \"Classification result\" , \"=\" * 10 ) assert np . argmax ( outputs [ 0 ] . buffer ) == 340 # 输出类别序号和预测概率值 print ( \"cls id: %d Confidence: %f \" % ( np . argmax ( outputs [ 0 ] . buffer ), outputs [ 0 ] . buffer [ 0 ][ np . argmax ( outputs [ 0 ] . buffer )])) Mobilenetv2物体分类 用图片进行识别不太过瘾，毕竟是静态的图像，没问题，TogetherROS中还提供了实时物体分类的案例，我们继续来体验一下。 为了实时显示视觉识别的效果，这里我们需要启动TogetherROS中的一个web服务器，它会把视觉识别的实时效果，通过网络传输出来，我们直接在浏览器中就可以看到结果啦。也是便于我们开发调试的一个重要工具。 # 启动webserver服务 $ cd /opt/tros/lib/websocket/webservice/ $ chmod +x ./sbin/nginx && ./sbin/nginx -p . 运行例程： $ source /opt/tros/setup.bash $ cp -r /opt/tros/lib/dnn_node_example/config/ . $ cp -r /opt/tros/lib/dnn_benchmark_example/config/runtime/ ./config/ $ ros2 launch /opt/tros/share/dnn_node_example/launch/hobot_dnn_node_example.launch.py config_file: = config/mobilenetv2workconfig.json image_width: = 480 image_height: = 272 在浏览器中登录192.168.1.10，就可以看到分类效果啦：","text_tokens":["x","务器","各样","340","py","可","打开","output","一下","计算机","好","应用","就","神经网络","id","%","websocket","便于","对此","机器","就是","算机","numpy","这件","什么","实现","10","1.10","dtype","env","from","zeros","buffer","first","不过","重要","cnn",".","info","课程","bgr2yuv","config","浏览","斑马","找到","简单","np","通过","#","进行","发现","从","as","之后","没有","需要","tensor","togetherros","很多","很快","outputs","各种各样","算法","-","几十年","还是","看","一只","mobilenetv2","1000","啊","if","。","出来","利用","zebra","example","224x224","讲解",")","yuv420p","opt","为了","bash","hw","调试","方法","如何","h","确定","—","代码","hobot","专门","mobilenetv1","它会","几十","resized","0","480","transpose","argmax","继续","传输","这套","web","对于","01","input","node","事","一套","环境","再","？","都","工具","分类","source","的话","先","y","launch","基于","这些","'","关于","可能","理论","开发","..","interpolation","nginx","但是","color","找","实时","无论","下来","标注","网络","tros","第","程序","物体","这是","地上","值","呢","resize","就可以看","d","大于","inputs","数据库","python3","课上","那","之类","花猫","那里","在","研究","周边","bin","webservice","输出","接下","_","得到","image","一个","上","nv12","过瘾","集","confidence","result","计算","reshape","能够","人类","越准","runtime","*","人来","是","类别","智慧","cd","uv","提供","可是","app","教会","pyeasy","这个","对象","!","启动","序号","多个","nchw","多","=","常见","已经","进去","多猫","浏览器","神经网","sudo","放进去","opencv","猫","/","缩","inter","name","著名","2","可以","i420","classification","like","&&","]",":","\"","layout","setup","体验","、","类似","benchmark","properties","cv2","神经","它","收到","部署","area","放到","十年","ros2","一眼","chmod","imread","机器人","应该","，","遥不可及","然后","height","dim","直接","__","具体","学习","视觉","传到","(","旁边","imagenet","planar","啦","调教","比如","and","预测","目的","模型","黑猫","登录","test","问题","r","识别","训练","运行","img","案例","assert","图像","开发方法","每当","也","basic","bgr2nv12","：","的","输入","+","和","有"," ","那么","3","桌子","概率","重点","搭建","种","sbin","推理","$","静态","各种","cp","不可","最大","中","results","众多","放进","把","如果","图片","例程","w","这样","感知","数据","不太","似乎","import","编程","庞大","1","hhp","一幅","让","p","4","width","服务器","得","还","dnn","packed","示例","我们","学者","没","is","无数","main","赶不上","这里","了","f","272","照片","越","大家","jpg","比较","return","出","万多个","pro","sample","到","接下来","这么","usr","之上","听说","解析","周边环境","比如说","个值",",","load","ai","type","虽然","万多","中有","inference","里边","0.99","那个","给","forward","des","来看","shape","models","一张","lib","192.168","超过","webserver","else","mobilenetv2workconfig","结果","print","1400","毕竟","用","来","过","share","白猫","准确","服务","看到","尺寸","效果","要","万张","获取","库","data","据库","cls","json","cvtcolor","原理","来讲","显示","file","get","[","def"],"title":"图像物体分类","title_tokens":["图像","物体","分类"]},{"location":"hhp/5.4_%E5%9B%BE%E5%83%8F%E7%89%A9%E4%BD%93%E5%88%86%E7%B1%BB/#_1","text":"接下来我们继续学习基于Hobot CNN模型推理库之上的视觉应用。 机器人要感知周边环境，那就得确定看到的图像中都有什么，比如地上有一只猫，旁边有一个桌子之类的，这个猫和桌子就是具体的物体分类啦。","text_tokens":["机器人","我们","那","感知","之类","的","接下来","，","下来","之上","环境","周边环境","和","具体","有","学习","视觉"," ","桌子","都","物体","分类","地上","看到","这个","周边","cnn","应用","猫","确定","图像","要","hobot","旁边","就","啦","库","接下","基于","推理","比如","一个","一只","机器","就是","。","中","什么","得","继续","模型"],"title":"图像物体分类","title_tokens":["图像","物体","分类"]},{"location":"hhp/5.4_%E5%9B%BE%E5%83%8F%E7%89%A9%E4%BD%93%E5%88%86%E7%B1%BB/#_2","text":"如果是人来识别一只猫的话，似乎再简单不过了，无论黑猫、白猫还是花猫，我们一眼就可以看出来。 不过这件事对于机器人来讲可没有那么简单，为了能够让机器准确识别一只猫，无数学者可是研究了几十年啊，虽然还赶不上人类的智慧，但是这件事已经没有那么遥不可及了。 比如说我们要让机器识别图像中有一只猫，我们就得先教会机器什么是猫，对此我们就得把各种各样猫的照片给计算机看，目的就是让机器学习，看的越多，识别的也就越准。 我们那里找这么多猫的图片呢？ 大家可能听说过一个著名的视觉对象数据库——ImageNet，里边有超过1400万张标注过的图像，2万多个类别，我们就可以利用这个庞大的数据库，找到很多猫的照片。 然后就搭建神经网络，把这些数据放进去训练了，调教出一套比较好的识别模型。 接下来把这套模型部署到机器人上，之后每当有一幅图像收到之后，就传到这个模型中，也就是模型推理，推理的结果就是类似这样的数据，概率最大的，也就是机器识别到的物体啦。 关于机器学习，理论众多，大家可以学习专门的课程，我们课上还是重点讲解在HHP中的实现方法。","text_tokens":["如果","图片","各样","著名","2","放进","对于","这样","可以","可","数据","似乎","事","一套","再","计算机","？","庞大","好","hhp","的话","、","先","类似","就","神经网络","这些","一幅","对此","神经","让","收到","部署","机器","就是","算机","十年","这件","什么","一眼","关于","实现","得","可能","理论","还","机器人","但是","我们","学者","，","找","无论","遥不可及","标注","下来","网络","然后","无数","不过","赶不上","学习","视觉","物体","传到","呢","了","imagenet","课程","就可以看","啦","调教","比如","照片","越","大家","目的","比较","数据库","找到","出","模型","万多个","课上","黑猫","简单","到","这么","花猫","接下来","识别","听说","那里","在","训练","比如说","之后","没有","研究","很多","各种各样","虽然","图像","中有","万多","几十年","里边","每当","接下","也","给","还是","一个","看","一只","上","啊","计算","。","出来","利用","能够","超过","人类","越准","讲解","人来","为了","是","结果","类别","1400","智慧","的","过","有","方法","可是","白猫"," ","那么","准确","概率","教会","重点","这个","对象","搭建","—","要","万张","多个","专门","据库","推理","几十","多","各种","已经","进去","来讲","多猫","神经网","不可","最大","中","放进去","众多","猫","这套","把"],"title":"图像分类原理","title_tokens":["图像","原理","分类"]},{"location":"hhp/5.4_%E5%9B%BE%E5%83%8F%E7%89%A9%E4%BD%93%E5%88%86%E7%B1%BB/#_3","text":"我们来看这样一张图片，大家很快就可以发现这是一只斑马。","text_tokens":["图片","一只","。","我们","这样","可以","这是","，","来看","很快","斑马","大家","发现","就","一张"],"title":"编程开发方法","title_tokens":["编程","开发方法","方法","开发"]},{"location":"hhp/5.4_%E5%9B%BE%E5%83%8F%E7%89%A9%E4%BD%93%E5%88%86%E7%B1%BB/#_4","text":"我们如何用机器来识别它呢，大家先来运行这个案例，这是基于ImageNet数据集训练的模型，可以识别1000种常见的物体，我们看一下效果如何？ $ cd /app/ai_inference/01_basic_sample/ $ sudo python3 ./test_mobilenetv1.py","text_tokens":["/","我们","test","py","可以","cd","01","用","，","数据","的","来","sample","识别","训练","运行"," ","一下","app","？","这是","物体","ai","如何","这个","案例",".","种","先","呢","效果","inference","imagenet","基于","_","$","mobilenetv1","它","常见","大家","看","集","机器","1000","basic","sudo","python3","模型"],"title":"运行示例程序","title_tokens":["示例","程序","运行"]},{"location":"hhp/5.4_%E5%9B%BE%E5%83%8F%E7%89%A9%E4%BD%93%E5%88%86%E7%B1%BB/#_5","text":"test_mobilenetv1.py： #!/usr/bin/env python3 from hobot_dnn import pyeasy_dnn as dnn import numpy as np import cv2 def bgr2nv12_opencv ( image ): height , width = image . shape [ 0 ], image . shape [ 1 ] area = height * width yuv420p = cv2 . cvtColor ( image , cv2 . COLOR_BGR2YUV_I420 ) . reshape (( area * 3 // 2 ,)) y = yuv420p [: area ] uv_planar = yuv420p [ area :] . reshape (( 2 , area // 4 )) uv_packed = uv_planar . transpose (( 1 , 0 )) . reshape (( area // 2 ,)) nv12 = np . zeros_like ( yuv420p ) nv12 [: height * width ] = y nv12 [ height * width :] = uv_packed return nv12 def print_properties ( pro ): print ( \"tensor type:\" , pro . tensor_type ) print ( \"data type:\" , pro . dtype ) print ( \"layout:\" , pro . layout ) print ( \"shape:\" , pro . shape ) def get_hw ( pro ): if pro . layout == \"NCHW\" : return pro . shape [ 2 ], pro . shape [ 3 ] else : return pro . shape [ 1 ], pro . shape [ 2 ] if __name__ == '__main__' : # test classification result models = dnn . load ( '../models/mobilenetv1_224x224_nv12.bin' ) # test input and output properties print ( \"=\" * 10 , \"inputs[0] properties\" , \"=\" * 10 ) print_properties ( models [ 0 ] . inputs [ 0 ] . properties ) print ( \"inputs[0] name is:\" , models [ 0 ] . inputs [ 0 ] . name ) print ( \"=\" * 10 , \"outputs[0] properties\" , \"=\" * 10 ) print_properties ( models [ 0 ] . outputs [ 0 ] . properties ) print ( \"outputs[0] name is:\" , models [ 0 ] . outputs [ 0 ] . name ) # 打开图片 img_file = cv2 . imread ( './zebra_cls.jpg' ) # 把图片缩放到模型的输入尺寸 # 获取算法模型的输入tensor 的尺寸 h , w = get_hw ( models [ 0 ] . inputs [ 0 ] . properties ) des_dim = ( w , h ) resized_data = cv2 . resize ( img_file , des_dim , interpolation = cv2 . INTER_AREA ) nv12_data = bgr2nv12_opencv ( resized_data ) # 模型推理 outputs = models [ 0 ] . forward ( nv12_data ) print ( \"=\" * 10 , \"Get output[0] numpy data\" , \"=\" * 10 ) print ( \"output[0] buffer numpy info: \" ) print ( \"shape: \" , outputs [ 0 ] . buffer . shape ) print ( \"dtype: \" , outputs [ 0 ] . buffer . dtype ) # print(\"First 10 results:\", outputs[0].buffer[0][:10]) # 从输出结果中得到值最大的那个序号，比如 zebra 就是第 340 个值，应该大于 0.99 print ( \"=\" * 10 , \"Classification result\" , \"=\" * 10 ) assert np . argmax ( outputs [ 0 ] . buffer ) == 340 # 输出类别序号和预测概率值 print ( \"cls id: %d Confidence: %f \" % ( np . argmax ( outputs [ 0 ] . buffer ), outputs [ 0 ] . buffer [ 0 ][ np . argmax ( outputs [ 0 ] . buffer )]))","text_tokens":["图片","2","340","w","py","input","打开","i420","classification","import","like","]",":","output","1","\"","layout","y","inter","id","%","properties","cv2","area","放到","'","就是","4","width","numpy","10","dtype","..","env","dnn","imread","packed","interpolation","from","应该","color","zeros","，","is","buffer","height","dim","first","__","main","第","值",".","(","f","planar","resize","info","bgr2yuv","d","and","比如","预测","大于","inputs","jpg","return","python3","模型","pro","test","usr","np","#","从","as","个值",",","load","tensor","img","bin","outputs","type","assert","算法","输出","0.99","_","那个","得到","image","forward","des","shape","models","nv12","confidence","result","bgr2nv12","reshape","if","zebra","224x224",")","*","else","yuv420p","结果","类别","print","：","hw","的","输入","uv","和"," ","3","概率","pyeasy","尺寸","!","h","hobot","获取","data","序号","推理","mobilenetv1","nchw","cls","=","cvtcolor","把","resized","0","最大","中","transpose","file","opencv","results","argmax","get","/","缩","[","def","name"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"hhp/5.4_%E5%9B%BE%E5%83%8F%E7%89%A9%E4%BD%93%E5%88%86%E7%B1%BB/#mobilenetv2","text":"用图片进行识别不太过瘾，毕竟是静态的图像，没问题，TogetherROS中还提供了实时物体分类的案例，我们继续来体验一下。 为了实时显示视觉识别的效果，这里我们需要启动TogetherROS中的一个web服务器，它会把视觉识别的实时效果，通过网络传输出来，我们直接在浏览器中就可以看到结果啦。也是便于我们开发调试的一个重要工具。 # 启动webserver服务 $ cd /opt/tros/lib/websocket/webservice/ $ chmod +x ./sbin/nginx && ./sbin/nginx -p . 运行例程： $ source /opt/tros/setup.bash $ cp -r /opt/tros/lib/dnn_node_example/config/ . $ cp -r /opt/tros/lib/dnn_benchmark_example/config/runtime/ ./config/ $ ros2 launch /opt/tros/share/dnn_node_example/launch/hobot_dnn_node_example.launch.py config_file: = config/mobilenetv2workconfig.json image_width: = 480 image_height: = 272 在浏览器中登录192.168.1.10，就可以看到分类效果啦：","text_tokens":["x","图片","务器","例程","py","可以","node","不太","&&",":","一下","工具","分类","setup","source","体验","就","benchmark","launch","websocket","便于","p","服务器","width","ros2","1.10","开发","还","dnn","chmod","nginx","我们","没","，","实时","网络","tros","直接","height","重要","视觉","物体","这里",".","了","啦","272","config","浏览","登录","问题","r","通过","#","识别","进行","在","运行","需要","togetherros","案例","webservice","图像","-","也","_","image","一个","过瘾","。","出来","lib","192.168","example","webserver","runtime","mobilenetv2workconfig","opt","为了","是","结果","：","毕竟","bash","cd","用","的","调试","来","+","提供","share"," ","服务","看到","启动","效果","hobot","sbin","静态","它会","$","=","json","cp","显示","浏览器","中","480","file","继续","传输","/","把","web"],"title":"Mobilenetv2物体分类","title_tokens":["mobilenetv2","物体","分类"]},{"location":"hhp/5.5_%E5%8A%A8%E6%80%81%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/","text":"动态目标检测 图像物体分类重在分析图像中存在的物体是什么，便于机器理解看到的环境信息，另外一种场景，机器不仅要识别某一物体，还要知道这个物体所在的位置，当物体在运动时，更要快速连续的跟踪，这就是目标检测，重在分析识别到物体在图像中的位置。 目标检测原理 假设我们要识别图像中这只狗的位置，以最为常用的YOLO算法为例，它会运用单个卷积神经网络(CNN) ，将图像分成网格，并预测每个网格的对象概率和边界框。 比如，对于这个图像，Yolo的CNN网络将输入的图片分割成7x7的网格，然后每个网格负责去检测那些中心点落在该格子内的目标，比如，小狗这个目标的中心点在左下角的网格中，那该网格就负责预测狗这个对象。 每个网格中将有多个边界框，在训练时，我们希望每个对象只有一个边界框，比如最终只有一个边界框把这只狗包起来。因此，我们根据哪个边界框与之前标注的重叠度最高，预测对象的位置和概率。 最终包围对象的边界框，就是识别的结果，使用四个描述符进行说明： 边界框的中心位置 边界框的高度 边界框的宽度 识别到对象所属的类 这样就完成了对目标的实时检测，拿到目标的信息之后，就可以进行后续的机器人行为控制了。 我们对目标检测系统运行速度的要求一般都比较高，可以实时处理视频流，比如车辆行驶的动态监测、自然环境中的目标识别，有着非常广泛的应用价值。 回到TogetherROS和旭日X3派的开发板，我们来看下这套软硬件结合的目标检测系统，效率如何。 MIPI相机目标检测 接下来，我们要利用MIPI相机，动态识别图像中各种各样的物体以及他们所在的位置，推理过程使用的是基于COCO数据集训练的80个类别，也就是可以识别80种常用的物体位置。 运行例程 $ cd /app/ai_inference/03_mipi_camera_sample/ $ python3 ./mipi_camera.py 代码解析 mipi_camera.py： #!/usr/bin/env python3 import numpy as np import cv2 import colorsys # Camera API libs from hobot_vio import libsrcampy as srcampy from hobot_dnn import pyeasy_dnn as dnn # detection model class names def get_classes (): return np . array ([ \"person\" , \"bicycle\" , \"car\" , \"motorcycle\" , \"airplane\" , \"bus\" , \"train\" , \"truck\" , \"boat\" , \"traffic light\" , \"fire hydrant\" , \"stop sign\" , \"parking meter\" , \"bench\" , \"bird\" , \"cat\" , \"dog\" , \"horse\" , \"sheep\" , \"cow\" , \"elephant\" , \"bear\" , \"zebra\" , \"giraffe\" , \"backpack\" , \"umbrella\" , \"handbag\" , \"tie\" , \"suitcase\" , \"frisbee\" , \"skis\" , \"snowboard\" , \"sports ball\" , \"kite\" , \"baseball bat\" , \"baseball glove\" , \"skateboard\" , \"surfboard\" , \"tennis racket\" , \"bottle\" , \"wine glass\" , \"cup\" , \"fork\" , \"knife\" , \"spoon\" , \"bowl\" , \"banana\" , \"apple\" , \"sandwich\" , \"orange\" , \"broccoli\" , \"carrot\" , \"hot dog\" , \"pizza\" , \"donut\" , \"cake\" , \"chair\" , \"couch\" , \"potted plant\" , \"bed\" , \"dining table\" , \"toilet\" , \"tv\" , \"laptop\" , \"mouse\" , \"remote\" , \"keyboard\" , \"cell phone\" , \"microwave\" , \"oven\" , \"toaster\" , \"sink\" , \"refrigerator\" , \"book\" , \"clock\" , \"vase\" , \"scissors\" , \"teddy bear\" , \"hair drier\" , \"toothbrush\" ]) def bgr2nv12_opencv ( image ): height , width = image . shape [ 0 ], image . shape [ 1 ] area = height * width yuv420p = cv2 . cvtColor ( image , cv2 . COLOR_RGB2YUV_I420 ) . reshape (( area * 3 // 2 ,)) y = yuv420p [: area ] uv_planar = yuv420p [ area :] . reshape (( 2 , area // 4 )) uv_packed = uv_planar . transpose (( 1 , 0 )) . reshape (( area // 2 ,)) nv12 = np . zeros_like ( yuv420p ) nv12 [: height * width ] = y nv12 [ height * width :] = uv_packed return nv12 def get_hw ( pro ): if pro . layout == \"NCHW\" : return pro . shape [ 2 ], pro . shape [ 3 ] else : return pro . shape [ 1 ], pro . shape [ 2 ] def postprocess ( model_output , model_hw_shape , origin_image = None , origin_img_shape = None , score_threshold = 0.5 , nms_threshold = 0.6 , dump_image = False ): input_height = model_hw_shape [ 0 ] input_width = model_hw_shape [ 1 ] if origin_image is not None : origin_image_shape = origin_image . shape [ 0 : 2 ] else : origin_image_shape = origin_img_shape prediction_bbox = decode ( outputs = model_output , score_threshold = score_threshold , origin_shape = origin_image_shape , input_size = 512 ) prediction_bbox = nms ( prediction_bbox , iou_threshold = nms_threshold ) prediction_bbox = np . array ( prediction_bbox ) topk = min ( prediction_bbox . shape [ 0 ], 1000 ) if topk != 0 : idx = np . argpartition ( prediction_bbox [ ... , 4 ], - topk )[ - topk :] prediction_bbox = prediction_bbox [ idx ] if dump_image and origin_image is not None : draw_bboxs ( origin_image , prediction_bbox ) return prediction_bbox def draw_bboxs ( image , bboxes , gt_classes_index = None , classes = get_classes ()): \"\"\"draw the bboxes in the original image \"\"\" num_classes = len ( classes ) image_h , image_w , channel = image . shape hsv_tuples = [( 1.0 * x / num_classes , 1. , 1. ) for x in range ( num_classes )] colors = list ( map ( lambda x : colorsys . hsv_to_rgb ( * x ), hsv_tuples )) colors = list ( map ( lambda x : ( int ( x [ 0 ] * 255 ), int ( x [ 1 ] * 255 ), int ( x [ 2 ] * 255 )), colors )) fontScale = 0.5 bbox_thick = int ( 0.6 * ( image_h + image_w ) / 600 ) for i , bbox in enumerate ( bboxes ): coor = np . array ( bbox [: 4 ], dtype = np . int32 ) if gt_classes_index == None : class_index = int ( bbox [ 5 ]) score = bbox [ 4 ] else : class_index = gt_classes_index [ i ] score = 1 bbox_color = colors [ class_index ] c1 , c2 = ( coor [ 0 ], coor [ 1 ]), ( coor [ 2 ], coor [ 3 ]) cv2 . rectangle ( image , c1 , c2 , bbox_color , bbox_thick ) classes_name = classes [ class_index ] bbox_mess = ' %s : %.2f ' % ( classes_name , score ) t_size = cv2 . getTextSize ( bbox_mess , 0 , fontScale , thickness = bbox_thick // 2 )[ 0 ] cv2 . rectangle ( image , c1 , ( c1 [ 0 ] + t_size [ 0 ], c1 [ 1 ] - t_size [ 1 ] - 3 ), bbox_color , - 1 ) cv2 . putText ( image , bbox_mess , ( c1 [ 0 ], c1 [ 1 ] - 2 ), cv2 . FONT_HERSHEY_SIMPLEX , fontScale , ( 0 , 0 , 0 ), bbox_thick // 2 , lineType = cv2 . LINE_AA ) print ( \" {} is in the picture with confidence: {:.4f} , bbox: {} \" . format ( classes_name , score , coor )) # cv2.imwrite(\"demo.jpg\", image) return image def decode ( outputs , score_threshold , origin_shape , input_size = 512 ): def _distance2bbox ( points , distance ): x1 = points [ ... , 0 ] - distance [ ... , 0 ] y1 = points [ ... , 1 ] - distance [ ... , 1 ] x2 = points [ ... , 0 ] + distance [ ... , 2 ] y2 = points [ ... , 1 ] + distance [ ... , 3 ] return np . stack ([ x1 , y1 , x2 , y2 ], - 1 ) def _scores ( cls , ce ): cls = 1 / ( 1 + np . exp ( - cls )) ce = 1 / ( 1 + np . exp ( - ce )) return np . sqrt ( ce * cls ) def _bbox ( bbox , stride , origin_shape , input_size ): h , w = bbox . shape [ 1 : 3 ] yv , xv = np . meshgrid ( np . arange ( h ), np . arange ( w )) xy = ( np . stack (( yv , xv ), 2 ) + 0.5 ) * stride bbox = _distance2bbox ( xy , bbox ) # opencv read, shape[1] is w, shape[0] is h scale_w = origin_shape [ 1 ] / input_size scale_h = origin_shape [ 0 ] / input_size scale = max ( origin_shape [ 0 ], origin_shape [ 1 ]) / input_size # origin img is pad resized #bbox = bbox * scale # origin img is resized bbox = bbox * [ scale_w , scale_h , scale_w , scale_h ] return bbox bboxes = list () strides = [ 8 , 16 , 32 , 64 , 128 ] for i in range ( len ( strides )): cls = outputs [ i ] . buffer bbox = outputs [ i + 5 ] . buffer ce = outputs [ i + 10 ] . buffer scores = _scores ( cls , ce ) classes = np . argmax ( scores , axis =- 1 ) classes = np . reshape ( classes , [ - 1 , 1 ]) max_score = np . max ( scores , axis =- 1 ) max_score = np . reshape ( max_score , [ - 1 , 1 ]) bbox = _bbox ( bbox , strides [ i ], origin_shape , input_size ) bbox = np . reshape ( bbox , [ - 1 , 4 ]) pred_bbox = np . concatenate ([ bbox , max_score , classes ], axis = 1 ) index = pred_bbox [ ... , 4 ] > score_threshold pred_bbox = pred_bbox [ index ] bboxes . append ( pred_bbox ) return np . concatenate ( bboxes ) def nms ( bboxes , iou_threshold , sigma = 0.3 , method = 'nms' ): def bboxes_iou ( boxes1 , boxes2 ): boxes1 = np . array ( boxes1 ) boxes2 = np . array ( boxes2 ) boxes1_area = ( boxes1 [ ... , 2 ] - boxes1 [ ... , 0 ]) * \\ ( boxes1 [ ... , 3 ] - boxes1 [ ... , 1 ]) boxes2_area = ( boxes2 [ ... , 2 ] - boxes2 [ ... , 0 ]) * \\ ( boxes2 [ ... , 3 ] - boxes2 [ ... , 1 ]) left_up = np . maximum ( boxes1 [ ... , : 2 ], boxes2 [ ... , : 2 ]) right_down = np . minimum ( boxes1 [ ... , 2 :], boxes2 [ ... , 2 :]) inter_section = np . maximum ( right_down - left_up , 0.0 ) inter_area = inter_section [ ... , 0 ] * inter_section [ ... , 1 ] union_area = boxes1_area + boxes2_area - inter_area ious = np . maximum ( 1.0 * inter_area / union_area , np . finfo ( np . float32 ) . eps ) return ious classes_in_img = list ( set ( bboxes [:, 5 ])) best_bboxes = [] for cls in classes_in_img : cls_mask = ( bboxes [:, 5 ] == cls ) cls_bboxes = bboxes [ cls_mask ] while len ( cls_bboxes ) > 0 : max_ind = np . argmax ( cls_bboxes [:, 4 ]) best_bbox = cls_bboxes [ max_ind ] best_bboxes . append ( best_bbox ) cls_bboxes = np . concatenate ( [ cls_bboxes [: max_ind ], cls_bboxes [ max_ind + 1 :]]) iou = bboxes_iou ( best_bbox [ np . newaxis , : 4 ], cls_bboxes [:, : 4 ]) weight = np . ones (( len ( iou ),), dtype = np . float32 ) assert method in [ 'nms' , 'soft-nms' ] if method == 'nms' : iou_mask = iou > iou_threshold weight [ iou_mask ] = 0.0 if method == 'soft-nms' : weight = np . exp ( - ( 1.0 * iou ** 2 / sigma )) cls_bboxes [:, 4 ] = cls_bboxes [:, 4 ] * weight score_mask = cls_bboxes [:, 4 ] > 0. cls_bboxes = cls_bboxes [ score_mask ] return best_bboxes def print_properties ( pro ): print ( \"tensor type:\" , pro . tensor_type ) print ( \"data type:\" , pro . dtype ) print ( \"layout:\" , pro . layout ) print ( \"shape:\" , pro . shape ) if __name__ == '__main__' : models = dnn . load ( '../models/fcos_512x512_nv12.bin' ) # 打印输入 tensor 的属性 print_properties ( models [ 0 ] . inputs [ 0 ] . properties ) # 打印输出 tensor 的属性 print ( len ( models [ 0 ] . outputs )) for output in models [ 0 ] . outputs : print_properties ( output . properties ) # 获取 Camera 句柄 cam = srcampy . Camera () # 打开 f37 摄像头，并且把输出突出缩小成算法模型的输入尺寸 h , w = get_hw ( models [ 0 ] . inputs [ 0 ] . properties ) # 打开 F37, 初始化视频 pipeline 0 ，设置帧率30fps，缩放图像为 512 x 512 cam . open_cam ( 0 , 1 , 30 , w , h ) # Get HDMI display object disp = srcampy . Display () # For the meaning of parameters, please refer to the relevant documents of HDMI display disp . display ( 0 , 1920 , 1080 ) input_shape = ( h , w ) while True : # 从相机获取分辨率为 512x512 的nv12格式的图像数据， 参数 2 代表从硬件模块IPU中获取 img = cam . get_img ( 2 , 512 , 512 ) # 把图像数据转成 numpy 数据类型 img = np . frombuffer ( img , dtype = np . uint8 ) # 模型推理 outputs = models [ 0 ] . forward ( img ) # 对算法结果进行过滤，去掉执行度低的检测框，计算检测框的交并比去除冗余框，把检测框的坐标还原到原图位置上 prediction_bbox = postprocess ( outputs , input_shape , origin_img_shape = ( 1080 , 1920 )) # 从新获取一张图像，大小缩放成与显示器的分辨率一样的 1920 x 1080, 并且转换成 bgr格式，方便进行绘图操作 origin_image = cam . get_img ( 2 , 1920 , 1080 ) origin_nv12 = np . frombuffer ( origin_image , dtype = np . uint8 ) . reshape ( 1620 , 1920 ) origin_bgr = cv2 . cvtColor ( origin_nv12 , cv2 . COLOR_YUV420SP2BGR ) # 把算法运行后得到的物体检测框绘制到图像上 box_bgr = draw_bboxs ( origin_bgr , prediction_bbox ) # X3 的HDMI输出模块的输入图像格式需要是NV12的，所以需要先把bgr格式转成NV12 box_nv12 = bgr2nv12_opencv ( box_bgr ) # 把 NV12 格式的图像输出给显示器 disp . set_img ( box_nv12 . tobytes ()) cam . close_cam () USB相机目标检测 如果大家手上没有MIPI接口的相机，使用USB相机也可以实现同样的功能。 运行例程 $ cd /app/ai_inference/02_usb_camera_sample/ $ python3 ./usb_camera_fcos.py 动态目标检测 大家如果没有HDMI显示器的话，也没有问题，刚才的例程，也可以这样来运行，我们通过统一网络环境中的浏览器就可以动态看到结果啦。 # 启动webserver服务 $ cd /opt/tros/lib/websocket/webservice/ $ chmod +x ./sbin/nginx && ./sbin/nginx -p . # 运行例程 $ source /opt/tros/setup.bash $ cp -r /opt/tros/lib/dnn_node_example/config/ . $ cp -r /opt/tros/lib/dnn_benchmark_example/config/runtime/ ./config/ $ ros2 launch /opt/tros/share/dnn_node_example/launch/hobot_dnn_node_example.launch.py config_file: = config/fcosworkconfig.json image_width: = 480 image_height: = 272","text_tokens":["x","框","各样","coco","py","hdmi","功能","价值","打开","simplex","handbag","display","right","output","ious","派","backpack","应用","并且","就","神经网络","高度","%","websocket","mask","便于","maximum","train","高","交","horse","srcampy","机器","就是","cake","255","场景","bottle","numpy","方便","什么","10","实现","dtype","env","输出模块","from","threshold","每个","zeros","arange","pipeline","coor","gt","buffer","类型","使用","成","dog","位置","cnn",".","int","y1","该","aa","广泛","f37","根据","config","carrot","浏览","最为","并","另外","original","open","usb","初始","scores","他们","np","换成","#","绘制","通过","exp","进行","enumerate","sink","close","从","as","之后","没有","下","需要","ipu","tensor","togetherros","outputs","算法","各种各样","-","监测","uint8","回到","map","person","速度","那该","最高","去","目标","内","希望","8","meaning","1000","if","。","利用","fire","tennis","512","orange","hershey","zebra","example","bowl",")","method","yuv420p","1920","opt","to","拿到","draw","baseball","宽度","摄像头","处理","hw","bash","chair","iou","四个","min","执行","kite","那些","如何","某一","bus","0.6","h","效率","代码","hobot","cell","max","best","之前","cam","它会","refrigerator","帧","行驶","resized","0","float32","vio","480","理解","transpose","argmax","cow","600","这套","points","newaxis","1.0","union","对于","input","node","box","of","vase","环境","更要","microwave","小成","not","与","都","分类","skateboard","glove","sigma","source","的话","frombuffer","先","names","y","launch","基于","以","64","hydrant","idx","'","tie","len","true","图像格式","score","系统","开发","..","刚才","接口","中将","nginx","bgr","起来","topk","说明","color","实时","标注","下来","网络","下角","tros","class","lambda","donut","包围","物体","32","当","度","x3","卷积","pizza","line","car","inputs","prediction","airplane","please","实时处理","fcos","bbox","python3","tobytes","自然","xv","跟踪","格式","thickness","自然环境","信息","fork","在","转换成","soft","detection","...","硬件","bin","分成","webservice","输出","left","哪个","对","接下","scissors","_","格子","skis","the","5","gettextsize","类","image","yv","eps","转换","得到","一个","存在","上","finfo","nv12","集","confidence","同样","libs","reshape","计算","xy","read","runtime","*","是","打印输出","类别","快速","一种","cd","meshgrid","uv","将","x2","\\","旭日","去掉","这","glass","app","table","分辨","pyeasy","bed","知道","这个","对象","camera","!","laptop","surfboard","启动","yolo","运动","一样","多个","新","bicycle","scale","比","nchw","demo","=","false","sign","代表","puttext","神经网","统一","浏览器","有着","index","过滤","opencv","假设","c2","/","inter","非常","bench","name","up","手上","pred","2","句柄","只","可以","还原","i420","like","&&","动态","以及","]",":","\"","layout","libsrcampy","setup","rgb","后","append","、","benchmark","中心","结合","properties","负责","cv2","神经","area","1080","linetype","摄像","colors","30","重在","ros2","网格","率","chmod","机器人","80","完成","remote","，","大小","api","然后","所在","motorcycle","height","decode","__","racket","axis","运用","broccoli","distance2bbox","(","因此","缩小","planar","02","啦","操作","比如","预测","and","cup","pad","ind","初始化","%.","argpartition","数据类型","model","左下角","行为","parking","hair","in","模型","所以","hot","问题","单个","r","识别","为例","个","postprocess","训练","运行","分辨率","hsv","mess","oven","检测","img","设置","冗余","assert","图像","只有","plant","teddy","array","也","frisbee","sheep","128","7x7","format","banana","包","couch","bgr2nv12","i","狗","小狗","ball","视频流","一般","连续","truck","toilet","section","4f","：","16","的","输入","dining","+","为","常用","和",">","有","突出"," ","概率","3","none","种","stride","03","toaster","boxes2","sbin","bear","t","推理","512x512","$","各种","toothbrush","转成","refer","disp","cp","strides","concatenate","原图","中心点","中","左下","mipi","meter","list","把","边界","软硬件","如果","图片","nms","例程","w","这样","数据","30fps","最终","import","spoon","1","bboxs","font","要求","缩小成","range","模块","bird","分析","distance","所属","打印","车辆","属性","p","控制","4","重叠","width","yuv420sp2bgr","分割","过程","classes","dnn","elephant","packed","s","y2","我们","size","坐标","0.5","documents","is","描述","rectangle","knife","main","object","转","snowboard","视频","sports","sandwich","后续","rgb2yuv","了","辨率","0.3","272","软硬","for","大家","{","jpg","giraffe","umbrella","apple","picture","ce","比较","parameters","keyboard","return","pro","ones","sample","2f","到","接下来","usr","tuples","num","解析","int32","boat",",","sqrt","load","ai","origin","stop","type","inference","低","描述符","set","while","给","tv","forward","去除","来看","不仅","shape","cat","models","一张","显示器","lib","fcosworkconfig","weight","}","像头","fontscale","webserver","else","结果","light","mouse","print","缩放","with","来","bat","开发板","book","imwrite","wine","落","share","colorsys","服务","看到","尺寸","traffic","relevant","要","clock","json","获取","phone","data","时","suitcase","thick","down","c1","cls","drier","boxes1","x1","stack","cvtcolor","原理","参数","还要","dump","0.0","显示","potted","绘图","相机","minimum","1620","file","bboxes","get","channel","[","def"],"title":"动态目标检测","title_tokens":["检测","动态","目标"]},{"location":"hhp/5.5_%E5%8A%A8%E6%80%81%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/#_1","text":"图像物体分类重在分析图像中存在的物体是什么，便于机器理解看到的环境信息，另外一种场景，机器不仅要识别某一物体，还要知道这个物体所在的位置，当物体在运动时，更要快速连续的跟踪，这就是目标检测，重在分析识别到物体在图像中的位置。","text_tokens":["是","跟踪","快速","一种","的","，","到","识别","信息","所在","环境","在","更要","这","位置","物体","分类","检测","看到","知道","某一","这个","当","图像","要","运动","时","分析","便于","存在","不仅","目标","还要","机器","另外","就是","场景","。","重在","中","什么","理解","连续"],"title":"动态目标检测","title_tokens":["检测","动态","目标"]},{"location":"hhp/5.5_%E5%8A%A8%E6%80%81%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/#_2","text":"假设我们要识别图像中这只狗的位置，以最为常用的YOLO算法为例，它会运用单个卷积神经网络(CNN) ，将图像分成网格，并预测每个网格的对象概率和边界框。 比如，对于这个图像，Yolo的CNN网络将输入的图片分割成7x7的网格，然后每个网格负责去检测那些中心点落在该格子内的目标，比如，小狗这个目标的中心点在左下角的网格中，那该网格就负责预测狗这个对象。 每个网格中将有多个边界框，在训练时，我们希望每个对象只有一个边界框，比如最终只有一个边界框把这只狗包起来。因此，我们根据哪个边界框与之前标注的重叠度最高，预测对象的位置和概率。 最终包围对象的边界框，就是识别的结果，使用四个描述符进行说明： 边界框的中心位置 边界框的高度 边界框的宽度 识别到对象所属的类 这样就完成了对目标的实时检测，拿到目标的信息之后，就可以进行后续的机器人行为控制了。 我们对目标检测系统运行速度的要求一般都比较高，可以实时处理视频流，比如车辆行驶的动态监测、自然环境中的目标识别，有着非常广泛的应用价值。 回到TogetherROS和旭日X3派的开发板，我们来看下这套软硬件结合的目标检测系统，效率如何。","text_tokens":["图片","框","只","对于","这样","可以","价值","最终","环境","动态","与","都","派","应用","、","要求","就","神经网络","中心","高度","结合","负责","非常","以","神经","所属","高","车辆","机器","就是","控制","重叠","网格","分割","系统","开发","中将","起来","机器人","我们","说明","完成","每个","，","实时","描述","标注","网络","成","然后","下角","使用","位置","运用","包围","视频","后续","cnn","(","因此","了","度","x3","卷积","该","广泛","比如","预测","软硬","根据","最为","并","比较","实时处理","左下角","行为","自然","单个","到","自然环境","识别","进行","信息","为例","在","训练","之后","运行","下","硬件","检测","togetherros","分成","算法","图像","只有","监测","描述符","哪个","对","回到","格子","类","速度","来看","那该","一个","最高","去","内","7x7","目标","希望","包","。","狗","小狗","视频流","一般",")","结果","拿到","：","宽度","处理","的","输入","四个","开发板","将","常用","和","旭日","这","有","落"," ","那些","概率","如何","这个","对象","效率","要","yolo","时","多个","之前","它会","行驶","神经网","中心点","中","左下","有着","假设","这套","把","边界","软硬件"],"title":"目标检测原理","title_tokens":["检测","原理","目标"]},{"location":"hhp/5.5_%E5%8A%A8%E6%80%81%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/#mipi","text":"接下来，我们要利用MIPI相机，动态识别图像中各种各样的物体以及他们所在的位置，推理过程使用的是基于COCO数据集训练的80个类别，也就是可以识别80种常用的物体位置。","text_tokens":["是","各样","coco","类别","80","我们","可以","，","接下来","的","数据","下来","识别","使用","所在","个","常用","训练","动态","以及","位置","物体","种","各种各样","图像","要","接下","基于","也","推理","各种","集","就是","相机","。","利用","mipi","中","过程","他们"],"title":"MIPI相机目标检测","title_tokens":["检测","mipi","目标","相机"]},{"location":"hhp/5.5_%E5%8A%A8%E6%80%81%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/#_3","text":"$ cd /app/ai_inference/03_mipi_camera_sample/ $ python3 ./mipi_camera.py","text_tokens":["03"," ","_","app","mipi","py","cd","ai","$","sample","camera","python3","/",".","inference"],"title":"运行例程","title_tokens":["例程","运行"]},{"location":"hhp/5.5_%E5%8A%A8%E6%80%81%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/#_4","text":"mipi_camera.py： #!/usr/bin/env python3 import numpy as np import cv2 import colorsys # Camera API libs from hobot_vio import libsrcampy as srcampy from hobot_dnn import pyeasy_dnn as dnn # detection model class names def get_classes (): return np . array ([ \"person\" , \"bicycle\" , \"car\" , \"motorcycle\" , \"airplane\" , \"bus\" , \"train\" , \"truck\" , \"boat\" , \"traffic light\" , \"fire hydrant\" , \"stop sign\" , \"parking meter\" , \"bench\" , \"bird\" , \"cat\" , \"dog\" , \"horse\" , \"sheep\" , \"cow\" , \"elephant\" , \"bear\" , \"zebra\" , \"giraffe\" , \"backpack\" , \"umbrella\" , \"handbag\" , \"tie\" , \"suitcase\" , \"frisbee\" , \"skis\" , \"snowboard\" , \"sports ball\" , \"kite\" , \"baseball bat\" , \"baseball glove\" , \"skateboard\" , \"surfboard\" , \"tennis racket\" , \"bottle\" , \"wine glass\" , \"cup\" , \"fork\" , \"knife\" , \"spoon\" , \"bowl\" , \"banana\" , \"apple\" , \"sandwich\" , \"orange\" , \"broccoli\" , \"carrot\" , \"hot dog\" , \"pizza\" , \"donut\" , \"cake\" , \"chair\" , \"couch\" , \"potted plant\" , \"bed\" , \"dining table\" , \"toilet\" , \"tv\" , \"laptop\" , \"mouse\" , \"remote\" , \"keyboard\" , \"cell phone\" , \"microwave\" , \"oven\" , \"toaster\" , \"sink\" , \"refrigerator\" , \"book\" , \"clock\" , \"vase\" , \"scissors\" , \"teddy bear\" , \"hair drier\" , \"toothbrush\" ]) def bgr2nv12_opencv ( image ): height , width = image . shape [ 0 ], image . shape [ 1 ] area = height * width yuv420p = cv2 . cvtColor ( image , cv2 . COLOR_RGB2YUV_I420 ) . reshape (( area * 3 // 2 ,)) y = yuv420p [: area ] uv_planar = yuv420p [ area :] . reshape (( 2 , area // 4 )) uv_packed = uv_planar . transpose (( 1 , 0 )) . reshape (( area // 2 ,)) nv12 = np . zeros_like ( yuv420p ) nv12 [: height * width ] = y nv12 [ height * width :] = uv_packed return nv12 def get_hw ( pro ): if pro . layout == \"NCHW\" : return pro . shape [ 2 ], pro . shape [ 3 ] else : return pro . shape [ 1 ], pro . shape [ 2 ] def postprocess ( model_output , model_hw_shape , origin_image = None , origin_img_shape = None , score_threshold = 0.5 , nms_threshold = 0.6 , dump_image = False ): input_height = model_hw_shape [ 0 ] input_width = model_hw_shape [ 1 ] if origin_image is not None : origin_image_shape = origin_image . shape [ 0 : 2 ] else : origin_image_shape = origin_img_shape prediction_bbox = decode ( outputs = model_output , score_threshold = score_threshold , origin_shape = origin_image_shape , input_size = 512 ) prediction_bbox = nms ( prediction_bbox , iou_threshold = nms_threshold ) prediction_bbox = np . array ( prediction_bbox ) topk = min ( prediction_bbox . shape [ 0 ], 1000 ) if topk != 0 : idx = np . argpartition ( prediction_bbox [ ... , 4 ], - topk )[ - topk :] prediction_bbox = prediction_bbox [ idx ] if dump_image and origin_image is not None : draw_bboxs ( origin_image , prediction_bbox ) return prediction_bbox def draw_bboxs ( image , bboxes , gt_classes_index = None , classes = get_classes ()): \"\"\"draw the bboxes in the original image \"\"\" num_classes = len ( classes ) image_h , image_w , channel = image . shape hsv_tuples = [( 1.0 * x / num_classes , 1. , 1. ) for x in range ( num_classes )] colors = list ( map ( lambda x : colorsys . hsv_to_rgb ( * x ), hsv_tuples )) colors = list ( map ( lambda x : ( int ( x [ 0 ] * 255 ), int ( x [ 1 ] * 255 ), int ( x [ 2 ] * 255 )), colors )) fontScale = 0.5 bbox_thick = int ( 0.6 * ( image_h + image_w ) / 600 ) for i , bbox in enumerate ( bboxes ): coor = np . array ( bbox [: 4 ], dtype = np . int32 ) if gt_classes_index == None : class_index = int ( bbox [ 5 ]) score = bbox [ 4 ] else : class_index = gt_classes_index [ i ] score = 1 bbox_color = colors [ class_index ] c1 , c2 = ( coor [ 0 ], coor [ 1 ]), ( coor [ 2 ], coor [ 3 ]) cv2 . rectangle ( image , c1 , c2 , bbox_color , bbox_thick ) classes_name = classes [ class_index ] bbox_mess = ' %s : %.2f ' % ( classes_name , score ) t_size = cv2 . getTextSize ( bbox_mess , 0 , fontScale , thickness = bbox_thick // 2 )[ 0 ] cv2 . rectangle ( image , c1 , ( c1 [ 0 ] + t_size [ 0 ], c1 [ 1 ] - t_size [ 1 ] - 3 ), bbox_color , - 1 ) cv2 . putText ( image , bbox_mess , ( c1 [ 0 ], c1 [ 1 ] - 2 ), cv2 . FONT_HERSHEY_SIMPLEX , fontScale , ( 0 , 0 , 0 ), bbox_thick // 2 , lineType = cv2 . LINE_AA ) print ( \" {} is in the picture with confidence: {:.4f} , bbox: {} \" . format ( classes_name , score , coor )) # cv2.imwrite(\"demo.jpg\", image) return image def decode ( outputs , score_threshold , origin_shape , input_size = 512 ): def _distance2bbox ( points , distance ): x1 = points [ ... , 0 ] - distance [ ... , 0 ] y1 = points [ ... , 1 ] - distance [ ... , 1 ] x2 = points [ ... , 0 ] + distance [ ... , 2 ] y2 = points [ ... , 1 ] + distance [ ... , 3 ] return np . stack ([ x1 , y1 , x2 , y2 ], - 1 ) def _scores ( cls , ce ): cls = 1 / ( 1 + np . exp ( - cls )) ce = 1 / ( 1 + np . exp ( - ce )) return np . sqrt ( ce * cls ) def _bbox ( bbox , stride , origin_shape , input_size ): h , w = bbox . shape [ 1 : 3 ] yv , xv = np . meshgrid ( np . arange ( h ), np . arange ( w )) xy = ( np . stack (( yv , xv ), 2 ) + 0.5 ) * stride bbox = _distance2bbox ( xy , bbox ) # opencv read, shape[1] is w, shape[0] is h scale_w = origin_shape [ 1 ] / input_size scale_h = origin_shape [ 0 ] / input_size scale = max ( origin_shape [ 0 ], origin_shape [ 1 ]) / input_size # origin img is pad resized #bbox = bbox * scale # origin img is resized bbox = bbox * [ scale_w , scale_h , scale_w , scale_h ] return bbox bboxes = list () strides = [ 8 , 16 , 32 , 64 , 128 ] for i in range ( len ( strides )): cls = outputs [ i ] . buffer bbox = outputs [ i + 5 ] . buffer ce = outputs [ i + 10 ] . buffer scores = _scores ( cls , ce ) classes = np . argmax ( scores , axis =- 1 ) classes = np . reshape ( classes , [ - 1 , 1 ]) max_score = np . max ( scores , axis =- 1 ) max_score = np . reshape ( max_score , [ - 1 , 1 ]) bbox = _bbox ( bbox , strides [ i ], origin_shape , input_size ) bbox = np . reshape ( bbox , [ - 1 , 4 ]) pred_bbox = np . concatenate ([ bbox , max_score , classes ], axis = 1 ) index = pred_bbox [ ... , 4 ] > score_threshold pred_bbox = pred_bbox [ index ] bboxes . append ( pred_bbox ) return np . concatenate ( bboxes ) def nms ( bboxes , iou_threshold , sigma = 0.3 , method = 'nms' ): def bboxes_iou ( boxes1 , boxes2 ): boxes1 = np . array ( boxes1 ) boxes2 = np . array ( boxes2 ) boxes1_area = ( boxes1 [ ... , 2 ] - boxes1 [ ... , 0 ]) * \\ ( boxes1 [ ... , 3 ] - boxes1 [ ... , 1 ]) boxes2_area = ( boxes2 [ ... , 2 ] - boxes2 [ ... , 0 ]) * \\ ( boxes2 [ ... , 3 ] - boxes2 [ ... , 1 ]) left_up = np . maximum ( boxes1 [ ... , : 2 ], boxes2 [ ... , : 2 ]) right_down = np . minimum ( boxes1 [ ... , 2 :], boxes2 [ ... , 2 :]) inter_section = np . maximum ( right_down - left_up , 0.0 ) inter_area = inter_section [ ... , 0 ] * inter_section [ ... , 1 ] union_area = boxes1_area + boxes2_area - inter_area ious = np . maximum ( 1.0 * inter_area / union_area , np . finfo ( np . float32 ) . eps ) return ious classes_in_img = list ( set ( bboxes [:, 5 ])) best_bboxes = [] for cls in classes_in_img : cls_mask = ( bboxes [:, 5 ] == cls ) cls_bboxes = bboxes [ cls_mask ] while len ( cls_bboxes ) > 0 : max_ind = np . argmax ( cls_bboxes [:, 4 ]) best_bbox = cls_bboxes [ max_ind ] best_bboxes . append ( best_bbox ) cls_bboxes = np . concatenate ( [ cls_bboxes [: max_ind ], cls_bboxes [ max_ind + 1 :]]) iou = bboxes_iou ( best_bbox [ np . newaxis , : 4 ], cls_bboxes [:, : 4 ]) weight = np . ones (( len ( iou ),), dtype = np . float32 ) assert method in [ 'nms' , 'soft-nms' ] if method == 'nms' : iou_mask = iou > iou_threshold weight [ iou_mask ] = 0.0 if method == 'soft-nms' : weight = np . exp ( - ( 1.0 * iou ** 2 / sigma )) cls_bboxes [:, 4 ] = cls_bboxes [:, 4 ] * weight score_mask = cls_bboxes [:, 4 ] > 0. cls_bboxes = cls_bboxes [ score_mask ] return best_bboxes def print_properties ( pro ): print ( \"tensor type:\" , pro . tensor_type ) print ( \"data type:\" , pro . dtype ) print ( \"layout:\" , pro . layout ) print ( \"shape:\" , pro . shape ) if __name__ == '__main__' : models = dnn . load ( '../models/fcos_512x512_nv12.bin' ) # 打印输入 tensor 的属性 print_properties ( models [ 0 ] . inputs [ 0 ] . properties ) # 打印输出 tensor 的属性 print ( len ( models [ 0 ] . outputs )) for output in models [ 0 ] . outputs : print_properties ( output . properties ) # 获取 Camera 句柄 cam = srcampy . Camera () # 打开 f37 摄像头，并且把输出突出缩小成算法模型的输入尺寸 h , w = get_hw ( models [ 0 ] . inputs [ 0 ] . properties ) # 打开 F37, 初始化视频 pipeline 0 ，设置帧率30fps，缩放图像为 512 x 512 cam . open_cam ( 0 , 1 , 30 , w , h ) # Get HDMI display object disp = srcampy . Display () # For the meaning of parameters, please refer to the relevant documents of HDMI display disp . display ( 0 , 1920 , 1080 ) input_shape = ( h , w ) while True : # 从相机获取分辨率为 512x512 的nv12格式的图像数据， 参数 2 代表从硬件模块IPU中获取 img = cam . get_img ( 2 , 512 , 512 ) # 把图像数据转成 numpy 数据类型 img = np . frombuffer ( img , dtype = np . uint8 ) # 模型推理 outputs = models [ 0 ] . forward ( img ) # 对算法结果进行过滤，去掉执行度低的检测框，计算检测框的交并比去除冗余框，把检测框的坐标还原到原图位置上 prediction_bbox = postprocess ( outputs , input_shape , origin_img_shape = ( 1080 , 1920 )) # 从新获取一张图像，大小缩放成与显示器的分辨率一样的 1920 x 1080, 并且转换成 bgr格式，方便进行绘图操作 origin_image = cam . get_img ( 2 , 1920 , 1080 ) origin_nv12 = np . frombuffer ( origin_image , dtype = np . uint8 ) . reshape ( 1620 , 1920 ) origin_bgr = cv2 . cvtColor ( origin_nv12 , cv2 . COLOR_YUV420SP2BGR ) # 把算法运行后得到的物体检测框绘制到图像上 box_bgr = draw_bboxs ( origin_bgr , prediction_bbox ) # X3 的HDMI输出模块的输入图像格式需要是NV12的，所以需要先把bgr格式转成NV12 box_nv12 = bgr2nv12_opencv ( box_bgr ) # 把 NV12 格式的图像输出给显示器 disp . set_img ( box_nv12 . tobytes ()) cam . close_cam ()","text_tokens":["x","框","py","hdmi","打开","simplex","handbag","display","right","output","ious","backpack","并且","%","mask","maximum","train","交","horse","srcampy","255","cake","bottle","numpy","方便","10","dtype","env","输出模块","from","threshold","zeros","arange","pipeline","coor","gt","buffer","类型","成","dog","位置",".","int","y1","aa","f37","carrot","并","original","open","初始","scores","np","换成","#","绘制","exp","进行","enumerate","sink","close","从","as","需要","ipu","tensor","outputs","算法","-","uint8","map","person","meaning","8","1000","if","fire","tennis","512","orange","hershey","zebra","bowl",")","method","yuv420p","1920","to","draw","baseball","摄像头","hw","chair","iou","min","执行","kite","bus","0.6","h","hobot","cell","max","best","cam","refrigerator","帧","resized","0","float32","vio","transpose","argmax","cow","600","points","newaxis","1.0","union","input","box","of","vase","microwave","小成","not","与","skateboard","glove","sigma","frombuffer","先","names","y","64","hydrant","idx","'","tie","len","true","图像格式","score","..","bgr","topk","color","class","lambda","donut","物体","32","度","pizza","line","x3","car","inputs","prediction","airplane","please","fcos","bbox","python3","tobytes","xv","格式","thickness","fork","转换成","soft","detection","...","硬件","bin","输出","left","对","scissors","gettextsize","5","_","skis","the","yv","eps","得到","转换","image","上","finfo","nv12","confidence","libs","reshape","计算","xy","read","*","打印输出","是","meshgrid","uv","x2","\\","去掉","glass","table","分辨","pyeasy","bed","camera","!","laptop","surfboard","一样","新","bicycle","scale","比","nchw","demo","=","false","sign","代表","puttext","index","过滤","opencv","c2","/","inter","bench","name","up","pred","2","句柄","还原","i420","like","]",":","\"","layout","libsrcampy","rgb","后","append","properties","cv2","area","1080","linetype","摄像","colors","30","率","remote","，","大小","api","motorcycle","height","decode","__","racket","axis","broccoli","distance2bbox","(","缩小","planar","操作","and","pad","初始化","cup","ind","%.","argpartition","数据类型","model","parking","hair","in","模型","所以","hot","postprocess","分辨率","运行","hsv","mess","oven","img","检测","设置","冗余","assert","图像","plant","teddy","array","frisbee","sheep","128","format","banana","i","couch","bgr2nv12","ball","truck","toilet","section","4f","：","16","输入","的","dining","+","为",">","突出"," ","3","none","stride","toaster","boxes2","bear","t","推理","512x512","toothbrush","转成","refer","disp","strides","concatenate","原图","mipi","中","meter","list","把","nms","w","数据","30fps","import","spoon","1","bboxs","font","缩小成","range","模块","bird","distance","打印","属性","4","width","yuv420sp2bgr","classes","dnn","elephant","packed","s","y2","size","坐标","0.5","documents","is","rectangle","knife","main","object","转","snowboard","视频","sports","sandwich","rgb2yuv","辨率","0.3","for","{","jpg","giraffe","umbrella","apple","picture","ce","parameters","keyboard","return","pro","ones","2f","usr","到","tuples","num","int32","boat",",","sqrt","load","origin","stop","type","低","set","while","给","tv","forward","去除","shape","cat","models","一张","显示器","weight","}","像头","fontscale","else","结果","light","mouse","print","缩放","with","bat","book","imwrite","wine","colorsys","尺寸","traffic","relevant","clock","获取","phone","data","thick","suitcase","down","c1","cls","drier","boxes1","x1","stack","cvtcolor","参数","绘图","0.0","dump","显示","potted","相机","minimum","1620","bboxes","get","channel","[","def"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"hhp/5.5_%E5%8A%A8%E6%80%81%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/#usb","text":"如果大家手上没有MIPI接口的相机，使用USB相机也可以实现同样的功能。","text_tokens":["如果","手上","同样","usb","相机","。","没有","也","mipi","可以","实现","功能","的","，","大家","使用","接口"],"title":"USB相机目标检测","title_tokens":["检测","目标","usb","相机"]},{"location":"hhp/5.5_%E5%8A%A8%E6%80%81%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/#_5","text":"$ cd /app/ai_inference/02_usb_camera_sample/ $ python3 ./usb_camera_fcos.py","text_tokens":["02","usb"," ","_","app","fcos","py","cd","ai","$","sample","camera","python3","/",".","inference"],"title":"运行例程","title_tokens":["例程","运行"]},{"location":"hhp/5.5_%E5%8A%A8%E6%80%81%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/#_6","text":"大家如果没有HDMI显示器的话，也没有问题，刚才的例程，也可以这样来运行，我们通过统一网络环境中的浏览器就可以动态看到结果啦。 # 启动webserver服务 $ cd /opt/tros/lib/websocket/webservice/ $ chmod +x ./sbin/nginx && ./sbin/nginx -p . # 运行例程 $ source /opt/tros/setup.bash $ cp -r /opt/tros/lib/dnn_node_example/config/ . $ cp -r /opt/tros/lib/dnn_benchmark_example/config/runtime/ ./config/ $ ros2 launch /opt/tros/share/dnn_node_example/launch/hobot_dnn_node_example.launch.py config_file: = config/fcosworkconfig.json image_width: = 480 image_height: = 272","text_tokens":["如果","x","例程","这样","py","可以","hdmi","node","环境","&&","动态",":","setup","source","的话","就","benchmark","launch","websocket","p","width","ros2","dnn","chmod","刚才","nginx","我们","，","网络","tros","height",".","啦","272","config","大家","浏览","问题","r","通过","#","运行","没有","webservice","-","也","_","image","显示器","。","lib","fcosworkconfig","example","webserver","runtime","opt","结果","bash","cd","的","来","+","share"," ","服务","看到","启动","hobot","sbin","$","=","json","cp","显示","浏览器","统一","中","480","file","/"],"title":"动态目标检测","title_tokens":["检测","动态","目标"]},{"location":"hhp/5.6_%E4%BA%BA%E4%BD%93%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%B7%9F%E8%B8%AA/","text":"人体检测与跟踪 不知道大家有没有玩过类似XBOX的体感游戏机，上边会有一个相机，动态识别我们的动作，比如跳舞、打球，是不是还挺神奇的，这就是人体检测与跟踪的应用。 HHP中也集成了一套类似的算法，可以识别人体、人头、人脸、人手等一系列关键点，我们来体验一下。 编程开发方法 先来看一个人体识别的基础应用，我们驱动相机后，实时采样视觉信息，然后再通过检测算法，识别每一幅图片中人体位置，并把识别的结果保存成一张图片，便于我们查看。 运行例程 # 下载例程代码（与之前课程下载的代码一致） $ cd /userdata/dev_ws/src $ git clone https://gitee.com/guyuehome/togetherros_tutorials.git $ cd /userdata/dev_ws/ $ colcon build # 终端1，运行相机 $ source /opt/tros/setup.bash $ ros2 run mipi_cam mipi_cam --ros-args -p out_format: = nv12 -p image_width: = 960 -p image_height: = 544 -p video_device: = F37 # 终端2，运行例程 $ source /opt/tros/setup.bash $ source ./install/local_setup.bash $ mkdir -p config && cp -r /opt/tros/lib/dnn_node_example/config/multitask_body_kps_960x544.hbm config/ $ ros2 run cpp_dnn_demo cpp_dnn_demo --ros-args -p image: = config/test.jpg 代码解析 #include \"opencv2/core/mat.hpp\" #include \"opencv2/imgcodecs.hpp\" #include \"opencv2/imgproc.hpp\" #include \"dnn_node/dnn_node.h\" #include \"dnn_node/util/image_proc.h\" #include \"sensor_msgs/msg/image.hpp\" using namespace hobot :: dnn_node ; class BodyDetNode : public DnnNode { public : BodyDetNode ( const std :: string & node_name = \"body_det\" , const rclcpp :: NodeOptions & options = rclcpp :: NodeOptions ()) : DnnNode ( node_name , options ) { // 获取模型输入图片的尺寸，包括图片的宽model_input_width_和高model_input_height ，用于模型前处理 if ( Init () != 0 || GetModelInputSize ( 0 , model_input_width_ , model_input_height_ ) < 0 ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"example\" ), \"Node init fail!\" ); } //创建图片消息的subscriber，订阅的topic为”/image_raw”，消息类型为sensor_msgs::msg::Image。订阅到的图片用于算法模型推理 ros_img_subscription_ = this -> create_subscription < sensor_msgs :: msg :: Image > ( \"/image_raw\" , 10 , std :: bind ( & BodyDetNode :: FeedImg , this , std :: placeholders :: _1 )); } ~ BodyDetNode () override {} void FeedImg ( const sensor_msgs :: msg :: Image :: ConstSharedPtr msg ); protected : int SetNodePara () override { if ( ! dnn_node_para_ptr_ ) return -1 ; //指定模型推理使用的模型文件名和模型名 dnn_node_para_ptr_ -> model_file = \"config/multitask_body_kps_960x544.hbm\" ; dnn_node_para_ptr_ -> model_name = \"multitask_body_kps_960x544\" ; //指定模型输出的人体框的解析方法，其中人体框输出索引为box_output_index_ //使用的解析方法为hobot_dnn预定义的检测框解析方法FaceHandDetectionOutputParser。 std :: shared_ptr < OutputParser > box_out_parser = std :: make_shared < FaceHandDetectionOutputParser > (); dnn_node_para_ptr_ -> output_parsers_ . emplace_back ( std :: make_pair ( box_output_index_ , box_out_parser ) ); return 0 ; } int PostProcess ( const std :: shared_ptr < DnnNodeOutput > & node_output ) override ; private : int model_input_width_ = -1 ; int model_input_height_ = -1 ; const int32_t box_output_index_ = 1 ; sensor_msgs :: msg :: Image :: ConstSharedPtr img_msg_ ; rclcpp :: Subscription < sensor_msgs :: msg :: Image >:: ConstSharedPtr ros_img_subscription_ = nullptr ; }; //输出模型结果，并将结果渲染到图片后保存在本地 int BodyDetNode::PostProcess ( const std :: shared_ptr < DnnNodeOutput > & node_output ) { if ( node_output -> outputs . empty () || static_cast < int32_t > ( node_output -> outputs . size ()) < box_output_index_ ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"example\" ), \"Invalid outputs\" ); return -1 ; } auto * filter2d_result = dynamic_cast < Filter2DResult *> ( node_output -> outputs [ box_output_index_ ]. get ()); if ( ! filter2d_result ) return -1 ; std :: stringstream ss ; ss << \"img encoding: \" << img_msg_ -> encoding << \", stamp: \" << img_msg_ -> header . stamp . sec << \",\" << img_msg_ -> header . stamp . nanosec << \" \\n out box size: \" << filter2d_result -> boxes . size () << \" \\n \" ; cv :: Mat nv12 ( img_msg_ -> height * 3 / 2 , img_msg_ -> width , CV_8UC1 , const_cast < char *> ( reinterpret_cast < const char *> ( img_msg_ -> data . data ()))); cv :: Mat bgr ; cv :: cvtColor ( nv12 , bgr , CV_YUV2BGR_NV12 ); for ( auto & rect : filter2d_result -> boxes ) { ss << \"rect: \" << rect . left << \" \" << rect . top << \" \" << rect . right << \" \" << rect . bottom << \" \\n \" ; // 图片渲染 cv :: rectangle ( bgr , cv :: Point ( rect . left , rect . top ), cv :: Point ( rect . right , rect . bottom ), cv :: Scalar ( 255 , 0 , 0 ), 3 ); } std :: string result_image = \"render_\" + std :: to_string ( img_msg_ -> header . stamp . sec ) + \".\" + std :: to_string ( img_msg_ -> header . stamp . nanosec ) + \".jpg\" ; ss << \"Render img to file: \" << result_image ; RCLCPP_INFO ( rclcpp :: get_logger ( \"example\" ), \"%s\" , ss . str (). c_str ()); cv :: imwrite ( result_image , bgr ); return 0 ; } //将nv12格式的图片转成模型输入的数据类型DNNInput后，输入给推理任务 void BodyDetNode::FeedImg ( const sensor_msgs :: msg :: Image :: ConstSharedPtr img_msg ) { if ( ! img_msg ) return ; if ( \"nv12\" != img_msg -> encoding ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"example\" ), \"Only support nv12 img encoding!\" ); return ; } img_msg_ = img_msg ; // 创建模型输入数据 auto inputs = std :: vector < std :: shared_ptr < DNNInput >> { ImageProc :: GetNV12PyramidFromNV12Img ( reinterpret_cast < const char *> ( img_msg -> data . data ()), img_msg -> height , img_msg -> width , model_input_height_ , model_input_width_ )}; // 运行推理，DnnNode基类中定义并实现的启动推理接口。 Run ( inputs ); } int main ( int argc , char ** argv ) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < BodyDetNode > ()); rclcpp :: shutdown (); return 0 ; } 人体检测与跟踪 结果保存成图片，虽然便于保留数据，但是不利于动态看到效果，我们不如再来实时动态效果显示。 在这个案例中，我们在之前人体识别的基础上，进一步实现了人体部位的识别和骨骼、眼神等关键点的识别，比如头、脸、身体、手掌、眼睛。 识别的结果同样是通过浏览器来进行查看。 # 启动webserver服务 $ cd /opt/tros/lib/websocket/webservice/ $ chmod +x ./sbin/nginx && ./sbin/nginx -p . # 运行例程 $ source /opt/tros/setup.bash $ cp -r /opt/tros/lib/mono2d_body_detection/config/ . $ ros2 launch /opt/tros/share/mono2d_body_detection/launch/hobot_mono2d_body_detection.launch.py","text_tokens":["imgcodecs","x","框","是不是","进一步","py","parser","mono2d","options","关键","right","output","一下","定义","应用","订阅","%","websocket","pair","便于","高","header","255","就是","static","ros","10","实现","名","out","游戏","不利于","类型","fail","使用","成","nodeoptions","位置","基类","任务",".","vector","int","info","课程","f37","gitee","config","浏览","namespace","并",";","sec","opencv2","通过","#","进行","void","没有","动态效果","togetherros","outputs","544","算法","-","利于","会","if","。","example",")","opt","to","bash","处理","local","方法","emplace","h","代码","hobot","override","constsharedptr","之前","cam","0","util","dnnnodeoutput","include","det","手掌","n","protected","dynamic","input","node","box","消息","&","一套","再","multitask","kps","与","setnodepara","体感","logger","reinterpret","filter2dresult","source","先","encoding","launch","sensor","dnninput","proc","ss","开发","bottom","接口","nginx","查看","bgr","但是","实时","tros","class","feedimg","stamp","文件名","device","采样","inputs","玩过","make","用于","error","跟踪","格式","userdata","--","raw","文件","信息","在","detection","back","webservice","输出","left","动作","_","image","一个","上","outputparser","nv12","同样","result","不是","人头","argc","*","是","眼神","boxes","cd","（","一致","将","\\","这","shared","本地","脸","部位","知道","init","这个","!","启动","眼睛","一系","body","const","facehanddetectionoutputparser","demo","=","身体","浏览器","git","index","top","关键点","yuv2bgr","using","/","<","name","保留","support","2","com","可以","其中","驱动","topic","&&","args","动态","]","终端",":","clone","cv","src","\"","setup","体验","后","tutorials","scalar","、","video","类似","only","960","ros2","chmod","渲染","dnnnode","，","然后","height","人手","create","视觉","(","cast","str","para","比如","骨骼","invalid","跳舞","rclcpp","等","数据类型","cpp","model","神奇","模型","test","dev","subscription","r","识别","postprocess","shutdown","运行","系列","检测","img","nanosec","案例","开发方法","也","run","rect","argv","format","|","guyuehome","install","msg","的","输入","+","为","filter2d","和",">","有","imgproc"," ","3","头","960x544","sbin","t","推理","$","”","getnv12pyramidfromnv12img","集成","cp","前","this","mipi","中","一步","hpp","把","string","图片","索引","例程","基础","数据","bodydetnode","auto","编程","1","hhp","getmodelinputsize","spin","char","一幅","xbox","义","point","p","每","width","hbm","还","上边","dnn","s","我们","size","人体","nullptr","private","rectangle","main","转","了","msgs","有没有","for","public","大家","{","jpg","8uc1","return","创建","placeholders","colcon","core","到","解析","int32","包括",",","mat","挺","虽然","c","人脸","给","来看","std","ptr","一张","lib","}","不如","mkdir","不利","webserver","结果","parsers","empty","imageproc","宽","来","打球","render","imwrite","share","https","服务","看到","尺寸","）","不","效果","获取","游戏机","stringstream","data","指定","保存","下载","~","subscriber","build","cvtcolor","一系列","显示","ws","相机","bind","预定","file","get","["],"title":"人体检测与跟踪","title_tokens":["检测","人体","与","跟踪"]},{"location":"hhp/5.6_%E4%BA%BA%E4%BD%93%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%B7%9F%E8%B8%AA/#_1","text":"不知道大家有没有玩过类似XBOX的体感游戏机，上边会有一个相机，动态识别我们的动作，比如跳舞、打球，是不是还挺神奇的，这就是人体检测与跟踪的应用。 HHP中也集成了一套类似的算法，可以识别人体、人头、人脸、人手等一系列关键点，我们来体验一下。","text_tokens":["神奇","是不是","跟踪","我们","人体","可以","游戏","的","，","来","关键","识别","打球","一套","人手","动态","有","这","没有"," ","一下","系列","与","体感","挺","检测","知道","hhp","应用","体验","不","算法","、","类似","了","一系","动作","游戏机","人脸","也","有没有","比如","跳舞","一个","等","xbox","大家","会","集成","一系列","就是","玩过","相机","。","不是","中","关键点","人头","还","上边"],"title":"人体检测与跟踪","title_tokens":["检测","人体","与","跟踪"]},{"location":"hhp/5.6_%E4%BA%BA%E4%BD%93%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%B7%9F%E8%B8%AA/#_2","text":"先来看一个人体识别的基础应用，我们驱动相机后，实时采样视觉信息，然后再通过检测算法，识别每一幅图片中人体位置，并把识别的结果保存成一张图片，便于我们查看。","text_tokens":["图片","结果","查看","我们","人体","基础","驱动","的","，","实时","通过","识别","信息","然后","成","再","视觉","位置","检测","应用","后","算法","先","采样","保存","一幅","便于","来看","一个","一张","并","相机","每","。","中","把"],"title":"编程开发方法","title_tokens":["编程","开发方法","方法","开发"]},{"location":"hhp/5.6_%E4%BA%BA%E4%BD%93%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%B7%9F%E8%B8%AA/#_3","text":"# 下载例程代码（与之前课程下载的代码一致） $ cd /userdata/dev_ws/src $ git clone https://gitee.com/guyuehome/togetherros_tutorials.git $ cd /userdata/dev_ws/ $ colcon build # 终端1，运行相机 $ source /opt/tros/setup.bash $ ros2 run mipi_cam mipi_cam --ros-args -p out_format: = nv12 -p image_width: = 960 -p image_height: = 544 -p video_device: = F37 # 终端2，运行例程 $ source /opt/tros/setup.bash $ source ./install/local_setup.bash $ mkdir -p config && cp -r /opt/tros/lib/dnn_node_example/config/multitask_body_kps_960x544.hbm config/ $ ros2 run cpp_dnn_demo cpp_dnn_demo --ros-args -p image: = config/test.jpg","text_tokens":["例程","2","com","node","&&","args","终端",":","clone","multitask","kps","与","src","1","setup","source","tutorials","video","960","ros","p","width","ros2","hbm","dnn","out","，","tros","height","device",".","课程","f37","gitee","config","jpg","cpp","colcon","test","userdata","dev","r","#","--","运行","togetherros","544","-","_","run","image","format","nv12","guyuehome","lib","install","mkdir","example","opt","bash","cd","的","（","一致","local"," ","https","）","代码","960x544","body","下载","之前","cam","$","demo","=","build","cp","ws","相机","mipi","git","/"],"title":"运行例程","title_tokens":["例程","运行"]},{"location":"hhp/5.6_%E4%BA%BA%E4%BD%93%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%B7%9F%E8%B8%AA/#_4","text":"#include \"opencv2/core/mat.hpp\" #include \"opencv2/imgcodecs.hpp\" #include \"opencv2/imgproc.hpp\" #include \"dnn_node/dnn_node.h\" #include \"dnn_node/util/image_proc.h\" #include \"sensor_msgs/msg/image.hpp\" using namespace hobot :: dnn_node ; class BodyDetNode : public DnnNode { public : BodyDetNode ( const std :: string & node_name = \"body_det\" , const rclcpp :: NodeOptions & options = rclcpp :: NodeOptions ()) : DnnNode ( node_name , options ) { // 获取模型输入图片的尺寸，包括图片的宽model_input_width_和高model_input_height ，用于模型前处理 if ( Init () != 0 || GetModelInputSize ( 0 , model_input_width_ , model_input_height_ ) < 0 ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"example\" ), \"Node init fail!\" ); } //创建图片消息的subscriber，订阅的topic为”/image_raw”，消息类型为sensor_msgs::msg::Image。订阅到的图片用于算法模型推理 ros_img_subscription_ = this -> create_subscription < sensor_msgs :: msg :: Image > ( \"/image_raw\" , 10 , std :: bind ( & BodyDetNode :: FeedImg , this , std :: placeholders :: _1 )); } ~ BodyDetNode () override {} void FeedImg ( const sensor_msgs :: msg :: Image :: ConstSharedPtr msg ); protected : int SetNodePara () override { if ( ! dnn_node_para_ptr_ ) return -1 ; //指定模型推理使用的模型文件名和模型名 dnn_node_para_ptr_ -> model_file = \"config/multitask_body_kps_960x544.hbm\" ; dnn_node_para_ptr_ -> model_name = \"multitask_body_kps_960x544\" ; //指定模型输出的人体框的解析方法，其中人体框输出索引为box_output_index_ //使用的解析方法为hobot_dnn预定义的检测框解析方法FaceHandDetectionOutputParser。 std :: shared_ptr < OutputParser > box_out_parser = std :: make_shared < FaceHandDetectionOutputParser > (); dnn_node_para_ptr_ -> output_parsers_ . emplace_back ( std :: make_pair ( box_output_index_ , box_out_parser ) ); return 0 ; } int PostProcess ( const std :: shared_ptr < DnnNodeOutput > & node_output ) override ; private : int model_input_width_ = -1 ; int model_input_height_ = -1 ; const int32_t box_output_index_ = 1 ; sensor_msgs :: msg :: Image :: ConstSharedPtr img_msg_ ; rclcpp :: Subscription < sensor_msgs :: msg :: Image >:: ConstSharedPtr ros_img_subscription_ = nullptr ; }; //输出模型结果，并将结果渲染到图片后保存在本地 int BodyDetNode::PostProcess ( const std :: shared_ptr < DnnNodeOutput > & node_output ) { if ( node_output -> outputs . empty () || static_cast < int32_t > ( node_output -> outputs . size ()) < box_output_index_ ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"example\" ), \"Invalid outputs\" ); return -1 ; } auto * filter2d_result = dynamic_cast < Filter2DResult *> ( node_output -> outputs [ box_output_index_ ]. get ()); if ( ! filter2d_result ) return -1 ; std :: stringstream ss ; ss << \"img encoding: \" << img_msg_ -> encoding << \", stamp: \" << img_msg_ -> header . stamp . sec << \",\" << img_msg_ -> header . stamp . nanosec << \" \\n out box size: \" << filter2d_result -> boxes . size () << \" \\n \" ; cv :: Mat nv12 ( img_msg_ -> height * 3 / 2 , img_msg_ -> width , CV_8UC1 , const_cast < char *> ( reinterpret_cast < const char *> ( img_msg_ -> data . data ()))); cv :: Mat bgr ; cv :: cvtColor ( nv12 , bgr , CV_YUV2BGR_NV12 ); for ( auto & rect : filter2d_result -> boxes ) { ss << \"rect: \" << rect . left << \" \" << rect . top << \" \" << rect . right << \" \" << rect . bottom << \" \\n \" ; // 图片渲染 cv :: rectangle ( bgr , cv :: Point ( rect . left , rect . top ), cv :: Point ( rect . right , rect . bottom ), cv :: Scalar ( 255 , 0 , 0 ), 3 ); } std :: string result_image = \"render_\" + std :: to_string ( img_msg_ -> header . stamp . sec ) + \".\" + std :: to_string ( img_msg_ -> header . stamp . nanosec ) + \".jpg\" ; ss << \"Render img to file: \" << result_image ; RCLCPP_INFO ( rclcpp :: get_logger ( \"example\" ), \"%s\" , ss . str (). c_str ()); cv :: imwrite ( result_image , bgr ); return 0 ; } //将nv12格式的图片转成模型输入的数据类型DNNInput后，输入给推理任务 void BodyDetNode::FeedImg ( const sensor_msgs :: msg :: Image :: ConstSharedPtr img_msg ) { if ( ! img_msg ) return ; if ( \"nv12\" != img_msg -> encoding ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"example\" ), \"Only support nv12 img encoding!\" ); return ; } img_msg_ = img_msg ; // 创建模型输入数据 auto inputs = std :: vector < std :: shared_ptr < DNNInput >> { ImageProc :: GetNV12PyramidFromNV12Img ( reinterpret_cast < const char *> ( img_msg -> data . data ()), img_msg -> height , img_msg -> width , model_input_height_ , model_input_width_ )}; // 运行推理，DnnNode基类中定义并实现的启动推理接口。 Run ( inputs ); } int main ( int argc , char ** argv ) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < BodyDetNode > ()); rclcpp :: shutdown (); return 0 ; }","text_tokens":["imgcodecs","string","图片","框","索引","protected","dynamic","2","support","其中","parser","input","node","box","数据","options","&","消息","topic","bodydetnode","auto","]","right",":","output","multitask","setnodepara","1","kps","\"","logger","cv","reinterpret","filter2dresult","定义","getmodelinputsize","后","scalar","订阅","spin","encoding","only","char","sensor","%","pair","高","header","义","255","point","static","ros","dnninput","width","proc","10","实现","hbm","ss","dnn","bottom","接口","名","渲染","bgr","s","dnnnode","out","人体","size","，","类型","nullptr","fail","使用","private","height","class","rectangle","成","feedimg","main","nodeoptions","create","转","基类","stamp","任务","文件名",".","(","vector","cast","int","info","str","para","n","msgs","for","public","invalid","rclcpp","config","{","jpg","inputs","数据类型","namespace","并",";","make","model","8uc1","return","用于","模型","创建","error","placeholders","sec","opencv2","格式","core","subscription","到","#","raw","文件","解析","void","在","int32","postprocess","shutdown","包括","运行",",","mat","img","检测","nanosec","outputs","back","算法","输出","-","left","c","_","给","run","image","rect","std","argv","ptr","outputparser","|","nv12","result","if","。","}","example","msg","argc",")","*","parsers","结果","to","boxes","处理","empty","输入","的","宽","imageproc","+","为","将","filter2d","render","和",">","\\","imwrite","shared","imgproc","方法"," ","3","本地","emplace","尺寸","init","!","h","启动","960x544","hobot","body","const","获取","override","stringstream","data","constsharedptr","指定","~","推理","t","保存","subscriber","facehanddetectionoutputparser","=","”","cvtcolor","getnv12pyramidfromnv12img","0","前","this","util","bind","预定","dnnnodeoutput","中","include","det","file","index","top","hpp","get","yuv2bgr","using","/","[","<","name"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"hhp/5.6_%E4%BA%BA%E4%BD%93%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%B7%9F%E8%B8%AA/#_5","text":"结果保存成图片，虽然便于保留数据，但是不利于动态看到效果，我们不如再来实时动态效果显示。 在这个案例中，我们在之前人体识别的基础上，进一步实现了人体部位的识别和骨骼、眼神等关键点的识别，比如头、脸、身体、手掌、眼睛。 识别的结果同样是通过浏览器来进行查看。 # 启动webserver服务 $ cd /opt/tros/lib/websocket/webservice/ $ chmod +x ./sbin/nginx && ./sbin/nginx -p . # 运行例程 $ source /opt/tros/setup.bash $ cp -r /opt/tros/lib/mono2d_body_detection/config/ . $ ros2 launch /opt/tros/share/mono2d_body_detection/launch/hobot_mono2d_body_detection.launch.py","text_tokens":["x","图片","例程","进一步","py","基础","数据","mono2d","关键","&&","动态","再","setup","source","、","launch","websocket","便于","p","ros2","实现","chmod","nginx","查看","但是","我们","人体","，","不利于","实时","tros","成",".","了","骨骼","比如","等","config","浏览","r","通过","#","识别","进行","在","运行","动态效果","detection","案例","webservice","虽然","-","利于","_","上","同样","。","lib","不如","不利","webserver","opt","结果","是","眼神","bash","cd","的","来","+","和","share"," ","头","服务","脸","部位","看到","这个","眼睛","效果","启动","hobot","body","sbin","保存","之前","$","身体","cp","显示","浏览器","中","一步","手掌","关键点","/","保留"],"title":"人体检测与跟踪","title_tokens":["检测","人体","与","跟踪"]},{"location":"hhp/5.7_%E5%8D%95%E7%9B%AE3D%E5%AE%A4%E5%86%85%E6%A3%80%E6%B5%8B/","text":"单目3D室内检测 接下来，我们继续学习物体 3D 检测算法。 机器人有时候不仅仅要识别出人，还要识别出房间里有什么东西，这就是室内物体 3D 检测啦。 在HHP上，就集成了这样一套算法，接下来让我们一起来体验以下吧。 先来看一张图片，很明显大家可以看到图中有两个垃圾桶。 运行示例程序 # 配置ROS2环境 $ source /opt/tros/setup.bash # 从tros的安装路径中拷贝出运行示例需要的配置文件。 $ cp -r /opt/tros/lib/mono3d_indoor_detection/config/ . # 启动launch文件 $ ros2 launch /opt/tros/share/mono3d_indoor_detection/launch/mono3d_indoor_detection.launch.py [ INFO ] [ 1654858490 .168592166 ] [ mono3d_detection ] : target type: trash_can [ INFO ] [ 1654858490 .168644750 ] [ mono3d_detection ] : target type: width, value: 236 .816406 [ INFO ] [ 1654858490 .168704333 ] [ mono3d_detection ] : target type: height, value: 305 .664062 [ INFO ] [ 1654858490 .168759584 ] [ mono3d_detection ] : target type: length, value: 224 .182129 [ INFO ] [ 1654858490 .168812334 ] [ mono3d_detection ] : target type: rotation, value: -1571.989179 [ INFO ] [ 1654858490 .168862543 ] [ mono3d_detection ] : target type: x, value: -191.977829 [ INFO ] [ 1654858490 .168916168 ] [ mono3d_detection ] : target type: y, value: -143.963307 [ INFO ] [ 1654858490 .168966502 ] [ mono3d_detection ] : target type: z, value: 714 .024127 [ INFO ] [ 1654858490 .169016794 ] [ mono3d_detection ] : target type: depth, value: 714 .024127 [ INFO ] [ 1654858490 .169067461 ] [ mono3d_detection ] : target type: score, value: 0 .973215 [ INFO ] [ 1654858490 .169168795 ] [ mono3d_detection ] : target type: trash_can [ INFO ] [ 1654858490 .169212837 ] [ mono3d_detection ] : target type: width, value: 253 .051758 [ INFO ] [ 1654858490 .169265004 ] [ mono3d_detection ] : target type: height, value: 282 .348633 [ INFO ] [ 1654858490 .169317046 ] [ mono3d_detection ] : target type: length, value: 257 .934570 [ INFO ] [ 1654858490 .169368921 ] [ mono3d_detection ] : target type: rotation, value: -1542.727947 [ INFO ] [ 1654858490 .169418671 ] [ mono3d_detection ] : target type: x, value: 552 .459776 [ INFO ] [ 1654858490 .169470588 ] [ mono3d_detection ] : target type: y, value: -164.073169 [ INFO ] [ 1654858490 .169517505 ] [ mono3d_detection ] : target type: z, value: 1088 .358164 [ INFO ] [ 1654858490 .169566839 ] [ mono3d_detection ] : target type: depth, value: 1088 .358164 [ INFO ] [ 1654858490 .169616464 ] [ mono3d_detection ] : target type: score, value: 0 .875521 很明显，已经识别到了两个垃圾桶。 代码解析 // Copyright (c) 2022，Horizon Robotics. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"include/centernet_3d_detection_node.h\" #include <unistd.h> #include <fstream> #include <memory> #include <string> #include <vector> #include \"dnn_node/dnn_node.h\" #include \"include/image_utils.h\" #include \"rclcpp/rclcpp.hpp\" #include <sys/stat.h> #ifdef CV_BRIDGE_PKG_ENABLED #include <cv_bridge/cv_bridge.h> #endif using hobot :: easy_dnn :: OutputDescription ; using hobot :: easy_dnn :: OutputParser ; CenterNet3DDetectionNode :: CenterNet3DDetectionNode ( const std :: string & node_name , const NodeOptions & options ) : DnnNode ( node_name , options ), output_frameCount_ ( 0 ) { this -> declare_parameter < int > ( \"is_sync_mode\" , is_sync_mode_ ); this -> declare_parameter < std :: string > ( \"config_file_path\" , config_file_path_ ); this -> declare_parameter < int > ( \"shared_mem\" , shared_mem_ ); this -> declare_parameter < std :: string > ( \"ai_msg_pub_topic_name\" , msg_pub_topic_name_ ); this -> declare_parameter < std :: string > ( \"image_sub_topic_name\" , ros_img_topic_name_ ); this -> declare_parameter < std :: string > ( \"feed_image\" , feed_image_ ); this -> get_parameter < int > ( \"is_sync_mode\" , is_sync_mode_ ); this -> get_parameter < std :: string > ( \"config_file_path\" , config_file_path_ ); this -> get_parameter < int > ( \"shared_mem\" , shared_mem_ ); this -> get_parameter < std :: string > ( \"ai_msg_pub_topic_name\" , msg_pub_topic_name_ ); this -> get_parameter < std :: string > ( \"image_sub_topic_name\" , ros_img_topic_name_ ); this -> get_parameter < std :: string > ( \"feed_image\" , feed_image_ ); model_file_name_ = config_file_path_ + \"/centernet.hbm\" ; mkdir ( \"./result/\" , 666 ); std :: stringstream ss ; ss << \"Parameter:\" << \" \\n config_file_path_:\" << config_file_path_ << \" \\n shared_men:\" << shared_mem_ << \" \\n is_sync_mode_: \" << is_sync_mode_ << \" \\n model_file_name_: \" << model_file_name_ << \" \\n feed_image:\" << feed_image_ ; RCLCPP_WARN ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"%s\" , ss . str (). c_str ()); if ( Start () == 0 ) { RCLCPP_WARN ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"start success!!!\" ); } else { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"start fail!!!\" ); } } CenterNet3DDetectionNode ::~ CenterNet3DDetectionNode () {} int CenterNet3DDetectionNode :: Start () { int ret = Init (); if ( ret != 0 ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Init failed!\" ); return ret ; } ret = GetModelInputSize ( 0 , model_input_width_ , model_input_height_ ); if ( ret < 0 ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Get model input size fail!\" ); return ret ; } RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"The model input width is %d and height is %d\" , model_input_width_ , model_input_height_ ); msg_publisher_ = this -> create_publisher < ai_msgs :: msg :: PerceptionTargets > ( msg_pub_topic_name_ , 10 ); RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"msg_pub_topic_name: %s\" , msg_pub_topic_name_ . data ()); if ( ! feed_image_ . empty ()) { std :: cout << \"mono3d read image:\" << feed_image_ << \" to detect\" << std :: endl ; PredictByImage ( feed_image_ ); return 0 ; } // RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Detect images that use subscriptions\" ); if ( shared_mem_ ) { #ifdef SHARED_MEM_ENABLED RCLCPP_WARN ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Create hbmem_subscription with topic_name: %s\" , sharedmem_img_topic_name_ . c_str ()); sharedmem_img_subscription_ = this -> create_subscription_hbmem < hbm_img_msgs :: msg :: HbmMsg1080P > ( sharedmem_img_topic_name_ , 10 , std :: bind ( & CenterNet3DDetectionNode :: SharedMemImgProcess , this , std :: placeholders :: _1 )); #else RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Unsupport shared mem\" ); #endif } else { RCLCPP_WARN ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Create subscription with topic_name: %s\" , ros_img_topic_name_ . c_str ()); ros_img_subscription_ = this -> create_subscription < sensor_msgs :: msg :: Image > ( ros_img_topic_name_ , 10 , std :: bind ( & CenterNet3DDetectionNode :: RosImgProcess , this , std :: placeholders :: _1 )); } return 0 ; } int CenterNet3DDetectionNode :: SetNodePara () { RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Set node para.\" ); if ( ! dnn_node_para_ptr_ ) { return -1 ; } dnn_node_para_ptr_ -> model_file = model_file_name_ ; dnn_node_para_ptr_ -> model_name = model_name_ ; dnn_node_para_ptr_ -> model_task_type = model_task_type_ ; dnn_node_para_ptr_ -> task_num = 1 ; return 0 ; } int CenterNet3DDetectionNode :: SetOutputParser () { // set output parser auto model_manage = GetModel (); if ( ! model_manage || ! dnn_node_para_ptr_ ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Invalid model\" ); return -1 ; } if ( model_manage -> GetOutputCount () < model_output_count_ ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Error! Model %s output count is %d, unmatch with count %d\" , dnn_node_para_ptr_ -> model_name . c_str (), model_manage -> GetOutputCount (), model_output_count_ ); return -1 ; } for ( int i = 0 ; i < output_index_ ; ++ i ) { std :: shared_ptr < OutputParser > assist_parser = std :: make_shared < CenterNet3DAssistParser > (); model_manage -> SetOutputParser ( i , assist_parser ); } // set 3D paser auto output_desc = std :: make_shared < OutputDescription > ( model_manage , output_index_ , \"3D_branch\" ); for ( int i = 0 ; i < output_index_ ; ++ i ) { output_desc -> GetDependencies (). push_back ( i ); } output_desc -> SetType ( \"3D\" ); model_manage -> SetOutputDescription ( output_desc ); std :: shared_ptr < OutputParser > out_parser = std :: make_shared < CenterNet3DOutputParser > ( config_file_path_ ); model_manage -> SetOutputParser ( output_index_ , out_parser ); return 0 ; } #define CV_DRAW_LINE(p0, p1) \\ cv::line(image, cv::Point(points[p0][0], points[p0][1]), \\ cv::Point(points[p1][0], points[p1][1]), \\ CV_RGB(0, 255, 0), 2); #define CV_PUT_TEXT(text, px, py, offset) \\ { double fontScale = 3.0l; int thickness = 3u, baseline; \\ cv::Size text_size = cv::getTextSize(text, \\ cv::HersheyFonts::FONT_HERSHEY_PLAIN, fontScale, thickness, &baseline); \\ cv::Point point(px , py); \\ point.y += offset;\\ cv::Rect rect(point.x, point.y, \\ text_size.width, text_size.height); \\ point.y += text_size.height;\\ offset += text_size.height;\\ cv::putText(image, text, point, \\ cv::HersheyFonts::FONT_HERSHEY_PLAIN, \\ fontScale, CV_RGB(0, 255, 128), thickness); } void Render3DBox ( const BBox3D & box , cv :: Mat & image ) { auto & points = box . corners2d_upscale ; CV_DRAW_LINE ( 0 , 1 ) CV_DRAW_LINE ( 0 , 3 ) CV_DRAW_LINE ( 0 , 4 ) CV_DRAW_LINE ( 1 , 2 ) CV_DRAW_LINE ( 1 , 5 ) CV_DRAW_LINE ( 2 , 3 ) CV_DRAW_LINE ( 2 , 6 ) CV_DRAW_LINE ( 3 , 7 ) CV_DRAW_LINE ( 4 , 5 ) CV_DRAW_LINE ( 4 , 7 ) CV_DRAW_LINE ( 5 , 6 ) CV_DRAW_LINE ( 6 , 7 ) std :: string box_type = std :: to_string ( box . class_label ); std :: string score = std :: to_string ( box . score ); int offset = 0 ; if ( - M_PI_2 <= box . r || box . r <= M_PI_2 ) { CV_PUT_TEXT ( box_type , points [ 7 ][ 0 ], points [ 7 ][ 1 ], offset ); CV_PUT_TEXT ( score , points [ 7 ][ 0 ], points [ 7 ][ 1 ], offset ); } else { CV_PUT_TEXT ( box_type , points [ 6 ][ 0 ], points [ 6 ][ 1 ], offset ); CV_PUT_TEXT ( score , points [ 6 ][ 0 ], points [ 6 ][ 1 ], offset ); } } int CenterNet3DDetectionNode :: PostProcess ( const std :: shared_ptr < DnnNodeOutput > & node_output ) { if ( ! msg_publisher_ ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"example\" ), \"Invalid msg_publisher_\" ); return -1 ; } struct timespec time_start = { 0 , 0 }; clock_gettime ( CLOCK_REALTIME , & time_start ); ai_msgs :: msg :: Perf perf ; perf . set__type ( \"PostProcess\" ); perf . stamp_start . sec = time_start . tv_sec ; perf . stamp_start . nanosec = time_start . tv_nsec ; auto centernet_3d_output = std :: dynamic_pointer_cast < CenterNet3DOutput > ( node_output ); if ( centernet_3d_output ) { std :: stringstream ss ; ss << \"3D output dection info\" ; if ( centernet_3d_output -> image_msg_header_ ) { ss << \", frame_id: \" << centernet_3d_output -> image_msg_header_ -> frame_id << \", stamp: \" << centernet_3d_output -> image_msg_header_ -> stamp . sec << \".\" << centernet_3d_output -> image_msg_header_ -> stamp . nanosec ; } RCLCPP_DEBUG ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"%s\" , ss . str (). c_str ()); } const auto & outputs = node_output -> outputs ; RCLCPP_DEBUG ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"outputs size: %d\" , outputs . size ()); if ( outputs . empty () || static_cast < int32_t > ( outputs . size ()) < model_output_count_ ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Invalid outputs\" ); return -1 ; } int smart_fps = 0 ; { auto tp_now = std :: chrono :: system_clock :: now (); output_frameCount_ ++ ; auto interval = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( tp_now - output_tp_ ) . count (); if ( interval >= 1000 ) { smart_fps = output_frameCount_ ; RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Smart fps = %d\" , smart_fps ); output_frameCount_ = 0 ; output_tp_ = std :: chrono :: system_clock :: now (); } } ai_msgs :: msg :: PerceptionTargets :: UniquePtr pub_data ( new ai_msgs :: msg :: PerceptionTargets ()); if ( centernet_3d_output -> image_msg_header_ ) { pub_data -> header . set__stamp ( centernet_3d_output -> image_msg_header_ -> stamp ); pub_data -> header . set__frame_id ( centernet_3d_output -> image_msg_header_ -> frame_id ); } pub_data -> set__fps ( smart_fps ); auto * det_result = dynamic_cast < CenterNet3DDetResult *> ( outputs [ output_index_ ]. get ()); if ( ! det_result ) { RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"invalid cast\" ); } else { RCLCPP_DEBUG ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"out box size: %d\" , det_result -> boxes . size ()); std :: map < std :: string , ai_msgs :: msg :: Target > target_list ; std :: vector < ai_msgs :: msg :: Target > targets ; targets . reserve ( det_result -> boxes . size ()); for ( auto & box : det_result -> boxes ) { ai_msgs :: msg :: Target target ; switch ( box . class_label ) { case BBox3D :: CHARGING_BASE : target . type = \"charging_base\" ; break ; case BBox3D :: SLIPPER : target . type = \"slipper\" ; break ; case BBox3D :: TRASH_CAN : target . type = \"trash_can\" ; break ; } RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_detection\" ), \"target type: %s\" , target . type . c_str ()); ai_msgs :: msg :: Attribute attribute ; ai_msgs :: msg :: Point point ; attribute . type = \"width\" ; attribute . value = box . w * 1000. ; RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_detection\" ), \"target type: %s, value: %f\" , attribute . type . c_str (), attribute . value ); target . attributes . push_back ( attribute ); attribute . type = \"height\" ; attribute . value = box . h * 1000. ; RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_detection\" ), \"target type: %s, value: %f\" , attribute . type . c_str (), attribute . value ); target . attributes . push_back ( attribute ); attribute . type = \"length\" ; attribute . value = box . l * 1000. ; RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_detection\" ), \"target type: %s, value: %f\" , attribute . type . c_str (), attribute . value ); target . attributes . push_back ( attribute ); attribute . type = \"rotation\" ; attribute . value = box . r * 1000. ; RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_detection\" ), \"target type: %s, value: %f\" , attribute . type . c_str (), attribute . value ); target . attributes . push_back ( attribute ); attribute . type = \"x\" ; attribute . value = box . x * 1000. ; RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_detection\" ), \"target type: %s, value: %f\" , attribute . type . c_str (), attribute . value ); target . attributes . push_back ( attribute ); attribute . type = \"y\" ; attribute . value = box . y * 1000. ; RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_detection\" ), \"target type: %s, value: %f\" , attribute . type . c_str (), attribute . value ); target . attributes . push_back ( attribute ); attribute . type = \"z\" ; attribute . value = box . z * 1000. ; RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_detection\" ), \"target type: %s, value: %f\" , attribute . type . c_str (), attribute . value ); target . attributes . push_back ( attribute ); attribute . type = \"depth\" ; attribute . value = box . d * 1000. ; RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_detection\" ), \"target type: %s, value: %f\" , attribute . type . c_str (), attribute . value ); target . attributes . push_back ( attribute ); attribute . type = \"score\" ; attribute . value = box . score * 1000. ; RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_detection\" ), \"target type: %s, value: %f\" , attribute . type . c_str (), box . score ); target . attributes . push_back ( attribute ); // 8 corners /* 4----------5 6----------7 /| /| /| /| / | / | / | / | / | / | / | / | 7---|------6 |5---|------4 | | | | || | | | | | | || | | | | 0------|---1| 2------|---3 | / | / | / | / | / ^ | / | / v | / |/ |/ |/ |/ 3----------2 1----------0 */ for ( const auto & corners : box . corners2d_upscale ) { geometry_msgs :: msg :: Point32 g_point ; g_point . x = corners [ 0 ]; g_point . y = corners [ 1 ]; point . point . push_back ( g_point ); } point . type = \"corners\" ; target . points . push_back ( point ); targets . push_back ( target ); } pub_data -> targets = std :: move ( targets ); if ( ! centernet_3d_output -> image_name_ . empty ()) { auto img_bgr = cv :: imread ( centernet_3d_output -> image_name_ ); for ( auto & box : det_result -> boxes ) { Render3DBox ( box , img_bgr ); } std :: string :: size_type iPos = centernet_3d_output -> image_name_ . find_last_of ( '/' ) + 1 ; std :: string filename = centernet_3d_output -> image_name_ . substr ( iPos , centernet_3d_output -> image_name_ . length () - iPos ); cv :: imwrite ( \"./result/\" + filename , img_bgr ); } } clock_gettime ( CLOCK_REALTIME , & time_start ); perf . stamp_end . sec = time_start . tv_sec ; perf . stamp_end . nanosec = time_start . tv_nsec ; pub_data -> perfs . emplace_back ( perf ); msg_publisher_ -> publish ( std :: move ( pub_data )); return 0 ; } int CenterNet3DDetectionNode :: Predict ( std :: vector < std :: shared_ptr < DNNInput >> & inputs , const std :: shared_ptr < std :: vector < hbDNNRoi >> rois , std :: shared_ptr < DnnNodeOutput > dnn_output ) { return Run ( inputs , dnn_output , rois , is_sync_mode_ == 1 ); } void CenterNet3DDetectionNode :: RosImgProcess ( const sensor_msgs :: msg :: Image :: ConstSharedPtr img_msg ) { if ( ! img_msg || ! rclcpp :: ok ()) { return ; } std :: stringstream ss ; ss << \"Recved img encoding: \" << img_msg -> encoding << \", h: \" << img_msg -> height << \", w: \" << img_msg -> width << \", step: \" << img_msg -> step << \", frame_id: \" << img_msg -> header . frame_id << \", stamp: \" << img_msg -> header . stamp . sec << \".\" << img_msg -> header . stamp . nanosec << \", data size: \" << img_msg -> data . size (); RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"%s\" , ss . str (). c_str ()); auto tp_start = std :: chrono :: system_clock :: now (); // 1. 将图片处理成模型输入数据类型DNNInput // 使用图片生成pym，NV12PyramidInput为DNNInput的子类 std :: shared_ptr < hobot :: easy_dnn :: NV12PyramidInput > pyramid = nullptr ; if ( \"rgb8\" == img_msg -> encoding ) { #ifdef CV_BRIDGE_PKG_ENABLED auto cv_img = cv_bridge :: cvtColorForDisplay ( cv_bridge :: toCvShare ( img_msg ), \"bgr8\" ); { auto tp_now = std :: chrono :: system_clock :: now (); auto interval = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( tp_now - tp_start ) . count (); RCLCPP_DEBUG ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"after cvtColorForDisplay cost ms: %d\" , interval ); } pyramid = ImageUtils :: GetNV12Pyramid ( cv_img -> image , model_input_height_ , model_input_width_ ); #else RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Unsupport cv bridge\" ); #endif } else if ( \"nv12\" == img_msg -> encoding ) { pyramid = ImageUtils :: GetNV12PyramidFromNV12Img ( reinterpret_cast < const char *> ( img_msg -> data . data ()), img_msg -> height , img_msg -> width , model_input_height_ , model_input_width_ ); } if ( ! pyramid ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Get Nv12 pym fail\" ); return ; } { auto tp_now = std :: chrono :: system_clock :: now (); auto interval = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( tp_now - tp_start ) . count (); RCLCPP_DEBUG ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"after GetNV12Pyramid cost ms: %d\" , interval ); } RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Dnn node begin to predict\" ); // 2. 使用pyramid创建DNNInput对象inputs // inputs将会作为模型的输入通过RunInferTask接口传入 auto inputs = std :: vector < std :: shared_ptr < DNNInput >> { pyramid }; auto dnn_output = std :: make_shared < CenterNet3DOutput > (); dnn_output -> src_img_width_ = img_msg -> width ; dnn_output -> src_img_height_ = img_msg -> height ; dnn_output -> image_msg_header_ = std :: make_shared < std_msgs :: msg :: Header > (); dnn_output -> image_msg_header_ -> set__frame_id ( img_msg -> header . frame_id ); dnn_output -> image_msg_header_ -> set__stamp ( img_msg -> header . stamp ); dnn_output -> image_name_ = \"\" ; // 3. 开始预测 uint32_t ret = Predict ( inputs , nullptr , dnn_output ); { auto tp_now = std :: chrono :: system_clock :: now (); auto interval = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( tp_now - tp_start ) . count (); RCLCPP_DEBUG ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"after Predict cost ms: %d\" , interval ); } if ( ret != 0 ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"predict img failed!\" ); } return ; } int CenterNet3DDetectionNode :: PredictByImage ( const std :: string & image ) { // 1. 将图片处理成模型输入数据类型DNNInput // 使用图片生成pym，NV12PyramidInput为DNNInput的子类 std :: shared_ptr < hobot :: easy_dnn :: NV12PyramidInput > pyramid = nullptr ; // bgr img，支持将图片resize到模型输入size pyramid = ImageUtils :: GetNV12Pyramid ( image , ImageType :: BGR , model_input_height_ , model_input_width_ ); if ( ! pyramid ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Get Nv12 pym fail with image: %s\" , image . c_str ()); return -1 ; } // 2. 使用pyramid创建DNNInput对象inputs // inputs将会作为模型的输入通过RunInferTask接口传入 auto inputs = std :: vector < std :: shared_ptr < DNNInput >> { pyramid }; auto dnn_output = std :: make_shared < CenterNet3DOutput > (); dnn_output -> src_img_width_ = 1920 ; dnn_output -> src_img_height_ = 1024 ; dnn_output -> image_msg_header_ = std :: make_shared < std_msgs :: msg :: Header > (); dnn_output -> image_msg_header_ -> set__frame_id ( \"test_frame\" ); dnn_output -> image_msg_header_ -> set__stamp ( rclcpp :: Time ()); dnn_output -> image_name_ = image ; // dnn_output->image_msg_header->set__frame_id(std::to_string(img_msg->index)); // dnn_output->image_msg_header->set__stamp(img_msg->time_stamp); // 3. 开始预测 uint32_t ret = Predict ( inputs , nullptr , dnn_output ); if ( ret != 0 ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"predict img failed!\" ); } return ret ; } #ifdef SHARED_MEM_ENABLED void CenterNet3DDetectionNode :: SharedMemImgProcess ( const hbm_img_msgs :: msg :: HbmMsg1080P :: ConstSharedPtr img_msg ) { if ( ! img_msg || ! rclcpp :: ok ()) { return ; } RCLCPP_DEBUG ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"go into shared mem\" ); // dump recved img msg // std::ofstream ofs(\"img_\" + std::to_string(img_msg->index) + \".\" + // std::string(reinterpret_cast<const char*>(img_msg->encoding.data()))); // ofs.write(reinterpret_cast<const char*>(img_msg->data.data()), // img_msg->data_size); auto tp_start = std :: chrono :: system_clock :: now (); // 1. 将图片处理成模型输入数据类型DNNInput // 使用图片生成pym，NV12PyramidInput为DNNInput的子类 std :: shared_ptr < hobot :: easy_dnn :: NV12PyramidInput > pyramid = nullptr ; if ( \"nv12\" == std :: string ( reinterpret_cast < const char *> ( img_msg -> encoding . data ()))) { pyramid = ImageUtils :: GetNV12PyramidFromNV12Img ( reinterpret_cast < const char *> ( img_msg -> data . data ()), img_msg -> height , img_msg -> width , model_input_height_ , model_input_width_ ); } else { RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"share mem unsupported img encoding: %s\" , img_msg -> encoding ); } if ( ! pyramid ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Get Nv12 pym fail!\" ); return ; } { auto tp_now = std :: chrono :: system_clock :: now (); auto interval = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( tp_now - tp_start ) . count (); RCLCPP_DEBUG ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"after GetNV12Pyramid cost ms: %d\" , interval ); } // 2. 使用pyramid创建DNNInput对象inputs // inputs将会作为模型的输入通过RunInferTask接口传入 auto inputs = std :: vector < std :: shared_ptr < DNNInput >> { pyramid }; auto dnn_output = std :: make_shared < CenterNet3DOutput > (); dnn_output -> src_img_width_ = img_msg -> width ; dnn_output -> src_img_height_ = img_msg -> height ; dnn_output -> image_msg_header_ = std :: make_shared < std_msgs :: msg :: Header > (); dnn_output -> image_msg_header_ -> set__frame_id ( std :: to_string ( img_msg -> index )); dnn_output -> image_msg_header_ -> set__stamp ( img_msg -> time_stamp ); // 3. 开始预测 int ret = Predict ( inputs , nullptr , dnn_output ); { auto tp_now = std :: chrono :: system_clock :: now (); auto interval = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( tp_now - tp_start ) . count (); RCLCPP_DEBUG ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"after Predict cost ms: %d\" , interval ); } // 4. 处理预测结果，如渲染到图片或者发布预测结果 if ( ret != 0 ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Run predict failed!\" ); } return ; } #endif","text_tokens":["x","ipos","after","py","parser","centernet3dassistparser","options","path","如","mem","output","failed","1542.727947","就","id","%","unsupport","459776","header","255","机器","就是","static","find","ros","attribute","配置文件","什么","垃圾","10","子类","attributes","ret","ifdef","6","www","out","pointer","limitations","类型","fail","使用","成","236","targets","centernet3ddetectionnode","nodeoptions","centernet3doutput","can",".","target","vector","v","int","info","ok","imagetype","put","see","sync","cost","config","168644750","l",";","desc","图中","time","obtain","robotics","sec","setoutputdescription","g","很","#","通过","void","end","从","as","需要","hbmmsg1080p","outputs","算法","offset","-","task","map","169016794","licenses","不仅仅","outputdescription","8","1000","if","。","224","hershey","example","uint32",")","1920","opt","text","to","draw","bash","处理","mono3d","agreed","either","出人","168916168","1024","indoor","3d","tocvshare","stat","charging","emplace","value","h","代码","hobot","plain","perf","p0","constsharedptr","success","milliseconds","---","rosimgprocess","bgr8","0","into","dnnnodeoutput","trash","include","enabled","hbmem","manage","det","继续","points","cvtcolorfordisplay","n","count","以下","dynamic","predict","input","node","box","of","base","&","一套","环境","not","corners","pym","setnodepara","reinterpret","logger","centernet3ddetresult","source","先","you","282","subscriptions","----------","encoding","y","168704333","launch","sensor","168862543","software","'","writing","dnninput","169418671","垃圾桶","ss","score","室内","utils","支持","接口","3u","gettime","起来","bgr","305","下来","tros","class","recved","law","upscale","169616464","程序","物体","stamp","a","------","一","resize","253","unmatch","line","dection","169566839","d","horizon","inputs","pkg","169470588","348633","that","case","make","191.977829","apache","settype","licensed","error","break","7","thickness","文件","在","sys","detection","org","back","start","配置","gettextsize","接下","paser","_","5","the","image","use","debug","上","outputparser","nv12","result","read","corners2d","时候","detect","*","1571.989179","boxes","predictbyimage","生成","552","将","或者","\\","这","shared","169067461","perfs","init","label","对象","!","启动","const","specific","=","struct","已经","under","switch","168592166","934570","puttext","substr","358164","index","using","/","warranties","<","name","2","可以","basis","topic","implied","parameter","]","明显","875521",":","cv","src","\"","setup","rgb","体验","getmodel","an","ofstream","geometry","on","distributed","p1","timespec","ros2","sub","ofs","168759584","imread","东西","write","渲染","机器人","dnnnode","interval","push","，","depth","height","1088","__","create","学习","里","uniqueptr","(","cast","now","hbdnnroi","啦","str","para","666","kind","and","预测","invalid","baseline","rclcpp","数据类型","chrono","169265004","169168795","realtime","model","in","模型","point32","language","168812334","test","subscription","setoutputparser","r","识别","rgb8","express","postprocess","运行","安装","169212837","检测","img","nanosec","3.0","by","or","1654858490","run","conditions","sharedmemimgprocess","version","rect","length","128","last","cout","images","|","unsupported","作为","i","nv12pyramidinput","copy","fstream","仅仅","applicable","msg","slipper","bbox3d","816406","compliance","bridge","的","输入","assist","+","为",">","getoutputcount","有","169368921"," ","257","centernet","3","begin","2022","reserve","t","at","easy","$","move","024127","branch","getnv12pyramidfromnv12img","集成","cp","this","143.963307","169317046","中","list","unistd","hpp","^","http","string","图片","w","这样","endif","数据","render3dbox","auto","168966502","ms","182129","framecount","mode","房间","1","hersheyfonts","hhp","getmodelinputsize","font","px","go","有时候","char","rotation","传入","new","让","publish","point","++","4","拷贝","width","hbm","dnn","nsec","without","示例","s","我们","size","is","imageutils","nullptr","fps","tp","路径","了","f","msgs","license","rois","for","runinfertask","664062","发布","大家","{","2.0","unless","governing","memory","double","return","创建","出","开始","placeholders","smart","getdependencies","centernet3doutputparser","两个","169517505","到","接下来","required","declare","num","解析","define","051758","int32","copyright","吧","frame",",","mat","ai","type","单目","except","any","c","有时","973215","set","tv","来看","std","不仅","714","permissions","ptr","一张","lib","}","perceptiontargets","fontscale","mkdir","pub","else","结果","warn","pi","with","empty","system","step","imwrite","share","164.073169","duration","看到","getnv12pyramid","sharedmem","pyramid","将会","要","may","clock","stringstream","data","z","~","filename","还要","feed","dump","publisher","endl","bind","file","men","get","[","m"],"title":"单目3D室内检测","title_tokens":["单目","检测","3d","室内"]},{"location":"hhp/5.7_%E5%8D%95%E7%9B%AE3D%E5%AE%A4%E5%86%85%E6%A3%80%E6%B5%8B/#3d","text":"接下来，我们继续学习物体 3D 检测算法。 机器人有时候不仅仅要识别出人，还要识别出房间里有什么东西，这就是室内物体 3D 检测啦。 在HHP上，就集成了这样一套算法，接下来让我们一起来体验以下吧。 先来看一张图片，很明显大家可以看到图中有两个垃圾桶。","text_tokens":["东西","图片","起来","以下","机器人","我们","这样","两个","可以","，","接下来","很","下来","识别","一套","在","出人","这","有","吧","学习","明显"," ","房间","3d","物体","检测","看到","里","hhp","体验","一","算法","先","要","了","就","啦","有时","接下","有时候","让","来看","不仅","上","大家","不仅仅","集成","还要","一张","机器","就是","。","继续","什么","垃圾","图中","垃圾桶","仅仅","室内","时候","出"],"title":"单目3D室内检测","title_tokens":["单目","检测","3d","室内"]},{"location":"hhp/5.7_%E5%8D%95%E7%9B%AE3D%E5%AE%A4%E5%86%85%E6%A3%80%E6%B5%8B/#_1","text":"# 配置ROS2环境 $ source /opt/tros/setup.bash # 从tros的安装路径中拷贝出运行示例需要的配置文件。 $ cp -r /opt/tros/lib/mono3d_indoor_detection/config/ . # 启动launch文件 $ ros2 launch /opt/tros/share/mono3d_indoor_detection/launch/mono3d_indoor_detection.launch.py [ INFO ] [ 1654858490 .168592166 ] [ mono3d_detection ] : target type: trash_can [ INFO ] [ 1654858490 .168644750 ] [ mono3d_detection ] : target type: width, value: 236 .816406 [ INFO ] [ 1654858490 .168704333 ] [ mono3d_detection ] : target type: height, value: 305 .664062 [ INFO ] [ 1654858490 .168759584 ] [ mono3d_detection ] : target type: length, value: 224 .182129 [ INFO ] [ 1654858490 .168812334 ] [ mono3d_detection ] : target type: rotation, value: -1571.989179 [ INFO ] [ 1654858490 .168862543 ] [ mono3d_detection ] : target type: x, value: -191.977829 [ INFO ] [ 1654858490 .168916168 ] [ mono3d_detection ] : target type: y, value: -143.963307 [ INFO ] [ 1654858490 .168966502 ] [ mono3d_detection ] : target type: z, value: 714 .024127 [ INFO ] [ 1654858490 .169016794 ] [ mono3d_detection ] : target type: depth, value: 714 .024127 [ INFO ] [ 1654858490 .169067461 ] [ mono3d_detection ] : target type: score, value: 0 .973215 [ INFO ] [ 1654858490 .169168795 ] [ mono3d_detection ] : target type: trash_can [ INFO ] [ 1654858490 .169212837 ] [ mono3d_detection ] : target type: width, value: 253 .051758 [ INFO ] [ 1654858490 .169265004 ] [ mono3d_detection ] : target type: height, value: 282 .348633 [ INFO ] [ 1654858490 .169317046 ] [ mono3d_detection ] : target type: length, value: 257 .934570 [ INFO ] [ 1654858490 .169368921 ] [ mono3d_detection ] : target type: rotation, value: -1542.727947 [ INFO ] [ 1654858490 .169418671 ] [ mono3d_detection ] : target type: x, value: 552 .459776 [ INFO ] [ 1654858490 .169470588 ] [ mono3d_detection ] : target type: y, value: -164.073169 [ INFO ] [ 1654858490 .169517505 ] [ mono3d_detection ] : target type: z, value: 1088 .358164 [ INFO ] [ 1654858490 .169566839 ] [ mono3d_detection ] : target type: depth, value: 1088 .358164 [ INFO ] [ 1654858490 .169616464 ] [ mono3d_detection ] : target type: score, value: 0 .875521 很明显，已经识别到了两个垃圾桶。","text_tokens":["x","py","环境","168966502","]","182129","875521","明显",":","setup","1542.727947","source","282","y","168704333","launch","rotation","168862543","459776","拷贝","配置文件","width","169418671","ros2","垃圾","垃圾桶","score","168759584","示例","，","305","depth","tros","height","236","1088","can","路径","169616464",".","target","了","info","253","169566839","664062","config","169470588","348633","168644750","169265004","169168795","191.977829","出","168812334","两个","169517505","到","r","很","#","文件","识别","051758","从","运行","安装","需要","detection",",","169212837","type","-","配置","973215","_","1654858490","169016794","length","714","。","lib","224","opt","1571.989179","816406","bash","mono3d","的","552","168916168","share","169067461"," ","257","indoor","169368921","164.073169","value","启动","z","$","024127","已经","0","cp","168592166","143.963307","934570","169317046","中","trash","358164","/","["],"title":"运行示例程序","title_tokens":["示例","程序","运行"]},{"location":"hhp/5.7_%E5%8D%95%E7%9B%AE3D%E5%AE%A4%E5%86%85%E6%A3%80%E6%B5%8B/#_2","text":"// Copyright (c) 2022，Horizon Robotics. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"include/centernet_3d_detection_node.h\" #include <unistd.h> #include <fstream> #include <memory> #include <string> #include <vector> #include \"dnn_node/dnn_node.h\" #include \"include/image_utils.h\" #include \"rclcpp/rclcpp.hpp\" #include <sys/stat.h> #ifdef CV_BRIDGE_PKG_ENABLED #include <cv_bridge/cv_bridge.h> #endif using hobot :: easy_dnn :: OutputDescription ; using hobot :: easy_dnn :: OutputParser ; CenterNet3DDetectionNode :: CenterNet3DDetectionNode ( const std :: string & node_name , const NodeOptions & options ) : DnnNode ( node_name , options ), output_frameCount_ ( 0 ) { this -> declare_parameter < int > ( \"is_sync_mode\" , is_sync_mode_ ); this -> declare_parameter < std :: string > ( \"config_file_path\" , config_file_path_ ); this -> declare_parameter < int > ( \"shared_mem\" , shared_mem_ ); this -> declare_parameter < std :: string > ( \"ai_msg_pub_topic_name\" , msg_pub_topic_name_ ); this -> declare_parameter < std :: string > ( \"image_sub_topic_name\" , ros_img_topic_name_ ); this -> declare_parameter < std :: string > ( \"feed_image\" , feed_image_ ); this -> get_parameter < int > ( \"is_sync_mode\" , is_sync_mode_ ); this -> get_parameter < std :: string > ( \"config_file_path\" , config_file_path_ ); this -> get_parameter < int > ( \"shared_mem\" , shared_mem_ ); this -> get_parameter < std :: string > ( \"ai_msg_pub_topic_name\" , msg_pub_topic_name_ ); this -> get_parameter < std :: string > ( \"image_sub_topic_name\" , ros_img_topic_name_ ); this -> get_parameter < std :: string > ( \"feed_image\" , feed_image_ ); model_file_name_ = config_file_path_ + \"/centernet.hbm\" ; mkdir ( \"./result/\" , 666 ); std :: stringstream ss ; ss << \"Parameter:\" << \" \\n config_file_path_:\" << config_file_path_ << \" \\n shared_men:\" << shared_mem_ << \" \\n is_sync_mode_: \" << is_sync_mode_ << \" \\n model_file_name_: \" << model_file_name_ << \" \\n feed_image:\" << feed_image_ ; RCLCPP_WARN ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"%s\" , ss . str (). c_str ()); if ( Start () == 0 ) { RCLCPP_WARN ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"start success!!!\" ); } else { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"start fail!!!\" ); } } CenterNet3DDetectionNode ::~ CenterNet3DDetectionNode () {} int CenterNet3DDetectionNode :: Start () { int ret = Init (); if ( ret != 0 ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Init failed!\" ); return ret ; } ret = GetModelInputSize ( 0 , model_input_width_ , model_input_height_ ); if ( ret < 0 ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Get model input size fail!\" ); return ret ; } RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"The model input width is %d and height is %d\" , model_input_width_ , model_input_height_ ); msg_publisher_ = this -> create_publisher < ai_msgs :: msg :: PerceptionTargets > ( msg_pub_topic_name_ , 10 ); RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"msg_pub_topic_name: %s\" , msg_pub_topic_name_ . data ()); if ( ! feed_image_ . empty ()) { std :: cout << \"mono3d read image:\" << feed_image_ << \" to detect\" << std :: endl ; PredictByImage ( feed_image_ ); return 0 ; } // RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Detect images that use subscriptions\" ); if ( shared_mem_ ) { #ifdef SHARED_MEM_ENABLED RCLCPP_WARN ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Create hbmem_subscription with topic_name: %s\" , sharedmem_img_topic_name_ . c_str ()); sharedmem_img_subscription_ = this -> create_subscription_hbmem < hbm_img_msgs :: msg :: HbmMsg1080P > ( sharedmem_img_topic_name_ , 10 , std :: bind ( & CenterNet3DDetectionNode :: SharedMemImgProcess , this , std :: placeholders :: _1 )); #else RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Unsupport shared mem\" ); #endif } else { RCLCPP_WARN ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Create subscription with topic_name: %s\" , ros_img_topic_name_ . c_str ()); ros_img_subscription_ = this -> create_subscription < sensor_msgs :: msg :: Image > ( ros_img_topic_name_ , 10 , std :: bind ( & CenterNet3DDetectionNode :: RosImgProcess , this , std :: placeholders :: _1 )); } return 0 ; } int CenterNet3DDetectionNode :: SetNodePara () { RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Set node para.\" ); if ( ! dnn_node_para_ptr_ ) { return -1 ; } dnn_node_para_ptr_ -> model_file = model_file_name_ ; dnn_node_para_ptr_ -> model_name = model_name_ ; dnn_node_para_ptr_ -> model_task_type = model_task_type_ ; dnn_node_para_ptr_ -> task_num = 1 ; return 0 ; } int CenterNet3DDetectionNode :: SetOutputParser () { // set output parser auto model_manage = GetModel (); if ( ! model_manage || ! dnn_node_para_ptr_ ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Invalid model\" ); return -1 ; } if ( model_manage -> GetOutputCount () < model_output_count_ ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Error! Model %s output count is %d, unmatch with count %d\" , dnn_node_para_ptr_ -> model_name . c_str (), model_manage -> GetOutputCount (), model_output_count_ ); return -1 ; } for ( int i = 0 ; i < output_index_ ; ++ i ) { std :: shared_ptr < OutputParser > assist_parser = std :: make_shared < CenterNet3DAssistParser > (); model_manage -> SetOutputParser ( i , assist_parser ); } // set 3D paser auto output_desc = std :: make_shared < OutputDescription > ( model_manage , output_index_ , \"3D_branch\" ); for ( int i = 0 ; i < output_index_ ; ++ i ) { output_desc -> GetDependencies (). push_back ( i ); } output_desc -> SetType ( \"3D\" ); model_manage -> SetOutputDescription ( output_desc ); std :: shared_ptr < OutputParser > out_parser = std :: make_shared < CenterNet3DOutputParser > ( config_file_path_ ); model_manage -> SetOutputParser ( output_index_ , out_parser ); return 0 ; } #define CV_DRAW_LINE(p0, p1) \\ cv::line(image, cv::Point(points[p0][0], points[p0][1]), \\ cv::Point(points[p1][0], points[p1][1]), \\ CV_RGB(0, 255, 0), 2); #define CV_PUT_TEXT(text, px, py, offset) \\ { double fontScale = 3.0l; int thickness = 3u, baseline; \\ cv::Size text_size = cv::getTextSize(text, \\ cv::HersheyFonts::FONT_HERSHEY_PLAIN, fontScale, thickness, &baseline); \\ cv::Point point(px , py); \\ point.y += offset;\\ cv::Rect rect(point.x, point.y, \\ text_size.width, text_size.height); \\ point.y += text_size.height;\\ offset += text_size.height;\\ cv::putText(image, text, point, \\ cv::HersheyFonts::FONT_HERSHEY_PLAIN, \\ fontScale, CV_RGB(0, 255, 128), thickness); } void Render3DBox ( const BBox3D & box , cv :: Mat & image ) { auto & points = box . corners2d_upscale ; CV_DRAW_LINE ( 0 , 1 ) CV_DRAW_LINE ( 0 , 3 ) CV_DRAW_LINE ( 0 , 4 ) CV_DRAW_LINE ( 1 , 2 ) CV_DRAW_LINE ( 1 , 5 ) CV_DRAW_LINE ( 2 , 3 ) CV_DRAW_LINE ( 2 , 6 ) CV_DRAW_LINE ( 3 , 7 ) CV_DRAW_LINE ( 4 , 5 ) CV_DRAW_LINE ( 4 , 7 ) CV_DRAW_LINE ( 5 , 6 ) CV_DRAW_LINE ( 6 , 7 ) std :: string box_type = std :: to_string ( box . class_label ); std :: string score = std :: to_string ( box . score ); int offset = 0 ; if ( - M_PI_2 <= box . r || box . r <= M_PI_2 ) { CV_PUT_TEXT ( box_type , points [ 7 ][ 0 ], points [ 7 ][ 1 ], offset ); CV_PUT_TEXT ( score , points [ 7 ][ 0 ], points [ 7 ][ 1 ], offset ); } else { CV_PUT_TEXT ( box_type , points [ 6 ][ 0 ], points [ 6 ][ 1 ], offset ); CV_PUT_TEXT ( score , points [ 6 ][ 0 ], points [ 6 ][ 1 ], offset ); } } int CenterNet3DDetectionNode :: PostProcess ( const std :: shared_ptr < DnnNodeOutput > & node_output ) { if ( ! msg_publisher_ ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"example\" ), \"Invalid msg_publisher_\" ); return -1 ; } struct timespec time_start = { 0 , 0 }; clock_gettime ( CLOCK_REALTIME , & time_start ); ai_msgs :: msg :: Perf perf ; perf . set__type ( \"PostProcess\" ); perf . stamp_start . sec = time_start . tv_sec ; perf . stamp_start . nanosec = time_start . tv_nsec ; auto centernet_3d_output = std :: dynamic_pointer_cast < CenterNet3DOutput > ( node_output ); if ( centernet_3d_output ) { std :: stringstream ss ; ss << \"3D output dection info\" ; if ( centernet_3d_output -> image_msg_header_ ) { ss << \", frame_id: \" << centernet_3d_output -> image_msg_header_ -> frame_id << \", stamp: \" << centernet_3d_output -> image_msg_header_ -> stamp . sec << \".\" << centernet_3d_output -> image_msg_header_ -> stamp . nanosec ; } RCLCPP_DEBUG ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"%s\" , ss . str (). c_str ()); } const auto & outputs = node_output -> outputs ; RCLCPP_DEBUG ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"outputs size: %d\" , outputs . size ()); if ( outputs . empty () || static_cast < int32_t > ( outputs . size ()) < model_output_count_ ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Invalid outputs\" ); return -1 ; } int smart_fps = 0 ; { auto tp_now = std :: chrono :: system_clock :: now (); output_frameCount_ ++ ; auto interval = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( tp_now - output_tp_ ) . count (); if ( interval >= 1000 ) { smart_fps = output_frameCount_ ; RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Smart fps = %d\" , smart_fps ); output_frameCount_ = 0 ; output_tp_ = std :: chrono :: system_clock :: now (); } } ai_msgs :: msg :: PerceptionTargets :: UniquePtr pub_data ( new ai_msgs :: msg :: PerceptionTargets ()); if ( centernet_3d_output -> image_msg_header_ ) { pub_data -> header . set__stamp ( centernet_3d_output -> image_msg_header_ -> stamp ); pub_data -> header . set__frame_id ( centernet_3d_output -> image_msg_header_ -> frame_id ); } pub_data -> set__fps ( smart_fps ); auto * det_result = dynamic_cast < CenterNet3DDetResult *> ( outputs [ output_index_ ]. get ()); if ( ! det_result ) { RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"invalid cast\" ); } else { RCLCPP_DEBUG ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"out box size: %d\" , det_result -> boxes . size ()); std :: map < std :: string , ai_msgs :: msg :: Target > target_list ; std :: vector < ai_msgs :: msg :: Target > targets ; targets . reserve ( det_result -> boxes . size ()); for ( auto & box : det_result -> boxes ) { ai_msgs :: msg :: Target target ; switch ( box . class_label ) { case BBox3D :: CHARGING_BASE : target . type = \"charging_base\" ; break ; case BBox3D :: SLIPPER : target . type = \"slipper\" ; break ; case BBox3D :: TRASH_CAN : target . type = \"trash_can\" ; break ; } RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_detection\" ), \"target type: %s\" , target . type . c_str ()); ai_msgs :: msg :: Attribute attribute ; ai_msgs :: msg :: Point point ; attribute . type = \"width\" ; attribute . value = box . w * 1000. ; RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_detection\" ), \"target type: %s, value: %f\" , attribute . type . c_str (), attribute . value ); target . attributes . push_back ( attribute ); attribute . type = \"height\" ; attribute . value = box . h * 1000. ; RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_detection\" ), \"target type: %s, value: %f\" , attribute . type . c_str (), attribute . value ); target . attributes . push_back ( attribute ); attribute . type = \"length\" ; attribute . value = box . l * 1000. ; RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_detection\" ), \"target type: %s, value: %f\" , attribute . type . c_str (), attribute . value ); target . attributes . push_back ( attribute ); attribute . type = \"rotation\" ; attribute . value = box . r * 1000. ; RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_detection\" ), \"target type: %s, value: %f\" , attribute . type . c_str (), attribute . value ); target . attributes . push_back ( attribute ); attribute . type = \"x\" ; attribute . value = box . x * 1000. ; RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_detection\" ), \"target type: %s, value: %f\" , attribute . type . c_str (), attribute . value ); target . attributes . push_back ( attribute ); attribute . type = \"y\" ; attribute . value = box . y * 1000. ; RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_detection\" ), \"target type: %s, value: %f\" , attribute . type . c_str (), attribute . value ); target . attributes . push_back ( attribute ); attribute . type = \"z\" ; attribute . value = box . z * 1000. ; RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_detection\" ), \"target type: %s, value: %f\" , attribute . type . c_str (), attribute . value ); target . attributes . push_back ( attribute ); attribute . type = \"depth\" ; attribute . value = box . d * 1000. ; RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_detection\" ), \"target type: %s, value: %f\" , attribute . type . c_str (), attribute . value ); target . attributes . push_back ( attribute ); attribute . type = \"score\" ; attribute . value = box . score * 1000. ; RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_detection\" ), \"target type: %s, value: %f\" , attribute . type . c_str (), box . score ); target . attributes . push_back ( attribute ); // 8 corners /* 4----------5 6----------7 /| /| /| /| / | / | / | / | / | / | / | / | 7---|------6 |5---|------4 | | | | || | | | | | | || | | | | 0------|---1| 2------|---3 | / | / | / | / | / ^ | / | / v | / |/ |/ |/ |/ 3----------2 1----------0 */ for ( const auto & corners : box . corners2d_upscale ) { geometry_msgs :: msg :: Point32 g_point ; g_point . x = corners [ 0 ]; g_point . y = corners [ 1 ]; point . point . push_back ( g_point ); } point . type = \"corners\" ; target . points . push_back ( point ); targets . push_back ( target ); } pub_data -> targets = std :: move ( targets ); if ( ! centernet_3d_output -> image_name_ . empty ()) { auto img_bgr = cv :: imread ( centernet_3d_output -> image_name_ ); for ( auto & box : det_result -> boxes ) { Render3DBox ( box , img_bgr ); } std :: string :: size_type iPos = centernet_3d_output -> image_name_ . find_last_of ( '/' ) + 1 ; std :: string filename = centernet_3d_output -> image_name_ . substr ( iPos , centernet_3d_output -> image_name_ . length () - iPos ); cv :: imwrite ( \"./result/\" + filename , img_bgr ); } } clock_gettime ( CLOCK_REALTIME , & time_start ); perf . stamp_end . sec = time_start . tv_sec ; perf . stamp_end . nanosec = time_start . tv_nsec ; pub_data -> perfs . emplace_back ( perf ); msg_publisher_ -> publish ( std :: move ( pub_data )); return 0 ; } int CenterNet3DDetectionNode :: Predict ( std :: vector < std :: shared_ptr < DNNInput >> & inputs , const std :: shared_ptr < std :: vector < hbDNNRoi >> rois , std :: shared_ptr < DnnNodeOutput > dnn_output ) { return Run ( inputs , dnn_output , rois , is_sync_mode_ == 1 ); } void CenterNet3DDetectionNode :: RosImgProcess ( const sensor_msgs :: msg :: Image :: ConstSharedPtr img_msg ) { if ( ! img_msg || ! rclcpp :: ok ()) { return ; } std :: stringstream ss ; ss << \"Recved img encoding: \" << img_msg -> encoding << \", h: \" << img_msg -> height << \", w: \" << img_msg -> width << \", step: \" << img_msg -> step << \", frame_id: \" << img_msg -> header . frame_id << \", stamp: \" << img_msg -> header . stamp . sec << \".\" << img_msg -> header . stamp . nanosec << \", data size: \" << img_msg -> data . size (); RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"%s\" , ss . str (). c_str ()); auto tp_start = std :: chrono :: system_clock :: now (); // 1. 将图片处理成模型输入数据类型DNNInput // 使用图片生成pym，NV12PyramidInput为DNNInput的子类 std :: shared_ptr < hobot :: easy_dnn :: NV12PyramidInput > pyramid = nullptr ; if ( \"rgb8\" == img_msg -> encoding ) { #ifdef CV_BRIDGE_PKG_ENABLED auto cv_img = cv_bridge :: cvtColorForDisplay ( cv_bridge :: toCvShare ( img_msg ), \"bgr8\" ); { auto tp_now = std :: chrono :: system_clock :: now (); auto interval = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( tp_now - tp_start ) . count (); RCLCPP_DEBUG ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"after cvtColorForDisplay cost ms: %d\" , interval ); } pyramid = ImageUtils :: GetNV12Pyramid ( cv_img -> image , model_input_height_ , model_input_width_ ); #else RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Unsupport cv bridge\" ); #endif } else if ( \"nv12\" == img_msg -> encoding ) { pyramid = ImageUtils :: GetNV12PyramidFromNV12Img ( reinterpret_cast < const char *> ( img_msg -> data . data ()), img_msg -> height , img_msg -> width , model_input_height_ , model_input_width_ ); } if ( ! pyramid ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Get Nv12 pym fail\" ); return ; } { auto tp_now = std :: chrono :: system_clock :: now (); auto interval = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( tp_now - tp_start ) . count (); RCLCPP_DEBUG ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"after GetNV12Pyramid cost ms: %d\" , interval ); } RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Dnn node begin to predict\" ); // 2. 使用pyramid创建DNNInput对象inputs // inputs将会作为模型的输入通过RunInferTask接口传入 auto inputs = std :: vector < std :: shared_ptr < DNNInput >> { pyramid }; auto dnn_output = std :: make_shared < CenterNet3DOutput > (); dnn_output -> src_img_width_ = img_msg -> width ; dnn_output -> src_img_height_ = img_msg -> height ; dnn_output -> image_msg_header_ = std :: make_shared < std_msgs :: msg :: Header > (); dnn_output -> image_msg_header_ -> set__frame_id ( img_msg -> header . frame_id ); dnn_output -> image_msg_header_ -> set__stamp ( img_msg -> header . stamp ); dnn_output -> image_name_ = \"\" ; // 3. 开始预测 uint32_t ret = Predict ( inputs , nullptr , dnn_output ); { auto tp_now = std :: chrono :: system_clock :: now (); auto interval = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( tp_now - tp_start ) . count (); RCLCPP_DEBUG ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"after Predict cost ms: %d\" , interval ); } if ( ret != 0 ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"predict img failed!\" ); } return ; } int CenterNet3DDetectionNode :: PredictByImage ( const std :: string & image ) { // 1. 将图片处理成模型输入数据类型DNNInput // 使用图片生成pym，NV12PyramidInput为DNNInput的子类 std :: shared_ptr < hobot :: easy_dnn :: NV12PyramidInput > pyramid = nullptr ; // bgr img，支持将图片resize到模型输入size pyramid = ImageUtils :: GetNV12Pyramid ( image , ImageType :: BGR , model_input_height_ , model_input_width_ ); if ( ! pyramid ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Get Nv12 pym fail with image: %s\" , image . c_str ()); return -1 ; } // 2. 使用pyramid创建DNNInput对象inputs // inputs将会作为模型的输入通过RunInferTask接口传入 auto inputs = std :: vector < std :: shared_ptr < DNNInput >> { pyramid }; auto dnn_output = std :: make_shared < CenterNet3DOutput > (); dnn_output -> src_img_width_ = 1920 ; dnn_output -> src_img_height_ = 1024 ; dnn_output -> image_msg_header_ = std :: make_shared < std_msgs :: msg :: Header > (); dnn_output -> image_msg_header_ -> set__frame_id ( \"test_frame\" ); dnn_output -> image_msg_header_ -> set__stamp ( rclcpp :: Time ()); dnn_output -> image_name_ = image ; // dnn_output->image_msg_header->set__frame_id(std::to_string(img_msg->index)); // dnn_output->image_msg_header->set__stamp(img_msg->time_stamp); // 3. 开始预测 uint32_t ret = Predict ( inputs , nullptr , dnn_output ); if ( ret != 0 ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"predict img failed!\" ); } return ret ; } #ifdef SHARED_MEM_ENABLED void CenterNet3DDetectionNode :: SharedMemImgProcess ( const hbm_img_msgs :: msg :: HbmMsg1080P :: ConstSharedPtr img_msg ) { if ( ! img_msg || ! rclcpp :: ok ()) { return ; } RCLCPP_DEBUG ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"go into shared mem\" ); // dump recved img msg // std::ofstream ofs(\"img_\" + std::to_string(img_msg->index) + \".\" + // std::string(reinterpret_cast<const char*>(img_msg->encoding.data()))); // ofs.write(reinterpret_cast<const char*>(img_msg->data.data()), // img_msg->data_size); auto tp_start = std :: chrono :: system_clock :: now (); // 1. 将图片处理成模型输入数据类型DNNInput // 使用图片生成pym，NV12PyramidInput为DNNInput的子类 std :: shared_ptr < hobot :: easy_dnn :: NV12PyramidInput > pyramid = nullptr ; if ( \"nv12\" == std :: string ( reinterpret_cast < const char *> ( img_msg -> encoding . data ()))) { pyramid = ImageUtils :: GetNV12PyramidFromNV12Img ( reinterpret_cast < const char *> ( img_msg -> data . data ()), img_msg -> height , img_msg -> width , model_input_height_ , model_input_width_ ); } else { RCLCPP_INFO ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"share mem unsupported img encoding: %s\" , img_msg -> encoding ); } if ( ! pyramid ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Get Nv12 pym fail!\" ); return ; } { auto tp_now = std :: chrono :: system_clock :: now (); auto interval = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( tp_now - tp_start ) . count (); RCLCPP_DEBUG ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"after GetNV12Pyramid cost ms: %d\" , interval ); } // 2. 使用pyramid创建DNNInput对象inputs // inputs将会作为模型的输入通过RunInferTask接口传入 auto inputs = std :: vector < std :: shared_ptr < DNNInput >> { pyramid }; auto dnn_output = std :: make_shared < CenterNet3DOutput > (); dnn_output -> src_img_width_ = img_msg -> width ; dnn_output -> src_img_height_ = img_msg -> height ; dnn_output -> image_msg_header_ = std :: make_shared < std_msgs :: msg :: Header > (); dnn_output -> image_msg_header_ -> set__frame_id ( std :: to_string ( img_msg -> index )); dnn_output -> image_msg_header_ -> set__stamp ( img_msg -> time_stamp ); // 3. 开始预测 int ret = Predict ( inputs , nullptr , dnn_output ); { auto tp_now = std :: chrono :: system_clock :: now (); auto interval = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( tp_now - tp_start ) . count (); RCLCPP_DEBUG ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"after Predict cost ms: %d\" , interval ); } // 4. 处理预测结果，如渲染到图片或者发布预测结果 if ( ret != 0 ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"mono3d_indoor_detection\" ), \"Run predict failed!\" ); } return ; } #endif","text_tokens":["x","ipos","after","py","parser","centernet3dassistparser","options","path","如","mem","output","failed","id","%","unsupport","header","255","static","find","ros","attribute","10","子类","attributes","ret","ifdef","6","www","out","pointer","limitations","类型","fail","使用","成","targets","centernet3ddetectionnode","nodeoptions","centernet3doutput","can",".","vector","target","v","int","info","ok","imagetype","put","see","sync","cost","config","l",";","desc","time","obtain","robotics","sec","setoutputdescription","g","通过","#","void","end","as","hbmmsg1080p","outputs","offset","-","task","map","licenses","outputdescription","8","1000","if","hershey","example","uint32",")","1920","text","to","draw","处理","mono3d","agreed","either","1024","indoor","3d","tocvshare","stat","charging","emplace","value","h","hobot","plain","perf","p0","constsharedptr","success","milliseconds","---","rosimgprocess","bgr8","0","into","dnnnodeoutput","enabled","include","manage","hbmem","det","trash","points","cvtcolorfordisplay","n","count","dynamic","predict","input","node","box","of","base","&","not","corners","pym","setnodepara","reinterpret","logger","centernet3ddetresult","you","----------","subscriptions","encoding","y","sensor","software","'","writing","dnninput","ss","score","utils","支持","接口","3u","gettime","bgr","class","recved","law","upscale","stamp","a","------","resize","unmatch","line","dection","d","horizon","inputs","pkg","that","case","make","apache","settype","licensed","error","break","7","thickness","sys","detection","org","back","start","gettextsize","paser","5","_","the","image","use","debug","outputparser","nv12","result","read","corners2d","detect","*","boxes","predictbyimage","生成","将","或者","\\","shared","perfs","init","label","对象","!","const","specific","=","struct","under","switch","puttext","substr","index","using","/","warranties","<","name","2","basis","topic","implied","parameter","]",":","cv","src","\"","rgb","getmodel","an","ofstream","geometry","on","distributed","p1","timespec","sub","ofs","imread","渲染","write","interval","dnnnode","push","，","depth","height","__","create","uniqueptr","(","cast","now","hbdnnroi","str","para","666","kind","and","预测","invalid","baseline","rclcpp","数据类型","chrono","realtime","model","in","模型","point32","language","test","subscription","setoutputparser","r","rgb8","express","postprocess","img","nanosec","3.0","by","or","run","conditions","sharedmemimgprocess","128","version","rect","length","last","cout","images","|","unsupported","作为","i","nv12pyramidinput","copy","fstream","applicable","msg","slipper","bbox3d","compliance","bridge","输入","的","assist","+","为",">","getoutputcount"," ","centernet","3","begin","2022","reserve","t","at","easy","move","branch","getnv12pyramidfromnv12img","this","list","unistd","hpp","^","http","string","图片","w","endif","数据","render3dbox","auto","ms","framecount","mode","1","hersheyfonts","getmodelinputsize","font","px","go","char","rotation","传入","new","publish","point","++","4","width","hbm","dnn","nsec","without","s","size","is","imageutils","nullptr","fps","tp","f","msgs","license","rois","for","runinfertask","发布","{","2.0","unless","governing","memory","double","return","创建","开始","placeholders","smart","getdependencies","centernet3doutputparser","declare","到","required","num","define","int32","copyright","frame",",","mat","ai","type","except","any","c","set","tv","std","permissions","ptr","}","perceptiontargets","fontscale","mkdir","pub","else","结果","warn","pi","with","empty","system","step","imwrite","share","duration","getnv12pyramid","sharedmem","pyramid","将会","may","clock","stringstream","data","z","~","filename","feed","dump","publisher","endl","bind","file","men","get","[","m"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"hhp/6.1_SLAM%E5%BB%BA%E5%9B%BE/","text":"SLAM建图 从这一节开始，我们开始尝试将 TogetherROS 与机器人联系起来做一些小项目。 第一节将开始学习 SLAM 技术。SLAM一般指即时定位与地图构建，即时定位与地图构建（Simultaneous Localization and Mapping，简称SLAM） 这个章节，我们将联系ROS2 和 TogetherROS ，使用 ROS2 的 SLAM-Toolbox 作为建图算法，在仿真环境中构建地图。 准备工作 1、安装 SLAM - Toolbox建立软链接 $ sudo apt-get install ros-foxy-slam-toolbox $ cd /opt/tros $ sudo python3 create_soft_link.py --foxy /opt/ros/foxy/ --tros /opt/tros/ 2、搭载仿真环境，此处采用 turtlebot3 仿真环境 $ sudo apt-get install ros-foxy-gazebo-* $ sudo apt install ros-foxy-turtlebot3 $ sudo apt install ros-foxy-turtlebot3-bringup $ sudo apt install ros-foxy-turtlebot3-simulations $ sudo apt install ros-foxy-teleop-twist-keyboard 使用介绍 首先在 PC 端启动仿真环境 $ source /opt/ros/foxy/setup.bash $ export TURTLEBOT3_MODEL = burger $ ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py Attention 第一次加载可能比较慢，原因是正在下载部分需要的插件。 打开后，即可看到如图: 在PC端打开一个新终端： $ source /opt/ros/foxy/setup.bash $ ros2 launch turtlebot3_bringup rviz2.launch.py 此时会打开一个RVIZ2 ，需要添加“map” 如下图： 旭日X3 派运行 SLAM-Toolbox： # 配置TogetherROS环境 $ source /opt/tros/setup.bash #启动SLAM launch文件 $ ros2 launch slam_toolbox online_sync_launch.py 此处有可能会遇到缺少lib文件问题，如果发生的话如下操作： $ sudo vi /etc/ld.so.conf #在其后增加： /usr/local/lib #保存退出： $ sudo ldconfig PC端再打开一个新终端，遥控建图： $ source /opt/ros/foxy/setup.bash $ ros2 run teleop_twist_keyboard teleop_twist_keyboard 效果如图： 建图结果","text_tokens":["如果","conf","2","py","foxy","技术","打开","定位","ldconfig","环境","如图","终端","第一","再",":","与","1","setup","派","source","比较慢","后","的话","搭载","、","仿真","较慢","launch","小","指","apt","即时","添加","介绍","gazebo","机器","ros","遥控","第一节","ros2","可能","twist","其后","准备","起来","机器人","我们","，","遇到","使用","tros","退出","工作","create","学习","simulations","一些","turtlebot3",".","x3","操作","简称","一节","sync","bringup","and","发生","so","尝试","链接","比较","如下","model","keyboard","python3","mapping","开始","建图","部分","burger","问题","usr","--","#","文件","首先","在","toolbox","从","soft","原因","运行","安装","localization","需要","togetherros","teleop","算法","此处","章节","-","etc","配置","此时","软","地图","online","_","项目","vi","map","export","run","一个","插件","会","rviz2","作为","link","加载","图","。","lib","第一次","install","一般","*","一次","world","opt","attention","采用","是","结果","即可","bash","：","cd","的","端","（","构建","将","和","旭日","这","有","local","simultaneous"," ","看到","这个","）","启动","效果","pc","ld","新","下载","“","保存","$","=","”","增加","slam","联系","缺少","正在","中","sudo","建立","做","get","/"],"title":"SLAM地图构建","title_tokens":["构建","slam","地图"]},{"location":"hhp/6.1_SLAM%E5%BB%BA%E5%9B%BE/#slam","text":"从这一节开始，我们开始尝试将 TogetherROS 与机器人联系起来做一些小项目。 第一节将开始学习 SLAM 技术。SLAM一般指即时定位与地图构建，即时定位与地图构建（Simultaneous Localization and Mapping，简称SLAM） 这个章节，我们将联系ROS2 和 TogetherROS ，使用 ROS2 的 SLAM-Toolbox 作为建图算法，在仿真环境中构建地图。","text_tokens":["起来","机器人","我们","，","的","技术","（","定位","构建","使用","在","将","环境","toolbox","从","和","这","simultaneous","第一","学习"," ","localization","与","这个","togetherros","）","一些","算法","章节","-","仿真","小","指","一节","地图","项目","简称","即时","and","尝试","slam","机器","联系","作为","。","mapping","中","第一节","ros2","做","一般","开始","建图"],"title":"SLAM建图","title_tokens":["slam","建图"]},{"location":"hhp/6.1_SLAM%E5%BB%BA%E5%9B%BE/#_1","text":"1、安装 SLAM - Toolbox建立软链接 $ sudo apt-get install ros-foxy-slam-toolbox $ cd /opt/tros $ sudo python3 create_soft_link.py --foxy /opt/ros/foxy/ --tros /opt/tros/ 2、搭载仿真环境，此处采用 turtlebot3 仿真环境 $ sudo apt-get install ros-foxy-gazebo-* $ sudo apt install ros-foxy-turtlebot3 $ sudo apt install ros-foxy-turtlebot3-bringup $ sudo apt install ros-foxy-turtlebot3-simulations $ sudo apt install ros-foxy-teleop-twist-keyboard","text_tokens":["opt","采用","2","py","cd","foxy","，","--","tros","环境","toolbox","soft","create","simulations","安装"," ","1","turtlebot3",".","teleop","搭载","、","-","此处","仿真","软","apt","_","bringup","$","slam","gazebo","链接","link","ros","install","sudo","建立","keyboard","get","twist","python3","/","*"],"title":"准备工作","title_tokens":["工作","准备"]},{"location":"hhp/6.1_SLAM%E5%BB%BA%E5%9B%BE/#_2","text":"首先在 PC 端启动仿真环境 $ source /opt/ros/foxy/setup.bash $ export TURTLEBOT3_MODEL = burger $ ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py Attention 第一次加载可能比较慢，原因是正在下载部分需要的插件。 打开后，即可看到如图: 在PC端打开一个新终端： $ source /opt/ros/foxy/setup.bash $ ros2 launch turtlebot3_bringup rviz2.launch.py 此时会打开一个RVIZ2 ，需要添加“map” 如下图： 旭日X3 派运行 SLAM-Toolbox： # 配置TogetherROS环境 $ source /opt/tros/setup.bash #启动SLAM launch文件 $ ros2 launch slam_toolbox online_sync_launch.py 此处有可能会遇到缺少lib文件问题，如果发生的话如下操作： $ sudo vi /etc/ld.so.conf #在其后增加： /usr/local/lib #保存退出： $ sudo ldconfig PC端再打开一个新终端，遥控建图： $ source /opt/ros/foxy/setup.bash $ ros2 run teleop_twist_keyboard teleop_twist_keyboard 效果如图：","text_tokens":["如果","conf","py","foxy","打开","ldconfig","环境","如图","终端","第一","再",":","setup","派","source","比较慢","后","的话","仿真","较慢","launch","添加","gazebo","ros","遥控","ros2","可能","twist","其后","，","遇到","tros","退出","turtlebot3",".","x3","操作","sync","bringup","发生","so","比较","如下","model","keyboard","建图","部分","burger","问题","usr","#","文件","首先","在","toolbox","原因","运行","需要","togetherros","teleop","etc","此处","-","配置","此时","online","_","vi","map","export","run","一个","插件","会","rviz2","图","加载","。","lib","第一次","一次","world","opt","attention","是","即可","bash","：","的","端","旭日","有","local"," ","看到","启动","效果","pc","ld","新","下载","“","保存","$","=","”","增加","slam","缺少","正在","sudo","/"],"title":"使用介绍","title_tokens":["介绍","使用"]},{"location":"hhp/6.1_SLAM%E5%BB%BA%E5%9B%BE/#_3","text":"","text_tokens":[],"title":"建图结果","title_tokens":["结果","建图"]},{"location":"hhp/6.2_%E5%B0%8F%E8%BD%A6%E4%BA%BA%E4%BD%93%E8%B7%9F%E9%9A%8F/","text":"小车人体跟随 之前我们介绍了如何利用 X3派 进行人体检测和跟踪，那么加入我们想要将体检测和跟踪和真实机器人做一个结合会是一种什么样的体验呢？ 这里，我们将通过X3派检测到的人体目标进行一个移动跟踪，最终的一个效果就是当装配着X3派和摄像头的小车面前出现一个人物时，小车将会跟随着人体一起移动。接下来，让我们一起来体验一下吧。 编程开发方法 先来看整个程序的流程图： 这里，我们将通过 Gazebo 仿真环境下的虚拟小车作为真实机器，首先，让我们来做一些准备工作。 在PC端搭建一个仿真环境： $ sudo apt-get install ros-foxy-gazebo-* $ sudo apt install ros-foxy-turtlebot3 $ sudo apt install ros-foxy-turtlebot3-simulations 使用介绍 首先在 PC 端启动仿真环境 $ source /opt/ros/foxy/setup.bash $ export TURTLEBOT3_MODEL = burger $ ros2 launch turtlebot3_gazebo empty_world.launch.py Attention 第一次加载可能比较慢，原因是正在下载部分需要的插件。 如下图所见： 旭日X3 派运行 如下指令： # 配置TogetherROS环境 $ source /opt/tros/setup.bash # 从TogetherROS的安装路径中拷贝出运行示例需要的配置文件。 $ cp -r /opt/tros/lib/mono2d_body_detection/config/ . #启动launch文件 $ ros2 launch body_tracking hobot_body_tracking_without_gesture.launch.py 接下来，只需要你站在摄像头面前左右前后移动，就会发现仿真环境下的小车也会跟着你移动。 再来看终端输出的信息： $ ros2 topic echo /cmd_vel linear: x: 0.5 y: 0.0 z: 0.0 angular: x: 0.0 y: 0.0 z: -0.5 --- linear: x: 0.5 y: 0.0 z: 0.0 angular: x: 0.0 y: 0.0 z: -0.5 --- 跟随效果","text_tokens":["x","py","只","linear","foxy","gesture","指令","mono2d","topic","cmd","最终","环境","再","终端","第一",":","一下","编程","？","图所见","setup","派","source","体验","跟","比较慢","站","先","仿真","想要","就","较慢","y","launch","结合","apt","随着","让","介绍","gazebo","机器","就是","摄像","ros","拷贝","配置文件","angular","什么","ros2","可能","开发","准备","without","起来","机器人","示例","我们","人体","0.5","，","下来","出现","使用","tros","工作","simulations","装配","程序","路径","这里","一些","turtlebot3","当","一",".","所见","呢","了","tracking","x3","什么样","左右","config","小车","比较","如下","model","跟着","出","部分","人物","burger","跟踪","流程","到","接下来","通过","#","文件","r","首先","进行","信息","发现","echo","在","移动","原因","从","吧","运行","下","需要","安装","detection","检测","togetherros","输出","开发方法","-","前后","配置","接下","也","_","export","来看","一个","插件","会","虚拟","目标","作为","加载","。","利用","lib","第一次","一起","像头","install","*","一次","world","opt","attention","是","真实","摄像头","一种","：","bash","empty","的","端","着","来","面前","你","将","vel","和","旭日","方法","加入"," ","整个","那么","如何","将体","搭建","启动","效果","将会","hobot","pc","body","时","z","下载","之前","---","$","=","跟随","流程图","0.0","cp","正在","中","sudo","做","get","/"],"title":"小车人体跟随","title_tokens":["跟随","人体","小车"]},{"location":"hhp/6.2_%E5%B0%8F%E8%BD%A6%E4%BA%BA%E4%BD%93%E8%B7%9F%E9%9A%8F/#_1","text":"之前我们介绍了如何利用 X3派 进行人体检测和跟踪，那么加入我们想要将体检测和跟踪和真实机器人做一个结合会是一种什么样的体验呢？ 这里，我们将通过X3派检测到的人体目标进行一个移动跟踪，最终的一个效果就是当装配着X3派和摄像头的小车面前出现一个人物时，小车将会跟随着人体一起移动。接下来，让我们一起来体验一下吧。","text_tokens":["是","真实","起来","人物","机器人","跟踪","我们","人体","一种","摄像头","，","的","通过","到","着","面前","下来","进行","出现","最终","接下来","将","移动","和","吧","加入","装配"," ","一下","那么","？","这里","如何","检测","派","体验","将体","当","跟","一","效果","呢","了","将会","想要","x3","结合","时","接下","什么样","之前","随着","让","一个","介绍","会","小车","目标","机器","就是","摄像","。","利用","什么","像头","一起","做"],"title":"小车人体跟随","title_tokens":["跟随","人体","小车"]},{"location":"hhp/6.2_%E5%B0%8F%E8%BD%A6%E4%BA%BA%E4%BD%93%E8%B7%9F%E9%9A%8F/#_2","text":"先来看整个程序的流程图： 这里，我们将通过 Gazebo 仿真环境下的虚拟小车作为真实机器，首先，让我们来做一些准备工作。 在PC端搭建一个仿真环境： $ sudo apt-get install ros-foxy-gazebo-* $ sudo apt install ros-foxy-turtlebot3 $ sudo apt install ros-foxy-turtlebot3-simulations","text_tokens":["真实","我们","：","流程","foxy","的","，","通过","来","端","首先","环境","将","工作","在","simulations"," ","整个","下","程序","这里","一些","turtlebot3","搭建","先","-","仿真","pc","apt","$","来看","让","一个","虚拟","流程图","gazebo","小车","机器","作为","ros","。","install","sudo","做","get","*","准备"],"title":"编程开发方法","title_tokens":["编程","开发方法","方法","开发"]},{"location":"hhp/6.2_%E5%B0%8F%E8%BD%A6%E4%BA%BA%E4%BD%93%E8%B7%9F%E9%9A%8F/#_3","text":"首先在 PC 端启动仿真环境 $ source /opt/ros/foxy/setup.bash $ export TURTLEBOT3_MODEL = burger $ ros2 launch turtlebot3_gazebo empty_world.launch.py Attention 第一次加载可能比较慢，原因是正在下载部分需要的插件。 如下图所见： 旭日X3 派运行 如下指令： # 配置TogetherROS环境 $ source /opt/tros/setup.bash # 从TogetherROS的安装路径中拷贝出运行示例需要的配置文件。 $ cp -r /opt/tros/lib/mono2d_body_detection/config/ . #启动launch文件 $ ros2 launch body_tracking hobot_body_tracking_without_gesture.launch.py 接下来，只需要你站在摄像头面前左右前后移动，就会发现仿真环境下的小车也会跟着你移动。 再来看终端输出的信息： $ ros2 topic echo /cmd_vel linear: x: 0.5 y: 0.0 z: 0.0 angular: x: 0.0 y: 0.0 z: -0.5 --- linear: x: 0.5 y: 0.0 z: 0.0 angular: x: 0.0 y: 0.0 z: -0.5 ---","text_tokens":["x","py","只","linear","foxy","gesture","指令","mono2d","topic","cmd","环境","再","终端","第一",":","图所见","setup","派","source","比较慢","站","仿真","就","较慢","y","launch","gazebo","摄像","ros","拷贝","配置文件","angular","ros2","可能","without","示例","0.5","，","下来","tros","路径","turtlebot3",".","所见","tracking","x3","左右","config","小车","比较","如下","model","跟着","出","部分","burger","r","接下来","#","文件","echo","首先","信息","发现","在","移动","原因","从","运行","需要","安装","detection","下","togetherros","输出","前后","-","配置","接下","也","_","export","来看","插件","会","加载","。","lib","第一次","像头","一次","world","opt","attention","是","bash","：","摄像头","empty","的","端","面前","你","vel","旭日"," ","启动","hobot","pc","body","z","下载","---","$","=","0.0","cp","正在","中","/"],"title":"使用介绍","title_tokens":["介绍","使用"]},{"location":"hhp/6.2_%E5%B0%8F%E8%BD%A6%E4%BA%BA%E4%BD%93%E8%B7%9F%E9%9A%8F/#_4","text":"","text_tokens":[],"title":"跟随效果","title_tokens":["跟随","效果"]}]}